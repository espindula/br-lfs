<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
  "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../general.ent">
  %general-entities;
]>

<sect1 id="ch-scripts-symlinks">
  <?dbhtml filename="symlinks.html"?>

  <title>Gérer les périphériques</title>

  <sect2>

    <title>Périphériques réseaux</title>

    <para>Udev, par défaut, nomme les périphériques réseaux à partir des données
    du Firmware/BIOS ou de leurs caractéristiques physiques comme leur bus, leur
    slot ou leur adresse MAC.  Le but de cette convention de nommage est de vous
    assurer que les périphériques réseaux aient un nommage cohérent qui ne s'appuie pas sur
    le moment où la carte réseau a été trouvée. Par exemple, sur un ordinateur 
    ayant deux cartes réseaux Intel et Realtek, il se peut que la carte réseau 
    Intel s'appelle eth0 et celle Realtek eth1. Dans certains cas, au redémarrage,
    les cartes sont numérotées en sens inverse.</para>
    
    <para>Avec la nouvelle règle de nommage, les noms des cartes réseaux
    ressembleraient en général à quelque chose comme enp5s0 ou wlp3s0. Si cette
    convention de nommage ne vous plaît pas, vous pouvez implémenter celle
    traditionnelle ou une autre personnalisée.</para>

    <sect3>
      <title>Désactiver la conservation des noms en ligne de commandes du noyau</title>
   
      <para>La règle de nommage traditionnel qui utilise eth0, eth1, etc peut
      être rétablie en ajoutant <userinput>net.ifnames=0</userinput> à la ligne de
      commandes du noyau. C'est surtout adapté aux systèmes  n'ayant qu'un périphérique
      ethernet du même type.  Les portables ont souvent plusieurs ports ethernet
      appelés eth0 et wlan0 et ils sont éligibles à cette méthode.  La ligne de
      commandes se passe dans le fichier de configuration de GRUB. Voir
      <xref linkend="grub-cfg"/>.</para>
    </sect3>

    <sect3>
      <title>Créer des règles Udev personnalisées</title>
   
      <para>Vous pouvez personnaliser les règles de nommage en créant des
      règles Udev personnalisées. Un script est inclu pour générer les règles initiales.
      Générez ces règles en lançant&nbsp;:</para>

<screen role="install"><userinput>bash /lib/udev/init-net-rules.sh</userinput></screen>

      <para>Maintenant, lisez le fichier
      <filename>/etc/udev/rules.d/70-persistent-net.rules</filename> pour
      trouver le nom affecté à une carte réseau&nbsp;:</para>

<screen role="nodump"><userinput>cat /etc/udev/rules.d/70-persistent-net.rules</userinput></screen>

      <note><para>Dans certains cas, comme par exemple quand une adresse MAC est
      affectée manuellement à une carte réseau, ou dans un environnement virtuel
      tel que Qemu ou Xen, il se peut que le fichier des règles du réseau n'ait pas
      été généré car les adresses ne sont pas affectées de façon cohérente. Dans
      ce cas, vous ne pouvez pas utiliser cette méthode.</para></note>
  
      <para>Le fichier commence par un bloc en commentaire suivi de deux lignes
      pour chaque NIC. La première ligne d'un NIC est une description commentée
      indiquant ses IDs matériels (comme ses IDs PCi de fabricant et de
      vendeur si la carte est PCI), avec le silote entre parenthèses, si on peut
      trouver le pilote. Ni l'ID matériel ni ;e pilote ne sont utilisés pour
      déterminer le nom à donner à une interface&nbsp;; ces informations ne
      sont là que pour information. La deuxième ligne est la règle Udev correspondant
      à cette NIC et qui affecte un nom.</para>
  
      <para>Toutes les règles Udev se composent de clés séparées par des virgules
      et éventuellement des espaces. Les clés de cette règle et l'explication de chacune
      sont ainsi&nbsp;:</para>
  
      <itemizedlist>
        <listitem>
          <para><literal>SUBSYSTEM=="net"</literal> - Ceci dit à Udev d'ignorer
          les périphériques n'étant par des cartes réseaux.</para>
        </listitem>
        <listitem>
          <para><literal>ACTION=="add"</literal> - Ceci dit à Udev d'ignorer
          la règle pour un uevent autre que l'ajout (les ue1rdns "remove" et
          "change" se produisent aussi mais il n'est pas utile de renommer les
          interfaces réseaux).</para>
        </listitem>
        <listitem>
          <para><literal>DRIVERS=="?*"</literal> - Ceci existe pour que Udev 
          ignore les sous-interfaces VLAN ou les ponts (ces interfaces n'ayant pas
          de pilote). Ces sous-interfaces sont passées 
          car le nom qui leur serait affecté entrerait en conflit avec 
          leurs périphériques parents.</para>
        </listitem>
        <listitem>
          <para><literal>ATTR{address}</literal> - La valeur de cette clé est
          l'adresse MAC de la NIC.</para>
        </listitem>
        <listitem>
          <para><literal>ATTR{type}=="1"</literal> - Ceci garantit que la règle
          ne corresponde qu'à l'interface primaire au cas où certains pilotes
          sans fil créent plusieurs interfaces virtuelles. Les interfaces
          secondaires sont passées pour la même raison qu'on évite les sous-interfaces 
          VLAN et des ponts&nbsp;: il y aurait conflit de noms.</para>
        </listitem>
        <listitem>
          <para><literal>NAME</literal> - La valeur de cette clé est le nom
          donné par Udev à cette interface.</para>
        </listitem>
      </itemizedlist>
 
      <para>La valeur de <literal>NAME</literal> est ce qui compte. Assurez-vous
      de connaître le nom affecté à chacune de vos cartes réseaux avant de
      continuer et d'utiliser cette valeur <literal>NAME</literal> quand vous
      créez vos fichiers de configuration ci-dessous.</para>

    </sect3>

    <!--<sect3>
      <title>Nommage personnalisé avec Systemd</title>
   
      <para>Vous pouvez également personnaliser le nom des interfaces réseaux 
      avec un ensemble de fichiers spécifiques à systemd. Un fichier ayant un nom
      comme 10-eth0.link dans le répertoire /etc/systemd/network peut définir
      le nom d'une interface. Tous les fichiers du répertoire seront traités de
      façon alphabétique. Les fichiers du répertoire /lib/systemd/network ayant
      le même nom que ceux qui sont dans /etc/systemd/network seront dominés.
      Voir la page de man de systemd.link pour une explication complète.</para>

      <para>Un exemple de fichier ressemble à&nbsp;:</para>

<screen role="nodump">[Match]
MACAddress=12:34:56:78:9a:bc
Driver=brcmsmac
Path=pci-0000:02:00.0-*
Type=wlan
Virtualization=no
Host=my-laptop
Architecture=x86-64

[Link]
Name=wireless0
MTUBytes=1450
BitsPerSecond=10M
WakeOnLan=magic
MACAddress=cb:a9:87:65:43:21</screen>

    <para>La section [Match] spécifie le moment où appliquer la règle. Dans
    l'exemple ci-dessus, les entrées peuvent être raccourcies au minimum requis
    pour une identification unique du périphérique réseau. De même, la section
    [Link] n'a besoin que de spécifier les changements désirés par rapport aux
    comportements par défaut. Le plus souvent, la seule chose utile est l'entrée
    Name.</para>

    </sect3>-->

  </sect2>
 
   <sect2>

    <title>Liens symboliques pour le CD-ROM</title>

    <para>Certains logiciels que vous pourriez vouloir installer plus
    tard (comme divers lecteurs multimédias) s'attendent à ce que les
    liens symboliques <filename class="symlink">/dev/cdrom</filename> et
    <filename class="symlink">/dev/dvd</filename> existent et pointent
    vers le lecteur CD-ROM ou DVD-ROM. De plus, il peut être pratique de
    mettre des références à ces liens symboliques dans <filename>/etc/fstab</filename>. Udev
    est fourni avec un script qui génèrera des fichiers de règles pour créer ces liens symboliques
    pour vous, selon les possibilités de chaque périphérique, mais vous devez
    décider lequel des deux modes opératoires vous souhaitez que le script utilise.</para>

    <para>Tout d'abord, le script peut opérer en mode <quote>chemin</quote> (utilisé par
    défaut pour les périphériques USB et FireWire), où les règles qu'il crée dépendent
    du chemin physique vers le lecteur CD ou DVD. Ensuite, il peut
    opérer en mode <quote>id</quote> (par défaut pour les
    périphériques IDE et SCSI), où les règles qu'il crée dépendent des
    chaînes d'identification contenues dans le lecteur CD ou DVD
    lui-même. Le chemin est déterminé par le script
    <command>path_id</command> d'Udev, et les chaînes d'identification
    sont lues à partir du matériel par ses programmes
    <command>ata_id</command> ou <command>scsi_id</command>, selon le
    type de périphérique que vous avez.</para>

    <para>Il y a des avantages dans chaque approche&nbsp;; la bonne
    approche à utiliser dépendra des types de changements de périphérique
    qui peuvent se produire. Si vous vous attendez à ce que le chemin
    physique vers le périphérique (c'est-à-dire, les ports et/ou les
    slots par lesquels ils sont branchés) changent, par exemple parce que
    vous envisagez de déplacer le lecteur sur un port IDE différent ou
    un connecteur USB différent, alors vous devriez utiliser le mode
    <quote>id</quote>. D'un autre côté, si vous vous attendez à ce
    que l'identification du périphérique change, par exemple parce qu'il
    peut mourir et que vous le remplaceriez par un périphérique différent
    avec les mêmes possibilités et qui serait monté sur les mêmes
    connecteurs, vous devriez utiliser le mode
    <quote>chemin</quote>.</para>

    <para>Si les deux types de changement sont possibles avec votre
    lecteur, choisissez un mode basé sur le type de changement que vous
    pensez rencontrer le plus fréquemment.</para>

<!-- If you use by-id mode, the symlinks will survive even the transition
     to libata for IDE drives, but that is not for the book. -->

    <important><para>Les périphériques externes (par exemple un lecteur
    CD connecté en USB) ne devraient pas utiliser la méthode des chemins,
    car chaque fois que le périphérique est monté sur un nouveau port,
    son chemin physique changera. Tous les périphériques connectés en
    externe auront ce problème si vous écrivez des règles Udev pour les
    reconnaître par leur chemin physique&nbsp;; le problème ne concerne
    pas que les lecteurs CD et DVD.</para></important>

    <para>Si vous souhaitez voir les valeurs que les scripts Udev
    utiliseront, et celles appropriées au périphérique CD-ROM, trouvez le
    répertoire correspondant sous
    <filename class="directory">/sys</filename> (cela peut être par exemple
    <filename class="directory">/sys/block/hdd</filename>) et
    lancez une commande ressemblant à ce qui suit&nbsp;:</para>

<screen role="nodump"><userinput>udevadm test /sys/block/hdd</userinput></screen>

    <para>Regardez les lignes contenant la sortie des divers programmes
    *_id. Le mode <quote>id</quote> utilisera la valeur ID_SERIAL
    si elle existe et n'est pas vide, sinon il utilisera une combinaison
    de ID_MODEL et de ID_REVISION. Le mode <quote>chemin</quote> utilisera la valeur de ID_PATH.</para>

    <para>Si le mode par défaut ne convient pas à votre situation, vous
    pouvez faire la modification suivante du fichier
    <filename>/etc/udev/rules.d/83-cdrom-symlinks.rules</filename>,
    comme suit, (où <replaceable>mode</replaceable> est soit
    <quote>by-id</quote> soit <quote>by-path</quote>)&nbsp;:</para>

<screen role="nodump"><userinput>sed -i -e 's/"write_cd_rules"/"write_cd_rules <replaceable>mode</replaceable>"/' \

    /etc/udev/rules.d/83-cdrom-symlinks.rules</userinput></screen>

    <para>Remarquez qu'il n'est pas nécessaire de créer les fichiers de règle ou les
     liens symboliques à ce moment puisque vous avez monté en bind le répertoire
    <filename class="directory">/dev</filename> du système hôte dans le système LFS,
    et nous supposons que les liens symboliques existent sur l'hôte. Les
    règles et les liens symboliques seront créés la première fois que vous
    démarrerez votre système LFS.</para>

    <para>Cependant, si vous avez plusieurs lecteurs CD-ROM, les liens
    symboliques générés à ce moment peuvent pointer vers des
    périphériques différents de ceux vers lesquels ils pointent sur
    votre hôte, car les périphériques ne sont pas découverts dans un
    ordre prévisible. Les affectations créées quand vous démarrerez pour
    la première fois le système LFS seront stables, donc cela n'est un
    problème que si vous avez besoin que les liens symboliques sur les
    deux systèmes pointent vers le même périphérique. Si tel est le cas,
    inspectez (et éditez peut-être) le fichier
    <filename>/etc/udev/rules.d/70-persistent-cd.rules</filename> généré
    après le démarrage pour vous assurer que les liens symboliques
    affectés correspondent à ce dont vous avez besoin.</para>

  </sect2>

  <sect2>

    <title>Gestion des périphériques dupliqués</title>

    <para>Comme expliqué à la <xref linkend="ch-scripts-udev"/>, l'ordre
    dans lequel les périphériques ayant la même fonction apparaissent dans
    <filename class="directory">/dev</filename> est essentiellement aléatoire.
    Par exemple si vous avez une webcam USB et un tunner TV, parfois
   <filename>/dev/video0</filename> renvoie à la webcam, et
    <filename>/dev/video1</filename> renvoie au tuner, et parfois
    après un redémarrage l'ordre s'inverse.
    Pour toutes les classes de matériel sauf les cartes son et les cartes réseau, ceci peut se
    corriger en créant des règles Udev pour des liens symboliques constants personnalisés.
    Le cas des cartes réseau est couvert de façon séparé dans
    <xref linkend="ch-scripts-network"/>, et vous pouvez trouver la configuration des cartes son dans
    <ulink url="&blfs-root;postlfs/devices.html">BLFS</ulink>.</para>

    <para>Pour chacun des périphériques susceptibles d'avoir ce problème
    (même si le problème n'apparaît pas dans votre distribution Linux actuelle),
    trouvez le répertoire correspondant sous
    <filename class="directory">/sys/class</filename> ou
    <filename class="directory">/sys/block</filename>.
    Pour les périphériques vidéo, cela peut être
    <filename class="directory">/sys/class/video4linux/video<replaceable>X</replaceable></filename>.
    Calculez les attributs qui identifient de façon unique un
    périphérique (normalement basé sur l'ID du fabricant et du produit
    et/ou les numéros de série)&nbsp;:</para>

<screen role="nodump"><userinput>udevadm info -a -p /sys/class/video4linux/video0</userinput></screen>

      <para>Puis, écrivez des règles qui créent les liens symboliques, comme&nbsp;:</para>

<screen role="nodump"><userinput>cat &gt; /etc/udev/rules.d/83-duplicate_devs.rules &lt;&lt; "EOF"
<literal>
# Liens symboliques permanent vers la webcam et le tuner
KERNEL=="video*", ATTRS{idProduct}=="1910", ATTRS{idVendor}=="0d81", \
    SYMLINK+="webcam"
KERNEL=="video*", ATTRS{device}=="0x036f", ATTRS{vendor}=="0x109e", \
    SYMLINK+="tvtuner"
</literal>
EOF</userinput></screen>

    <para>Il en résulte que les périphériques <filename>/dev/video0</filename> et
    <filename>/dev/video1</filename> renvoient encore de manière aléatoire au tuner
    et à la webcam (et donc ne devrait jamais être utilisé directement), mais il y a des
    liens symboliques <filename>/dev/tvtuner</filename> et
    <filename>/dev/webcam</filename> qui pointent toujours vers le bon
    périphérique.</para>

 </sect2>

</sect1>
