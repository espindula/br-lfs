<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
  "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../general.ent">
  %general-entities;
]>

<sect1 id="ch-scripts-udev">
  <?dbhtml filename="udev.html"?>

  <title>Gestion des périphériques et modules sur un système LFS</title>

  <indexterm zone="ch-scripts-udev">
    <primary sortas="a-Udev">Udev</primary>
    <secondary>utilisation</secondary>
  </indexterm>

  <para>Dans le <xref linkend="chapter-building-system"/>, nous avons
  installé le paquet Udev. Avant d'aller dans les détails concernant son
  fonctionnement, un bref historique des méthodes précédentes de gestion
  des périphériques est nécessaire.</para>

  <para>Les systèmes Linux en général utilisent traditionnellement une
  méthode de création de périphériques statiques avec laquelle un grand
  nombre de n&oelig;uds périphériques est créé sous

  <filename class="directory">/dev</filename> (quelque fois des milliers
  de n&oelig;uds), que le matériel correspondant existe ou pas. Ceci se
  fait typiquement avec un script <command>MAKEDEV</command>, qui
  contient des appels au programme <command>mknod</command> avec les
  numéros de périphériques majeurs et mineurs pour chaque périphérique
  possible qui pourrait exister dans le monde.</para>

  <para>En utilisant la méthode udev, seuls les périphériques détectés
  par le noyau obtiennent des n&oelig;uds périphériques créés pour eux.
  Comme ces n&oelig;uds périphériques seront créés à chaque lancement du
  système, ils seront stockés dans un système de fichiers
  <systemitem class="filesystem">devtmpfs</systemitem> (un système de
  fichiers virtuel qui réside entièrement dans la  mémoire du système). Les n&oelig;uds
  périphériques ne requièrent pas beaucoup d'espace disque, donc la
  mémoire utilisée est négligeable.</para>

  <sect2>
    <title>Historique</title>

    <para>En février 2000, un nouveau système de fichiers appelé
    <systemitem class="filesystem">devfs</systemitem> a été intégré au
    noyau 2.3.46 et rendu disponible pour la série 2.4 des noyaux
    stables. Bien qu'il soit présent dans le source du noyau, cette
    méthode de création dynamique de périphérique n'a jamais reçu un
    support inconditionnel des développeurs du noyau.</para>

    <para>Le principal problème de l'approche adopté par 

    <systemitem class="filesystem">devfs</systemitem> était la façon dont il gérait la

    détection, la création et le nommage des périphériques. Ce dernier problème, le

    nommage des périphériques, était peut-être le plus critique. Il est

    généralement accepté que s'il est possible de configurer les noms des

    périphériques, alors la politique de nommage des périphériques revient à

    l'administrateur du système, et du coup n'est pas imposée par un ou
    des développeur(s) en particulier. Le système de fichiers

    <systemitem class="filesystem">devfs</systemitem> souffre aussi de 
    conditions particulières inhérentes à son concept et ne peut pas
    être  corrigé sans une revue importante du noyau. Il a aussi été
    marqué comme obsolète pendant une longue période &mdash; à cause
    d'un manque de  maintenance &mdash; et a finalement été supprimé du
    noyau en juin 2006.</para>

    <para>Avec le développement du noyau instable 2.5, sorti ensuite en
    tant que la série 2.6 des noyaux stables, un nouveau système de
    fichiers virtuel appelé 

    <systemitem class="filesystem">sysfs</systemitem> est arrivé. Le rôle
    de <systemitem class="filesystem">sysfs</systemitem> est d'exporter une vue 
    de la configuration matérielle du 
    système pour les processus en espace utilisateur.
    Avec cette représentation visible de l'espace utilisateur,
    la possibilité de voir un remplacement de l'espace utilisateur pour  
    <systemitem class="filesystem">devfs</systemitem> est devenu
    beaucoup plus réaliste.</para>

  </sect2>

  <sect2>
    <title>Implémentation d'Udev</title>

    <sect3>
      <title>Sysfs</title>

      <para>Le système de fichier
      <systemitem class="filesystem">sysfs</systemitem> a été brièvement mentionné ci-dessus. On pourrait se
      demander comment <systemitem class="filesystem">sysfs</systemitem>
      connaît les périphériques présents sur un système et quels numéros
      de périphériques devraient être utilisés. Les pilotes qui ont été
      compilés directement dans le noyau enregistrent leur objet avec
      <systemitem class="filesystem">sysfs</systemitem> quand ils sont
      détectés par le noyau. Pour les pilotes compilés en tant que
      modules, cet enregistrement surviendra quand le module sera
      chargé. Une fois que le système de fichier
      <systemitem class="filesystem">sysfs</systemitem> est monté (sur
      <filename class="directory">/sys</filename>), les données
      enregistrées par les pilotes internes avec
      <systemitem class="filesystem">sysfs</systemitem> sont disponibles
      pour les processus en espace utilisateur ainsi qu'à
      <command>udev</command> pour continuer (et faire même des modifications 
      aux n&oelig;uds
      périphériques).</para>

    </sect3>

    <sect3>
      <title>Scripts de démarrage d'Udev</title>

      <para>Le script de démarrage <command>/etc/rc.d/init.d/udev</command> s'occupe
      de créer les n&oelig;uds périphériques au lancement de
      Linux. Le script supprime la gestion des uevents de 
      <command>/sbin/hotplug</command> par défaut. On fait cela car le
      noyau n'a plus besoin de faire appel à un binaire externe. À la
      place, <command>udevd</command> écoutera sur un socket netlink les
      uevents que le noyau fait apparaître. Puis, le script de démarrage
      copie les n&oelig;uds des périphériques statiques qui existent
      dans <filename class="directory">/lib/udev/devices</filename> vers
      <filename class="directory">/dev</filename>. Cela est nécessaire
      car certains périphériques, répertoires et liens symboliques sont
      requis avant que les processus de gestion du périphérique
      dynamique ne soient disponibles pendant les premières étapes du
      démarrage d'un système.
      La création des n&oelig;uds statiques dans
      <filename class="directory">/lib/udev/devices</filename> fournit
      aussi un contournement facile pour les périphériques
      qui ne sont pas supportés par l'infrastructure de gestion des
      périphériques en dynamique. Ensuite le script de démarrage lance
      le démon Udev, <command>udevd</command>, qui agira sur tous les
      uevents qu'il reçoit. Enfin, le script de démarrage oblige le
      noyau à répéter des uevents pour chaque périphérique qui a été
      déjà enregistré puis attend que <command>udevd</command> les
      gère.</para>

 
      <para>Le script de démarrage <command>/etc/rc.d/init.d/udev_retry</command> 
      s'occupe de ratraper les événements pour les sous-systèmes dont les règles
      se basent sur des systèmes de fichiers non montés jusqu'à ce que le
      scp:pt <command>mountfs</command> se lance (en particulier, il se peut que
      /usr et /var provoquent cela). Ce script se lance après que le script
      <command>mountfs</command>, pour que ces règles réussissent le
      contournement (si elles sont retardées). Le fichier 
      <filename>/etc/sysconfig/udev_retry</filename> configure cela&nbsp;; 
      tous les mots de ce fichier qui ne sont pas des commentaires sont
      considérés comme des noms de sous-systèmes qu'il faut ratraper au moment
      du nouvel essai. (Pour trouver le sous-système d'un périphérique, 
      utilisez <command>udevadm info --attribute-walk</command>.)</para>

    </sect3>

    <sect3>
      <title>Création de n&oelig;uds de périphérique</title>

      <para>À partir d'Udev-&udev-version;, <command>udevd</command> ne crée
      plus de fichiers de périphériques dans <filename class="directory">/dev</filename>.
      Cela se gère plutôt dans le noyau, avec le système de fichiers <systemitem
      class="filesystem">devtmpfs</systemitem>.  Tout pilote qui souhaite
      enregistrer un n&oelig;ud périphérique ira sur <systemitem
      class="filesystem">devtmpfs</systemitem> (via le c&oelig;ur du pilote) 
      pour le faire. Quand une session
      When a <systemitem class="filesystem">devtmpfs</systemitem> est montée sur
      <filename class="directory">/dev</filename>, le n&oelig;ud de périphérique
      sera cré au départ avec un nom, des droits et un propriétaire fixes.</para>

      <para>Peu de temps après, le noyau enverra un uevent à <command>
      udevd</command>. À partir des règles indiquées dans les fichiers contenus
      dans les répertoires
      <filename class="directory">/etc/udev/rules.d</filename>, <filename
      class="directory">/lib/udev/rules.d</filename>, et <filename
      class="directory">/run/udev/rules.d</filename>, <command>
      udevd</command> créera les liens symboliques supplémentaires vers le
      n&oelig;ud périphérique, ou bien il modifiera ses droits, son propriétaire 
      ou son groupe, ou l'entrée dans la fase de données interne de 
      <command>udevd</command> concernant cet objet.</para>

      <para>Les règles dans ces trois répertoires sont numérotées de la même
      façon que dans le paquet LFS-Bootscripts et les trois répertoires sont
      mis à jour ensemble. Si <command>udevd</command> ne peut pas trouver de
      règles pour le périphérique qu'il cée, il en donnera la propriété et les
      droits à n'importe quel
      <systemitem class="filesystem">devtmpfs</systemitem> utilisé
      au départ.</para>

    </sect3>

    <sect3>
      <title>Chargement d'un module</title>

      <para>Il se peut que les pilotes des périphériques compilés en
      module aient des aliases compilés en eux. Les aliases sont
      visibles dans la sortie du programme <command>modinfo</command> et
      sont souvent liés aux identifiants spécifiques du bus des
      périphériques supportés par un module. Par exemple, le pilote
      <emphasis>snd-fm801</emphasis> supporte les périphériques PCI
      ayant l'ID fabricant 0x1319 et l'ID de périphérique 0x0801, et il
      a un alias qui est 
      <quote>pci:v00001319d00000801sv*sd*bc04sc01i*</quote>. Pour la
      plupart des périphériques, le pilote du bus définit l'alias du
      pilote qui gérerait le périphérique via  <systemitem
      class="filesystem">sysfs</systemitem>. Par exemple, le fichier
      <filename>/sys/bus/pci/devices/0000:00:0d.0/modalias</filename>
      pourrait contenir la chaîne 
      <quote>pci:v00001319d00000801sv00001319sd00001319bc04sc01i00</quote>.
      Il résultera des règles par défaut fournies avec Udev que
      <command>udevd</command> fera appel à 
      <command>/sbin/modprobe</command> avec le contenu de la variable
      d'environnement de l'uevent <envar>MODALIAS</envar>  (qui devrait
      être la même que le contenu du fichier
      <filename>modalias</filename> dans sysfs), donc chargera tous les
      modules dont les alias correspondent à cette chaîne après les expansions génériques.</para>

      <para>Dans cet exemple, cela signifie que, outre <emphasis>snd-fm801</emphasis>,
     le pilote <emphasis>forte</emphasis> obsolète (et non désiré) 
     sera chargé s'il est disponible. Voir ci-dessous les moyens d'empêcher
      le chargement des modules indésirables.</para>

      <para>Le noyau lui-même est aussi capable de charger des modules
      de protocole réseau, de support pour des systèmes de fichiers et
      des NLS sur demande.</para>

    </sect3>

    <sect3>
      <title>Gestion des périphériques dynamiques/montables à chaud</title>

      <para>Quand vous connectez un périphérique, comme un lecteur MP3
      USB (<foreignphrase>Universal Serial Bus</foreignphrase>), le
      noyau reconnaît que le périphérique est maintenant connecté et
      génère un uevent. Cet uevent est alors géré par
      <command>udevd</command> comme décrit ci-dessus.</para>

    </sect3>

  </sect2>

  <sect2>
    <title>Problèmes avec le chargement des modules et la création des périphériques</title>

    <para>Il existe quelques problèmes connus pour la création
    automatique des n&oelig;uds périphériques&nbsp;:</para>

    <sect3>
      <title>Un module du noyau n'est pas chargé automatiquement</title>

      <para>Udev ne chargera un module que s'il a un alias spécifique au
      bus et si le pilote du bus envoie correctement les alias
      nécessaires vers <systemitem class="filesystem">sysfs</systemitem>.
      Sinon, il faut organiser le chargement de modules par d'autres
      moyens. Avec Linux-&linux-version;, Udev est connu pour charger les
      pilotes correctement écrits pour les périphériques INPUT, IDE,
      PCI, USB, SCSI, SERIO et FireWire.</para>

      <para>Pour déterminer si le pilote du périphérique dont vous avez
      besoin a le support nécessaire pour Udev, lancez
      <command>modinfo</command> avec le nom du module comme argument.
      Puis, essayez de localiser le répertoire du périphérique
      sous <filename class="directory">/sys/bus</filename> et vérifiez
      s'il y a un fichier <filename>modalias</filename> là-bas.</para>

      <para>Si le fichier <filename>modalias</filename> existe dans
      <systemitem class="filesystem">sysfs</systemitem>, alors le pilote
      supporte le périphérique et peut lui parler directement, mais
      s'il n'a pas d'alias, c'est un bogue dans le pilote. Chargez le
      pilote sans l'aide d'Udev et attendez que le problème soit corrigé
      plus tard.</para>

      <para>S'il n'y a pas de fichier <filename>modalias</filename> dans
      le bon répertoire sous

      <filename class="directory">/sys/bus</filename>, cela signifie que
      les développeurs du noyau n'ont pas encore ajouté de support
      modalias à ce type de bus. Avec Linux-&linux-version;, c'est le
      cas pour les bus ISA. Attendez que ce problème soit réparé dans
      les versions ultérieures du noyau.</para>

      <para>Udev n'a pas du tout pour but de charger des pilotes
      <quote>wrappers</quote> (qui emballent un autre pilote) comme <emphasis>snd-pcm-oss</emphasis> et
      des pilotes non matériels comme <emphasis>loop</emphasis>.</para>

    </sect3>

    <sect3>
      <title>Un module du noyau n'est pas chargé automatiquement et 
      Udev n'est pas prévu pour le charger</title>

      <para>Si le module <quote>wrapper</quote> n'améliore que la
      fonctionnalité fournie par un autre module (comme
      <emphasis>snd-pcm-oss</emphasis> améliore la fonctionnalité de
      <emphasis>snd-pcm</emphasis> en rendant les cartes son disponibles
      pour les applications OSS), configurez la commande
      <command>modprobe</command> pour charger le wrapper après qu'Udev ait
      chargé le module emballé. Pour cela, ajoutez une ligne
      <quote>softdep</quote> dans tous les fichiers
      <filename>/etc/modprobe.d/<replaceable>&lt;filename&gt;</replaceable>.conf</filename>. Par exemple&nbsp;:</para>

<screen role="nodump"><literal>softdep snd-pcm post: snd-pcm-oss</literal></screen>

      <para>Remarquez que la commande <quote>softdep</quote> autorise aussi les
      dépendances <literal>pre:</literal>, ou un mélange de
      <literal>pre:</literal> et de <literal>post:</literal>.  Voir la page de 
      manuel de <filename>modprobe.d(5)</filename> pour plus d'informations
      sur la syntaxe et les possibilités d'<quote>softdep</quote>.</para>

      <para>Si le module en question n'est pas un emballage et s'avère
      utile en tant que tel, configurez le script de démarrage
      <command>modules</command> pour charger ce module sur le
      système de démarrage. Pour cela, ajoutez le nom du module au
      fichier <filename>/etc/sysconfig/modules</filename> sur une ligne
      séparée. Cela fonctionne aussi pour les modules emballage, mais ce
      n'est pas optimal dans ce cas.</para>

    </sect3>

    <sect3>
      <title>Udev charge un module indésirable</title>

      <para>Ne compilez pas le module, ou mettez-le en liste noire dans
      un fichier <filename>/etc/modprobe.d/blacklist.conf</filename>
      comme on le fait avec le module <emphasis>forte</emphasis> dans l'exemple
      ci-dessous&nbsp;:</para>

<screen role="nodump"><literal>blacklist forte</literal></screen>

      <para>Les modules en liste noire peuvent toujours être chargés
      manuellement avec la commande explicite 
      <command>modprobe</command>.</para>

    </sect3>

    <sect3>
      <title>Udev crée mal un périphérique, ou crée un mauvais lien
      symbolique</title>

      <para>Cela se produit habituellement si une règle correspond à un
      périphérique de façon imprévue. Par exemple, une règle écrite
      avec des lacunes peut correspondre à un disque SCSI (comme désiré)
      et au périphérique générique SCSI correspondant (de façon
      incorrecte) du fabricant. Trouvez la règle défectueuse et
      rendez-la plus précise, à l'aide de la commande
      <command>udevadm info</command></para>

    </sect3>

    <sect3>
      <title>Une règle Udev fonctionne de manière non fiable</title>

      <para>Cela peut être une autre manifestation du problème
      précédent. Sinon, et si votre règle utilise les attributs de 
      <systemitem class="filesystem">sysfs</systemitem>, il se peut que
      ce soit un problème de timing du noyau, sur le point d'être
      corrigé dans les noyaux ultérieurs. Pour le moment, vous pouvez
      contourner en créant une règle qui attend l'attribut

      <systemitem class="filesystem">sysfs</systemitem> utilisé et en la
      mettant dans le fichier
      <filename>/etc/udev/rules.d/10-wait_for_sysfs.rules</filename>
      (créez ce fichier s'il n'existe pas). Merci d'informer la liste de
      développement de LFS si vous faites ainsi et que cela vous
      aide.</para>

    </sect3>

    <sect3>
      <title>Udev ne crée pas de périphérique</title>

      <para>Le texte ci-après assume que le pilote est compilé de
      manière statique dans le noyau ou qu'il est déjà chargé comme
      module, et que vous avez déjà vérifié qu'Udev ne crée pas de
      périphérique mal nommé.</para>

      <para>Udev n'a pas besoin d'information pour créer un n&oelig;ud
      périphérique si le pilote du noyau n'envoie pas ses données vers 
      <systemitem class="filesystem">sysfs</systemitem>. C'est ce qu'il
      y a de plus courant avec les pilotes de tierces parties à
      l'extérieur de l'arborescence du noyau. Créez un n&oelig;ud de
      périphérique statique dans <filename>/lib/udev/devices</filename>
      avec les numéros majeurs/mineurs appropriés (voir le fichier
      <filename>devices.txt</filename> dans la documentation du noyau ou
      la documentation fournie par le fabricant du pilote tierce
      partie). Le n&oelig;ud du périphérique statique sera copié vers 
      <filename class="directory">/dev</filename> par le script de
      démarrage <command>udev</command>.</para>

    </sect3>

    <sect3>
      <title>Le nommage des périphériques change de manière aléatoire après
      le redémarrage</title>

      <para>Cela est dû au fait que Udev, par nature, gère les uevents
      et charge les modules en parallèle, donc dans un ordre
      imprévisible. Cela ne sera jamais <quote>corrigé</quote>. Vous ne
      devriez pas espérer que les noms des périphériques du noyau sont 
      stables. Créez plutôt vos propres règles qui rendent les liens
      symboliques stables basés sur des attributs stables du
      périphérique, comme une série de nombre ou la sortie de divers
      utilitaires *_id installés par Udev. Voir

      <xref linkend="ch-scripts-symlinks"/> et

      <xref linkend="ch-scripts-network"/> pour des exemples.</para>

    </sect3>

  </sect2>

  <sect2>
    <title>Lecture utile</title>

    <para>Des documentations supplémentaires sont disponibles sur les
    sites suivants&nbsp;:</para>

    <itemizedlist>

      <listitem>
        <para>A Userspace Implementation of <systemitem class="filesystem">devfs</systemitem>
        <ulink url="http://www.kroah.com/linux/talks/ols_2003_udev_paper/Reprint-Kroah-Hartman-OLS2003.pdf"/>
        (NdT&nbsp;: Une implémentation en espace utilisateur de devfs)</para>
      </listitem>

      <listitem>
        <para>The <systemitem class="filesystem">sysfs</systemitem> Filesystem
        <ulink url="http://www.kernel.org/pub/linux/kernel/people/mochel/doc/papers/ols-2005/mochel.pdf"/>
        (NdT&nbsp;: Le système de fichier
        <systemitem class="filesystem">sysfs</systemitem>)</para>
      </listitem>
      <listitem>
        <para>Pointers to further reading
        <ulink url="http://www.kernel.org/pub/linux/utils/kernel/hotplug/udev.html"/>
        (NdT&nbsp;: Pointeurs vers de plus amples lectures)</para>
      </listitem>
    </itemizedlist>

  </sect2>

</sect1>
