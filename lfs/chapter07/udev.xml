<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN" "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../general.ent">
  %general-entities;
]>
<sect1 id="ch-scripts-udev">
<title>Gestion des périphériques et modules sur un système LFS</title>
<?dbhtml filename="udev.html"?>

<indexterm zone="ch-scripts-udev">
<primary sortas="a-Udev">Udev</primary>
<secondary>usage</secondary></indexterm>

<para>Dans <xref linkend="chapter-building-system"/>, nous avons installé le
paquet Udev. Avant d'aller dans les détails concernant son fonctionnement, un
bref historique des méthodes précédentes de gestion des périphériques est
nécessaire.</para>

<para>Les systèmes Linux en général utilisent traditionellement une méthode
de création de périphériques statiques avec laquelle un grand nombre de
n&oelig;uds périphériques est créé sous <filename
class="directory">/dev</filename> (quelque fois des milliers de n&oelig;uds
), quel le matériel correspondant existe ou pas. Ceci se fait
typiquement avec un script <command>MAKEDEV</command>, qui contient des appels
au programme <command>mknod</command> avec les numéros de périphériques
majeurs et mineurs pour chaque périphérique possible qui pourrait exister
dans le monde. En utilisant la méthode udev, seuls les périphériques
détectés par le noyau obtiennent des n&oelig;uds périphériques créés pour
eux. Comme ces n&oelig;uds périphériques seront créés à chaque lancement du
système, ils seront stockés dans un <systemitem
class="filesystem">ramfs</systemitem> (un système de fichiers qui réside
entièrement en mémoire et ne prend pas d'espace disque). Les n&oelig;uds
périphériques ne requièrent pas beaucoup d'espace disque, donc la mémoire
utilisée est négligable.</para>

<sect2>
<title>Historique</title>

<para>En février 2000, un nouveau système de fichiers appelé <systemitem
class="filesystem">devfs</systemitem> a été intégré au noyau 2.3.46 et rendu
disponible pour la série 2.4 des noyaux stables. Bien qu'il soit présent dans
le source du noyau, cette méthode de création dynamique de périphérique n'a
jamais reçu un support inconditionnel des développeurs du noyau.</para>

<para>Le principal problème de l'approche adopté par <systemitem
class="filesystem">devfs</systemitem> était la façon dont il gérait la
détection, la création et le nommage des périphériques. Ce dernier problème, le
nommage des périphériques, était peut-être le plus critique. Il est
généralement accepté que s'il est possible de configurer les noms des
périphériques, alors la politique de nommage des périphériques revient à
l'administrateur du système, et du coup n'est pas imposée par un développeur
particulier. Le système de fichiers <systemitem
class="filesystem">devfs</systemitem> souffre aussi de conditions
particulières inhérentes à son concept et ne peut pas être corrigé sans une 
revue importante du noyau. Il a aussi été marqué comme obsolète à cause d'un
manque de maintenance.</para>

<para>Avec le développement du noyau instable 2.5, sorti ensuite en tant que la
série 2.6 des noyaux stables, un nouveau système de fichiers virtuel appelé
<systemitem class="filesystem">sysfs</systemitem> est arrivé. Le travail de
<systemitem class="filesystem">sysfs</systemitem> est d'exporter une vue de la
struture du système des processus en espace utilisateur. Avec cette
représentation visible de l'espace utilisateur, la possibilité de voir une
remplacement de l'espace utilisateur pour <systemitem
class="filesystem">devfs</systemitem> est devenu beaucoup plus réaliste.</para>
<beginpage/>
</sect2>

<sect2>
<title>Implémentation d'Udev</title>

<para>Le système de fichiers <systemitem class="filesystem">sysfs</systemitem>
a été brièvement mentionné ci-dessus. On pourrait se demander comment
<systemitem class="filesystem">sysfs</systemitem> connait les périphériques
présents sur un système et quels numéros de périphériques devraient être
utilisés. Les pilotes qui ont été compilés directement dans le noyau
enregistrent leur objet avec <systemitem class="filesystem">sysfs</systemitem>
quand ils sont détectés par le noyau. Pour les pilotes compilés en tant que
modules, ceci surviendra quand le module sera chargé. Une fois que le système
de fichiers <systemitem class="filesystem">sysfs</systemitem> est monté (sur
<filename class="directory">/sys</filename>), les données enregistrées par les
pilotes internes avec <systemitem class="filesystem">sysfs</systemitem> sont
disponibles pour les processus en espace utilisateur ainsi qu'à
<command>udev</command> pour la création des n&oelig;uds périphériques.</para>

<para>Le script de démarrage <command>S10udev</command> fait attention à créer
les n&oelig;uds périphériques au lancement de Linux. Ce script commence 
en enregistrant <command>/sbin/udev</command> comme gestionnaire d'événements
de montage à chaud. Ces événements (discutés plus bas) ne devraient pas être
générés lors de cette étape mais <command>udev</command> est enregistré juste
au cas où cela se passerait quand même. Le programme
<command>udevstart</command> parcourt le système de fichiers <systemitem
class="filesystem">/sys</systemitem> et crée les périphériques sous <filename
class="directory">/dev</filename> correspondant à ces descriptions. Par
exemple, <filename>/sys/class/tty/vcs/dev</filename> contient la chaîne
<quote>7:0</quote>. Cette chaîne est utilisée par <command>udevstart</command>
pour créer <filename>/dev/vcs</filename> avec le nombre majeur
<emphasis>7</emphasis> et le nombre mineur <emphasis>0</emphasis>. Les droits
de chaque périphérique que <command>udevstart</command> crée sont initialisés
en utilisant les fichiers du répertoire <filename
class="directory">/etc/udev.d/permissions.d/</filename>. Ils sont numérotés
de la même façon que les scripts de démarrage LFS. Si <command>udev</command>
ne trouve pas un fichier de droits pour le périphérique en cours de
création, il utilise les droits par défaut, <emphasis>600</emphasis>, et donne
l'appartenance du périphérique à <emphasis>root:root</emphasis>. Les noms des
n&oelig;uds créés sous le répertoire <filename
class="directory">/dev</filename> sont configurés en respectant les
règles spécifiées dans les fichiers à l'intérieur du répertoire <filename
class="directory">/etc/udev/rules.d/</filename>.</para>

<para>Une fois l'étape ci-dessus terminée, tous les périphériques qui étaient
déjà présents et ont des pilotes intégrés au noyau seront disponibles pour
utilisation. Qu'en est-il des périphériques qui ont des pilotes sous
forme de modules&nbsp;?</para>

<para>Plus tôt, nous avons mentionné le concept d'un <quote>gestionnaire
d'événements de montage à chaud</quote>. Quand la connexion d'un nouveau
périphérique est détectée par le noyau, le noyau génèrera un événement de
montage à chaud et regardera dans le fichier
<filename>/proc/sys/kernel/hotplug</filename> pour trouver le programme en
espace utilisateur qui gère la connexion du périphérique. Le script de démarrage
<command>udev</command> a enregistré <command>udev</command> comme
gestionnaire. Quand ces événements sont générés, le noyau indiquera à
<command>udev</command> de vérifier le système de fichiers <filename
class="directory">/sys</filename> pour des informations sur le nouveau
périphérique et pour créer son entrée <filename
class="directory">/dev</filename>.</para>

<para>Ceci nous amène au problème d'<command>udev</command>, mais aussi avec
<systemitem class="filesystem">devfs</systemitem>. Il est habituellement
référencé comme le <quote>problème de l'oelig;uf et de la poule</quote>. La
plupart des distributions Linux gère le chargement des modules via des entrées
dans <filename>/etc/modules.conf</filename>. L'accès à un n&oelig;ud
périphérique implique le chargement du module du noyau. Avec
<command>udev</command>, cette méthode ne fonctionnera pas car le n&oelig;ud
périphérique n'existe pas tant que le module n'est pas chargé. Pour résoudre
ceci, le script de démarrage <command>S05modules</command> a été ajouté au
paquet lfs-bootscripts, avec le fichier
<filename>/etc/sysconfig/modules</filename>. En
<beginpage/> ajoutant les noms de modules au fichier
<filename>modules</filename>, ces modules seront chargés lorsque l'ordinateur
démarrera. Ceci permet à <command>udev</command> de détecter les périphériques
et de créer les n&oelig;uds périphériques appropriés.</para>

<para>Notez que sur les machines lentes ou pour les pilotes qui créent un
grand nombre de n&oelig;uds périphériques, le processus de création des
périphériques pourrait prendre quelques secondes pour se terminer. Ceci
signifie que certains n&oelig;uds périphériques pourraient ne pas être
accessibles immédiatement.</para>
</sect2>

<sect2>
<title>Gestion des périphériques dynamiques/montables à chaud</title>

<para>Lorsque vous connectez un périphérique, comme un lecteur MP3 USB, le
noyau reconnaît que le périphérique est maintenant connecté et génère un
événement de montage à chaud. Si le pilote a déjà été chargé (soit parce qu'il
était compilé dans le noyau soit parce qu'il a été chargé via le script de
démarrage <command>S05modules</command>), <command>udev</command> sera appelé
pour créer le(s) n&oelig;ud(s) périphérique correspondant suivant les données de
<systemitem class="filesystem">sysfs</systemitem> disponibles dans
<filename class="directory">/sys</filename>. Si le pilote du périphérique tout
juste connecté est disponible comme module mais actuellement non chargé, alors
connecter le périphérique au système fera que le pilote du bus du noyau
génèrera un événement de montage à chaque notifiant l'espace utilisateur de la
connexion du nouveau périphérique et le fait qu'il n'est pas rattaché à un
pilote. En fait, rien ne se passe et le périphérique lui-même n'est pas encore
utilisable.</para>

<para>Si vous avez construit un système qui comprend beaucoup de pilotes
compilés en tant que modules plutôt que directement intégrés au noyau,
utiliser <command>S05modules</command> pourrait ne pas être pratique. Le paquet
Hotplug (voir <ulink url="http://linux-hotplug.sourceforge.net/"/>) peut être
bénéfique dans ces cas. Lorsque le paquet Hotplug package est installé, il
répondra aux événements de montage à chaud du pilote du bus du noyau. Le paquet
Hotplug chargera le module approprié et rendra ce périphérique disponible en
créant le(s) n&oelig;ud(s) pour lui.</para>
</sect2>

<sect2>
<title>Problèmes avec la création des périphériques</title>

<para>Il existe quelques problèmes connus pour la création automatique
des n&oelig;uds périphériques&nbsp;:</para>

<para>1) Un pilote du noyau pourrait ne pas exporter ses données dans
<systemitem class="filesystem">sysfs</systemitem>.</para>
   
<para>Ceci est plus fréquent avec les pilotes de tierces parties, à
l'extérieur du noyau. Ces pilotes n'auront pas leur n&oelig;uds créés. Utilisez
le fichier de configuration <filename>/etc/sysconfig/createfiles</filename>
pour créer manuellement les périphériques. Consultez le fichier
<filename>devices.txt</filename> à l'intérieur de la documentation du noyau ou
la documentation venant avec ce pilote pour trouver les bons nombres majeurs et
mineurs.</para>

<beginpage/>
<para>2) Un périphérique non matériel est requis. Ceci est plus fréquent avec
le module de compatibilité OSS (acronyme de Open Sound System) du projet ALSA
(Advanced Linux Sound Architecture). Ces types de périphériques peuvent être
gérés de deux façons différentes&nbsp;:</para>

<itemizedlist>

<listitem><para>Ajouter les noms des modules à
<filename>/etc/sysconfig/modules</filename></para></listitem>
<listitem><para>Utiliser une ligne <quote>install</quote> dans
<filename>/etc/modprobe.conf</filename>. Ceci indique à la commande
<command>modprobe</command> <quote>au chargement du module, de charger aussi
cet autre module, au même moment.</quote> Par exemple&nbsp;:</para>

<screen><userinput>install snd-pcm modprobe -i snd-pcm ; modprobe \
    snd-pcm-oss ; true</userinput></screen>

<para>Ceci fera que le système charge à la fois les modules 
<emphasis>snd-pcm</emphasis> et <emphasis>snd-pcm-oss</emphasis> quand toute
requête est faite pour charger le pilote
<emphasis>snd-pcm</emphasis>.</para></listitem>
</itemizedlist>
</sect2>

<sect2>
<title>Lecture utile</title>

<para>Des documentations supplémentaires sont disponibles sur les sites
suivants&nbsp;:</para>

<itemizedlist>
<listitem><para remap="verbatim">A Userspace Implementation of devfs
<ulink url="http://www.kroah.com/linux/talks/ols_2003_udev_paper/Reprint-Kroah-Hartman-OLS2003.pdf"><phrase
condition="pdf">http://www.kroah.com/linux/talks/ols_2003_udev_paper/
Reprint-Kroah-Hartman-OLS2003.pdf</phrase></ulink> (NdT&nbsp;:
Une implémentation en espace utilisateur de devfs)</para></listitem>

<listitem><para remap="verbatim">FAQ udev
<ulink url="http://www.kernel.org/pub/linux/utils/kernel/hotplug/udev-FAQ"/></para></listitem>

<listitem><para remap="verbatim">The Linux Kernel Driver Model
<ulink url="http://public.planetmirror.com/pub/lca/2003/proceedings/papers/Patrick_Mochel/Patrick_Mochel.pdf"><phrase  
condition="pdf">http://public.planetmirror.com/pub/lca/2003/proceedings/papers/
Patrick_Mochel/Patrick_Mochel.pdf</phrase></ulink> (NdT&nbsp;:
le modèle des pilotes du noyau Linux)</para></listitem>
</itemizedlist>
</sect2>

</sect1>

