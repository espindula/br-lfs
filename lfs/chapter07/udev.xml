<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN" "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../general.ent">
  %general-entities;
]>
<sect1 id="ch-scripts-udev">
<title>Gestion des périphériques et modules sur un système LFS</title>
<?dbhtml filename="udev.html"?>

<indexterm zone="ch-scripts-udev">
<primary sortas="a-Udev">Udev</primary>
<secondary>usage</secondary></indexterm>

<para>Dans <xref linkend="chapter-building-system"/>, nous avons installé le
paquet Udev. Avant d'aller dans les détails concernant son fonctionnement, un
bref historique des méthodes précédentes de gestion des périphériques est
nécessaire.</para>

<para>Les systèmes Linux en général utilisent traditionnellement une méthode
de création de périphériques statiques avec laquelle un grand nombre de
n&oelig;uds périphériques est créé sous <filename
class="directory">/dev</filename> (quelque fois des milliers de n&oelig;uds
), quel le matériel correspondant existe ou pas. Ceci se fait
typiquement avec un script <command>MAKEDEV</command>, qui contient des appels
au programme <command>mknod</command> avec les numéros de périphériques
majeurs et mineurs pour chaque périphérique possible qui pourrait exister
dans le monde. En utilisant la méthode udev, seuls les périphériques
détectés par le noyau obtiennent des n&oelig;uds périphériques créés pour
eux. Comme ces n&oelig;uds périphériques seront créés à chaque lancement du
système, ils seront stockés dans un <systemitem
class="filesystem">tmpfs</systemitem> (un système de fichiers qui réside
entièrement en mémoire). Les n&oelig;uds périphériques ne requièrent pas
beaucoup d'espace disque, donc la mémoire utilisée est négligeable.</para>

<sect2>
<title>Historique</title>

<para>En février 2000, un nouveau système de fichiers appelé <systemitem
class="filesystem">devfs</systemitem> a été intégré au noyau 2.3.46 et rendu
disponible pour la série 2.4 des noyaux stables. Bien qu'il soit présent dans
le source du noyau, cette méthode de création dynamique de périphérique n'a
jamais reçu un support inconditionnel des développeurs du noyau.</para>

<para>Le principal problème de l'approche adopté par <systemitem
class="filesystem">devfs</systemitem> était la façon dont il gérait la
détection, la création et le nommage des périphériques. Ce dernier problème, le
nommage des périphériques, était peut-être le plus critique. Il est
généralement accepté que s'il est possible de configurer les noms des
périphériques, alors la politique de nommage des périphériques revient à
l'administrateur du système, et du coup n'est pas imposée par un développeur
particulier. Le système de fichiers <systemitem
class="filesystem">devfs</systemitem> souffre aussi de conditions
particulières inhérentes à son concept et ne peut pas être corrigé sans une 
revue importante du noyau. Il a aussi été marqué comme obsolète à cause d'un
manque de maintenance.</para>

<para>Avec le développement du noyau instable 2.5, sorti ensuite en tant que la
série 2.6 des noyaux stables, un nouveau système de fichiers virtuel appelé
<systemitem class="filesystem">sysfs</systemitem> est arrivé. Le travail de
<systemitem class="filesystem">sysfs</systemitem> est d'exporter une vue de la
configuration matérielle du système pour les processus en espace utilisateur.
Avec cette représentation visible de l'espace utilisateur, la possibilité de
voir une remplacement de l'espace utilisateur pour <systemitem
class="filesystem">devfs</systemitem> est devenu beaucoup plus réaliste.</para>

</sect2>

<sect2>
<title>Implémentation d'Udev</title>

<para>Le système de fichiers <systemitem class="filesystem">sysfs</systemitem>
a été brièvement mentionné ci-dessus. On pourrait se demander comment
<systemitem class="filesystem">sysfs</systemitem> connaît les périphériques
présents sur un système et quels numéros de périphériques devraient être
utilisés. Les pilotes qui ont été compilés directement dans le noyau
enregistrent leur objet avec <systemitem class="filesystem">sysfs</systemitem>
quand ils sont détectés par le noyau. Pour les pilotes compilés en tant que
modules, cet enregistrement surviendra quand le module sera chargé. Une fois que
le système de fichiers <systemitem class="filesystem">sysfs</systemitem> est
monté (sur <filename class="directory">/sys</filename>), les données enregistrées
par les pilotes internes avec <systemitem class="filesystem">sysfs</systemitem>
sont disponibles pour les processus en espace utilisateur ainsi qu'à
<command>udev</command> pour la création des n&oelig;uds périphériques.</para>

<para>Le script de démarrage <command>S10udev</command> fait attention à créer
les n&oelig;uds périphériques au lancement de Linux. Ce script commence 
en enregistrant <command>/sbin/udevsend</command> comme gestionnaire d'événements
de montage à chaud. Ces événements (discutés plus bas) ne sont généralement pas
générés lors de cette étape mais <command>udev</command> est enregistré juste
au cas où cela se passerait quand même. Le programme
<command>udevstart</command> parcourt le système de fichiers <systemitem
class="filesystem">/sys</systemitem> et crée les périphériques sous <filename
class="directory">/dev</filename> correspondant à ces descriptions. Par
exemple, <filename>/sys/class/tty/vcs/dev</filename> contient la chaîne
<quote>7:0</quote>. Cette chaîne est utilisée par <command>udevstart</command>
pour créer <filename>/dev/vcs</filename> avec le nombre majeur
<emphasis>7</emphasis> et le nombre mineur <emphasis>0</emphasis>. Les noms et
droits des n&oelig;uds créés sous le répertoire <filename
class="directory">/dev</filename> sont configurés suivant les règles spécifiées
dans les fichiers du répertoire <filename
class="directory">/etc/udev/rules.d/</filename>. Ils sont numérotés d'une façon
similaire au paquetage LFS-Bootscripts. Si <command>udev</command> ne peut as
trouver une règle pour le périphérique en cours de création, celui-ci aura les
droits par défaut (<emphasis>660</emphasis>) et son propriétaire sera
<emphasis>root:root</emphasis>.</para>

<para>Une fois l'étape ci-dessus terminée, tous les périphériques qui étaient
déjà présents et ont des pilotes intégrés au noyau seront disponibles pour
utilisation. Ceci nous amène aux périphériques qui ont des pilotes sous
forme de modules.</para>

<para>Plus tôt, nous avons mentionné le concept d'un <quote>gestionnaire
d'événements de montage à chaud</quote>. Quand la connexion d'un nouveau
périphérique est détectée par le noyau, le noyau générera un événement de
montage à chaud et regardera dans le fichier
<filename>/proc/sys/kernel/hotplug</filename> pour trouver le programme en
espace utilisateur qui gère la connexion du périphérique. Le script de démarrage
<command>udev</command> a enregistré <command>udevsend</command> comme
gestionnaire. Quand ces événements sont générés, le noyau indiquera à
<command>udev</command> de vérifier le système de fichiers <filename
class="directory">/sys</filename> pour des informations sur le nouveau
périphérique et pour créer son entrée <filename
class="directory">/dev</filename>.</para>

<para>Ceci nous amène au problème d'<command>udev</command>, mais aussi avec
<systemitem class="filesystem">devfs</systemitem>. Il est habituellement
référencé comme le <quote>problème de l'oelig;uf et de la poule</quote>. La
plupart des distributions Linux gère le chargement des modules via des entrées
dans <filename>/etc/modules.conf</filename>. L'accès à un n&oelig;ud
périphérique implique le chargement du module du noyau. Avec
<command>udev</command>, cette méthode ne fonctionnera pas car le n&oelig;ud
périphérique n'existe pas tant que le module n'est pas chargé. Pour résoudre
ceci, le script de démarrage <command>S05modules</command> a été ajouté au
paquet lfs-bootscripts, avec le fichier
<filename>/etc/sysconfig/modules</filename>. En ajoutant les noms de modules
au fichier <filename>modules</filename>, ces modules seront chargés lorsque
l'ordinateur démarrera. Ceci permet à <command>udev</command> de détecter les
périphériques et de créer les n&oelig;uds périphériques appropriés.</para>

<para>Notez que sur les machines lentes ou pour les pilotes qui créent un
grand nombre de n&oelig;uds périphériques, le processus de création des
périphériques pourrait prendre quelques secondes pour se terminer. Ceci
signifie que certains n&oelig;uds périphériques pourraient ne pas être
accessibles immédiatement.</para>
</sect2>

<sect2>
<title>Gestion des périphériques dynamiques/montables à chaud</title>

<para>Lorsque vous connectez un périphérique, comme un lecteur MP3 USB, le
noyau reconnaît que le périphérique est maintenant connecté et génère un
événement de montage à chaud. Si le pilote a déjà été chargé (soit parce qu'il
était compilé dans le noyau soit parce qu'il a été chargé via le script de
démarrage <command>S05modules</command>), <command>udev</command> sera appelé
pour créer le(s) n&oelig;ud(s) périphérique correspondant suivant les données de
<systemitem class="filesystem">sysfs</systemitem> disponibles dans
<filename class="directory">/sys</filename>.</para>

<para>Si le pilote du périphérique tout juste connecté est disponible comme
module mais actuellement non chargé, le paquetage Hotplug chargera les modules
appropriés et rendra ce périphérique disponible en créant le(s) n&oelig;ud(s)
périphérique(s) qui le concernent.</para>

</sect2>

<sect2>
<title>Problèmes avec la création des périphériques</title>

<para>Il existe quelques problèmes connus pour la création automatique
des n&oelig;uds périphériques&nbsp;:</para>

<para>1) Un pilote du noyau pourrait ne pas exporter ses données dans
<systemitem class="filesystem">sysfs</systemitem>.</para>
   
<para>Ceci est plus fréquent avec les pilotes de tierces parties, à
l'extérieur du noyau. Udev ne sera pas capable de créer automatiquement les
n&oelig;uds périphériques pour de tels pilotes. Utilisez le fichier de
configuration <filename>/etc/sysconfig/createfiles</filename> pour créer
manuellement les périphériques. Consultez le fichier <filename>devices.txt</filename>
dans la documentation du noyau ou la documentation pour trouver les bons numéros
majeurs et mineurs pour ce périphérique.</para>

<para>2) Un périphérique non matériel est requis. Ceci est plus fréquent avec
le module de compatibilité OSS (acronyme de Open Sound System) du projet ALSA
(Advanced Linux Sound Architecture). Ces types de périphériques peuvent être
gérés de deux façons différentes&nbsp;:</para>

<itemizedlist>

<listitem><para>Ajouter les noms des modules à
<filename>/etc/sysconfig/modules</filename></para><beginpage/></listitem>
<listitem><para>Utiliser une ligne <quote>install</quote> dans
<filename>/etc/modprobe.conf</filename>. Ceci indique à la commande
<command>modprobe</command> <quote>au chargement du module, de charger aussi
cet autre module, au même moment.</quote> Par exemple&nbsp;:</para>

<screen role="nodump"><userinput>install snd-pcm modprobe -i snd-pcm ; modprobe \
    snd-pcm-oss ; true</userinput></screen>

<para>Ceci fera que le système charge à la fois les modules 
<emphasis>snd-pcm</emphasis> et <emphasis>snd-pcm-oss</emphasis> quand toute
requête est faite pour charger le pilote
<emphasis>snd-pcm</emphasis>.</para></listitem>
</itemizedlist>
</sect2>

<sect2>
<title>Lecture utile</title>

<para>Des documentations supplémentaires sont disponibles sur les sites
suivants&nbsp;:</para>

<itemizedlist>
<listitem><para remap="verbatim">A Userspace Implementation of
<systemitem class="filesystem">devfs</systemitem> <ulink
url="http://www.kroah.com/linux/talks/ols_2003_udev_paper/Reprint-Kroah-Hartman-OLS2003.pdf"/>
(NdT&nbsp;: Une implémentation en espace utilisateur de devfs)</para></listitem>

<listitem><para remap="verbatim">FAQ udev
<ulink url="http://www.kernel.org/pub/linux/utils/kernel/hotplug/udev-FAQ"/></para></listitem>

<listitem><para remap="verbatim">The Linux Kernel Driver Model <ulink
url="http://public.planetmirror.com/pub/lca/2003/proceedings/papers/Patrick_Mochel/Patrick_Mochel.pdf"/>
(NdT&nbsp;: Le modèle du pilote pour le noyau Linux)</para></listitem>
</itemizedlist>
</sect2>

</sect1>

