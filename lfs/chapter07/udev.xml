<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
  "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../general.ent">
  %general-entities;
]>

<sect1 id="ch-scripts-udev">
  <?dbhtml filename="udev.html"?>

  <title>Gestion des périphériques et modules d'un système LFS</title>

  <indexterm zone="ch-scripts-udev">
    <primary sortas="a-Udev">Udev</primary>
    <secondary>utilisation</secondary>
  </indexterm>

  <para>Au <xref linkend="chapter-building-system"/>, nous avons
  installé le paquet Udev. Avant d'entrer dans les détails concernant son
  fonctionnement, un bref historique des méthodes précédentes de gestion
  des périphériques est nécessaire.</para>

  <para>Traditionnellement, les systèmes Linux utilisent une
  méthode de création de périphériques statiques avec laquelle un grand
  nombre de n&oelig;uds de périphériques sont créés sous
  <filename class="directory">/dev</filename> (quelque fois des milliers de n&oelig;uds),
  que le matériel correspondant existe ou pas.
  Ceci est fait typiquement avec un script <command>MAKEDEV</command>,
  qui contient des appels au programme <command>mknod</command> avec
  les numéros de périphériques majeurs et mineurs pour chaque périphérique
  possible qui pourrait exister dans le monde.</para>

  <para>En utilisant la méthode udev, seuls les n&oelig;uds pour le périphériques détectés
  par le noyau sont créés.
  Comme ces n&oelig;uds de périphériques seront créés à chaque lancement du
  système, ils seront stockés dans un système de fichiers
  <systemitem class="filesystem">devtmpfs</systemitem>
  (un système de fichiers virtuel qui réside entièrement dans la mémoire du système).
  Les n&oelig;uds de périphériques ne requièrent pas beaucoup d'espace, donc la mémoire utilisée est négligeable.</para>

  <sect2>
    <title>Historique</title>

    <para>En février 2000, un nouveau système de fichiers appelé
    <systemitem class="filesystem">devfs</systemitem>
    a été intégré au noyau 2.3.46 et rendu disponible pour la série 2.4 des noyaux stables.
    Bien qu'il soit présent dans les sources du noyau, cette méthode de création dynamique des périphériques
    n'a jamais reçu un support inconditionnel des développeurs du noyau.</para>

    <para>Le principal problème de l'approche adopté par
    <systemitem class="filesystem">devfs</systemitem> était la façon dont il gérait la
    détection, la création et le nommage des périphériques. Ce dernier problème, le
    nommage des périphériques, était peut-être le plus critique. Il est
    généralement accepté que s'il est possible de configurer les noms des
    périphériques, alors la politique de nommage des périphériques revient à
    l'administrateur du système, et du coup n'est imposée par aucun développeur en particulier.
    Le système de fichiers <systemitem class="filesystem">devfs</systemitem> souffre aussi de
    restrictions particulières inhérentes à sa conception et qui ne peuvent
    être corrigées sans une revue importante du noyau. Il a aussi été
    marqué comme obsolète pendant une longue période &mdash;&nbsp;à cause
    d'un manque de maintenance&nbsp;&mdash; et a finalement été supprimé du
    noyau en juin 2006.</para>

    <para>Avec le développement de la branche instable 2.5 du noyau, sortie ensuite en
    avec la série 2.6 des noyaux stables, un nouveau système de fichiers virtuel appelé
    <systemitem class="filesystem">sysfs</systemitem> est arrivé. Le rôle de
    <systemitem class="filesystem">sysfs</systemitem> est d'exporter une vue
    de la configuration matérielle du système pour les processus en espace utilisateur.
    Avec cette représentation visible en espace utilisateur,
    la possibilité de voir un remplacement de l'espace utilisateur pour
    <systemitem class="filesystem">devfs</systemitem>
    est devenu beaucoup plus réaliste.</para>

  </sect2>

  <sect2>
    <title>Implémentation d'Udev</title>

    <sect3>
      <title>Sysfs</title>

      <para>Le système de fichier
      <systemitem class="filesystem">sysfs</systemitem>
      a été brièvement mentionné ci-dessus. On pourrait se demander comment
      <systemitem class="filesystem">sysfs</systemitem>
      connaît les périphériques présents sur un système et quels numéros
      de périphériques devraient être utilisés. Les pilotes qui ont été
      compilés directement dans le noyau enregistrent leurs objets avec
      <systemitem class="filesystem">sysfs</systemitem> (en interne, devtmpfs) quand ils sont
      détectés par le noyau. Pour les pilotes compilés en tant que
      modules, cet enregistrement surviendra quand le module sera
      chargé. Une fois que le système de fichier
      <systemitem class="filesystem">sysfs</systemitem>
      est monté (sur
      <filename class="directory">/sys</filename>),
      les données enregistrées par les pilotes internes avec
      <systemitem class="filesystem">sysfs</systemitem>
      sont disponibles pour les processus en espace utilisateur ainsi que pour
      <command>udev</command>
      pour continuer (et faire même des modifications aux n&oelig;uds de périphériques).</para>

    </sect3>


    <sect3>
      <title>Création de n&oelig;uds de périphérique</title>

      <para>Les fichiers de périphérique sont créés par le noyau avec le
      système de fichiers <systemitem class="filesystem">devtmpfs</systemitem>.
      Tout pilote souhaitant enregistrer un n&oelig;ud de périphérique ira dans
      <systemitem class="filesystem">devtmpfs</systemitem> (par le c&oelig;ur du
      pilote) pour le faire. Quand une instance <systemitem class="filesystem">devtmpfs</systemitem>
      est montée sur <filename class="directory">/dev</filename>, le n&oelig;ud
      de périphérique sera créé dès le départ avec un nom, des droits et un
      propriétaire figés.</para>
      

      <para>Peu de temps après, le noyau enverra un uevent à <command>udevd</command>.
      À partir des règles indiquées dans les fichiers contenus dans les répertoires
      <filename class="directory">/etc/udev/rules.d</filename>,
      <filename class="directory">/lib/udev/rules.d</filename> et
      <filename class="directory">/run/udev/rules.d</filename>,
      <command> udevd</command> créera les liens symboliques supplémentaires vers le
      n&oelig;ud de périphérique, ou bien il modifiera ses droits, son propriétaire
      ou son groupe, ou l'entrée dans la base de données interne d'<command>udevd</command>
      concernant cet objet.</para>

      <para>Les règles de ces trois répertoires sont numérotées de la même
      façon que dans le paquet LFS-Bootscripts et les trois répertoires sont
      mis à jour ensemble. Si <command>udevd</command> ne peut pas trouver de
      règles pour le périphérique qu'il crée, il en donnera la propriété et les
      droits à n'importe quel <systemitem class="filesystem">devtmpfs</systemitem>
      utilisé au départ.</para>

    </sect3> 

    <sect3>
      <title>Les scripts de démarrage d'Udev</title>

      <para>Le premier script de démarrage de LFS,
      <filename>/etc/init.d/mountvirtfs</filename>, va copier les périphériques de
      <filename class="directory">/lib/udev/devices</filename> vers
      <filename class="directory">/dev</filename>. C'est nécessaire car certains
      périphériques, certains répertoires et certains liens symboliques sont
      requis avant que les processus de gestion dynamique des périphériques ne soient
      disponibles au tout début du démarrage d'un système ou car ils sont exigés
      par <command>udevd</command> lui-même. La création de n&oelig;uds de
      périphériques statiques dans <filename
      class="directory">/lib/udev/devices</filename> offre aussi un contournement
      facile pour les périphériques qui ne sont pas supportés par l'infrastructure
      de gestion dynamique des périphériques.</para> 

      <para>Le script de démarrage <filename>/etc/rc.d/init.d/udev</filename> 
      démarre <command>udevd</command>, récupère tous les périphériques "montés à
      froid"" ayant déjà été créés par le noyau et et il attend les règles pour
      se terminer. Le script défait aussi le gestionnaire d'uevent de son
      paramétrage par défaut <filename>/sbin/hotplug </filename>.  Cela se fait
      car le noyau n'a plus besoin d'appeler de binaires externes. À la place,
      <command>udevd</command> listera sur une socket netlink les uevents que
      le noyau détecte.</para> 

      <para>Le script de démarrage <command>/etc/rc.d/init.d/udev_retry</command>
      prend soin de ratraper les événements pour les sous-systèmes dont les règles
      peuvent s'appuyer sur des systèmes de fichiers non montés jusqu'à ce que
      le script <command>mountfs</command> ne s'exécute (en particulier,
      <filename class="directory">/usr</filename>
      et <filename class="directory">/var</filename> peut causeer cela).  Ce
      script se lance après que le script <command>mountfs</command>, afin
      que les règles (si récupérées), réussissent la deuxième fois. Il est
      configuré à partir du fichier <filename>/etc/sysconfig/udev_retry</filename>&nbsp;;
      tous les mots de ce fichier différents de commentaires sont considérés comme
      des noms de sous-systèmes pour récupérer lors de la nouvelle tentative.
      Pour trouver le sous-système d'un périphérique, utilisez
      <command>udevadm info --attribute-walk &lt;périphérique&gt;</command> où
      &lt;périphérique&gt; est un chemin absolu dans /dev ou /sys tel que /dev/sr0 ou
      /sys/class/rtc.</para>
    </sect3>

    <sect3>
      <title>Chargement d'un module</title>

      <para>Il se peut que les pilotes des périphériques compilés en
      module aient aussi des alias compilés. Les alias sont
      visibles dans la sortie du programme <command>modinfo</command> et
      sont souvent liés aux identifiants spécifiques du bus des
      périphériques supportés par un module. Par exemple, le pilote
      <emphasis>snd-fm801</emphasis> supporte les périphériques PCI
      ayant l'ID fabricant 0x1319 et l'ID de périphérique 0x0801
      a aussi un alias <quote>pci:v00001319d00000801sv*sd*bc04sc01i*</quote>.
      Pour la plupart des périphériques, le pilote du bus définit l'alias du pilote qui
      gérerait le périphérique via <systemitem class="filesystem">sysfs</systemitem>.
      Par exemple, le fichier <filename>/sys/bus/pci/devices/0000:00:0d.0/modalias</filename>
      pourrait contenir la chaîne <quote>pci:v00001319d00000801sv00001319sd00001319bc04sc01i00</quote>.
      Il résultera des règles fournies par défaut qu'<command>udevd</command>
      fera appel à <command>/sbin/modprobe</command>
      avec le contenu de la variable d'environnement de l'uevent <envar>MODALIAS</envar>
      (qui devrait être la même que le contenu du fichier  <filename>modalias</filename> dans sysfs),
      donc chargera tous les modules dont les alias correspondent à cette chaîne
      après les expansions génériques.</para>

      <para>Dans cet exemple, cela signifie que, outre <emphasis>snd-fm801</emphasis>,
      le pilote obsolète (et non désiré) <emphasis>forte</emphasis>
      sera chargé s'il est disponible. Voir ci-dessous les moyens d'empêcher
      le chargement des modules indésirables.</para>

      <para>Le noyau lui-même est aussi capable de charger des modules
      de protocole réseau, de support pour des systèmes de fichiers et
      des NLS sur demande.</para>

    </sect3>

    <sect3>
      <title>Gestion des périphériques dynamiques ou montables à chaud</title>

      <para>Quand vous connectez un périphérique, comme un lecteur MP3 USB,
      le noyau reconnaît que le périphérique est maintenant connecté et
      génère un uevent. Cet uevent est alors géré par
      <command>udevd</command> comme décrit ci-dessus.</para>

    </sect3>

  </sect2>

  <sect2>
    <title>Problèmes avec le chargement des modules et la création des périphériques</title>

    <para>Il existe quelques problèmes connus pour la création
    automatique des n&oelig;uds de périphériques&nbsp;:</para>

    <sect3>
      <title>Un module noyau n'est pas chargé automatiquement</title>

      <para>Udev ne chargera un module que s'il a un alias spécifique au
      bus et que le pilote du bus envoie correctement les alias
      nécessaires vers <systemitem class="filesystem">sysfs</systemitem>.
      Sinon, il faut organiser le chargement des modules par d'autres moyens.
      Avec Linux-&linux-version;, Udev est connu pour charger
      les pilotes correctement écrits pour les périphériques
      INPUT, IDE, PCI, USB, SCSI, SERIO et FireWire.</para>

      <para>Pour déterminer si le pilote du périphérique dont vous avez
      besoin a le support nécessaire pour Udev, lancez
      <command>modinfo</command> avec le nom du module en argument.
      Puis, essayez de localiser le répertoire du périphérique
      sous <filename class="directory">/sys/bus</filename> et vérifiez
      s'il y a un fichier <filename>modalias</filename>.</para>

      <para>Si le fichier <filename>modalias</filename> existe dans
      <systemitem class="filesystem">sysfs</systemitem>, alors le pilote
      supporte le périphérique et peut lui parler directement, mais
      s'il n'a pas d'alias, c'est un bogue dans le pilote. Chargez le
      pilote sans l'aide d'Udev et attendez que le problème soit corrigé
      plus tard.</para>

      <para>S'il n'y a pas de fichier <filename>modalias</filename>
      dans le bon répertoire sous <filename class="directory">/sys/bus</filename>,
      cela signifie que les développeurs du noyau n'ont pas encore ajouté de support
      modalias à ce type de bus. Avec Linux-&linux-version;, c'est le
      cas pour les bus ISA. Attendez que ce problème soit réparé dans
      les versions ultérieures du noyau.</para>

      <para>Udev n'a pas du tout pour but de charger des pilotes <quote>wrapper</quote>
      (qui emballent un autre pilote) comme <emphasis>snd-pcm-oss</emphasis>
      et des pilotes non matériels comme <emphasis>loop</emphasis>.</para>

    </sect3>

    <sect3>
      <title>Un module du noyau n'est pas chargé automatiquement et
      Udev n'est pas prévu pour le charger</title>

      <para>Si le module <quote>wrapper</quote> n'améliore que la
      fonctionnalité fournie par un autre module (comme
      <emphasis>snd-pcm-oss</emphasis> améliore la fonctionnalité de
      <emphasis>snd-pcm</emphasis> en rendant les cartes son disponibles pour les applications OSS),
      configurez <command>modprobe</command> pour charger le wrapper
      après qu'Udev ait chargé le module emballé. Pour cela, ajoutez une ligne
      <quote>softdep</quote> dans tous les fichiers
      <filename>/etc/modprobe.d/<replaceable>&lt;filename&gt;</replaceable>.conf</filename>.
      Par exemple&nbsp;:</para>

<screen role="nodump"><literal>softdep snd-pcm post: snd-pcm-oss</literal></screen>

      <para>Remarquez que la commande <quote>softdep</quote> autorise aussi les dépendances
      <literal>pre:</literal>, ou un mélange de
      <literal>pre:</literal> et de <literal>post:</literal>. Voir la page de
      manuel de <filename>modprobe.d(5)</filename> pour plus d'informations
      sur la syntaxe et les possibilités de <quote>softdep</quote>.</para>

      <para>Si le module en question n'est pas un emballage et s'avère
      utile en tant que tel, configurez le script de démarrage
      <command>modules</command> pour charger ce module sur le
      système de démarrage. Pour cela, ajoutez le nom du module au fichier
      <filename>/etc/sysconfig/modules</filename> sur une ligne séparée.
      Ceci fonctionne aussi pour les modules d'emballage, mais sans
      être optimal.</para>

    </sect3>

    <sect3>
      <title>Udev charge un module indésirable</title>

      <para>Ne compilez pas le module, ou mettez-le en liste noire dans un fichier
      <filename>/etc/modprobe.d/blacklist.conf</filename>
      comme nous l'avons fait avec le module <emphasis>forte</emphasis>
      dans l'exemple ci-dessous&nbsp;:</para>

<screen role="nodump"><literal>blacklist forte</literal></screen>

      <para>Les modules en liste noire peuvent toujours être chargés
      manuellement avec la commande explicite <command>modprobe</command>.</para>

    </sect3>

    <sect3>
      <title>Udev crée mal un périphérique, ou crée un mauvais lien symbolique</title>

      <para>Cela se produit habituellement si une règle correspond à un
      périphérique de façon imprévue. Par exemple, une règle lacunaire
      peut correspondre à un disque SCSI (comme désiré)
      et au périphérique SCSI générique du même fabricant (de façon incorrecte).
      Trouvez la règle défectueuse et affinez-la, à l'aide de la commande
      <command>udevadm info</command></para>

    </sect3>

    <sect3>
      <title>Une règle Udev fonctionne de manière non fiable</title>

      <para>Cela peut être une autre manifestation du problème précédent.
      Sinon, et si votre règle utilise les attributs de
      <systemitem class="filesystem">sysfs</systemitem>, il se peut que
      ce soit un problème de timing du noyau, sur le point d'être
      corrigé dans les noyaux ultérieurs.
      Pour le moment, vous pouvez contourner en créant une règle qui attend l'attribut
      <systemitem class="filesystem">sysfs</systemitem> utilisé et en le
      mettant dans le fichier <filename>/etc/udev/rules.d/10-wait_for_sysfs.rules</filename>
      (créez ce fichier s'il n'existe pas). Merci d'informer la liste de
      développement de LFS si vous faites ainsi et que cela vous aide.</para>

    </sect3>

    <sect3>
      <title>Udev ne crée pas de périphérique</title>

      <para>Le texte ci-après suppose que le pilote est compilé de
      manière statique dans le noyau ou qu'il est déjà chargé comme
      module, et que vous avez déjà vérifié qu'Udev ne crée pas de
      périphérique mal nommé.</para>

      <para>Udev n'a pas besoin d'information pour créer un n&oelig;ud
      de périphérique si le pilote du noyau n'envoie pas ses données vers
      <systemitem class="filesystem">sysfs</systemitem>.
      C'est ce qu'il y a de plus courant avec les pilotes tierce partie à
      l'extérieur de l'arborescence du noyau. Créez un n&oelig;ud de
      périphérique statique dans <filename>/lib/udev/devices</filename>
      avec les numéros majeurs/mineurs appropriés (voir le fichier
      <filename>devices.txt</filename> dans la documentation du noyau ou
      la documentation fournie par le fabricant du pilote tierce
      partie). Le n&oelig;ud du périphérique statique sera copié vers
      <filename class="directory">/dev</filename> par le script de
      démarrage <command>udev</command>.</para>

    </sect3>

    <sect3>
      <title>L'ordre de nommage des périphériques change de manière aléatoire après le redémarrage</title>

      <para>Cela est dû au fait qu'Udev, par nature, gère les uevents
      et charge les modules en parallèle, donc dans un ordre imprévisible.
      Cela ne sera jamais <quote>corrigé</quote>. Vous ne
      devriez pas supposer que les noms des périphériques du noyau sont
      stables. Créez plutôt vos propres règles qui rendent les liens
      symboliques stables basés sur des attributs stables du
      périphérique, comme une série de nombre ou la sortie de divers
      utilitaires *_id installés par Udev. Voir la <xref linkend="ch-scripts-symlinks"/> et
      la <xref linkend="ch-scripts-network"/> pour des exemples.</para>

    </sect3>

  </sect2>

  <sect2>
    <title>Lecture utile</title>

    <para>Des documentations supplémentaires sont disponibles sur les
    sites suivants&nbsp;:</para>

    <itemizedlist>

      <listitem>
        <para>A Userspace Implementation of <systemitem class="filesystem">devfs</systemitem>
        <ulink url="http://www.kroah.com/linux/talks/ols_2003_udev_paper/Reprint-Kroah-Hartman-OLS2003.pdf"/>
        (NdT&nbsp;: Une implémentation en espace utilisateur de devfs)</para>
      </listitem>

      <listitem>
        <para>The <systemitem class="filesystem">sysfs</systemitem> Filesystem
        <ulink url="http://www.kernel.org/pub/linux/kernel/people/mochel/doc/papers/ols-2005/mochel.pdf"/>
        (NdT&nbsp;: Le système de fichiers <systemitem class="filesystem">sysfs</systemitem>)</para>
      </listitem>

<!--      <listitem>
        <para>Pointers to further reading
        <ulink url="http://www.kernel.org/pub/linux/utils/kernel/hotplug/udev.html"/>
        (NdT&nbsp;: Pointeurs vers de plus amples lectures)</para>
      </listitem>-->

    </itemizedlist>

  </sect2>

</sect1>
