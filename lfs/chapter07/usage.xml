<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
  "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../general.ent">
  <!ENTITY site               SYSTEM "../appendices/rc.site.script">
  %general-entities;
]>

<sect1 id="ch-scripts-usage">
  <?dbhtml filename="usage.html"?>

  <title>Utiliser et configurer les scripts de démarrage de System V</title>

  <indexterm zone="ch-scripts-usage">
    <primary sortas="a-Bootscripts">Bootscripts</primary>
    <secondary>utilisation</secondary>
  </indexterm>

  <sect2>
    <title>Comment fonctionnent les scripts de démarrage de System V&nbsp;?</title>

  <para>Linux utilise un service de démarrage spécial nommé SysVinit qui
  est basé sur un concept de <emphasis>niveaux d'exécution</emphasis>.
  Il peut être très différent d'un système à un autre, du coup, il ne
  peut pas être supposé que parce que cela fonctionne sur une
  distribution Linux particulière, cela fonctionnera de la même façon
  dans LFS. LFS a sa propre façon de le faire mais il respecte
  généralement les standards établis.</para>

  <para>SysVinit (qui sera nommé par la suite <quote>init</quote>)
  fonctionne en utilisant un schéma de niveaux d'exécution. Ils sont au
  nombre de sept (numérotés de 0 à 6). En fait, il en existe plus mais
  ils sont réservés à des cas spéciaux et ne sont généralement pas utilisés.
  Voir <filename>init(8)</filename> pour plus de détails. Chacun d'entre
  eux correspond à des actions que l'ordinateur est supposé effectuer
  lorsqu'il démarre. Le niveau d'exécution par défaut est 3. Voici les
  descriptions sur l'implémentation des différents niveaux d'exécution&nbsp;:</para>

<literallayout>0: arrête l'ordinateur
1: mode mono-utilisateur
2: mode multi-utilisateur sans réseau
3: mode multi-utilisateur avec réseau
4: réservé pour la personnalisation, sinon identique à 3
5: identique à 4, il est habituellement utilisé pour la connexion GUI (comme <command>xdm</command> de X ou <command>kdm</command> de KDE)
6: redémarre l'ordinateur</literallayout>

  </sect2>

  <sect2 id="conf-sysvinit" role="configuration">
  <title>Configuration de Sysvinit</title>

  <indexterm zone="conf-sysvinit">
    <primary sortas="a-Sysvinit">Sysvinit</primary>
    <secondary>configuration</secondary>
  </indexterm>

  <indexterm zone="conf-sysvinit">
    <primary sortas="e-/etc/inittab">/etc/inittab</primary>
  </indexterm>

  <para>Lors de l'initialisation du noyau, le premier programme qui se lance
  est soit spécifié sur la ligne de commande, soit, par défaut,
  <command>init</command>. Ce programme lit le fichier d'initialisation
  <filename>/etc/inittab</filename>. Créez ce fichier avec&nbsp;:</para>

<screen><userinput>cat &gt; /etc/inittab &lt;&lt; "EOF"
<literal># Début de /etc/inittab

id:3:initdefault:

si::sysinit:/etc/rc.d/init.d/rc S

l0:0:wait:/etc/rc.d/init.d/rc 0
l1:S1:wait:/etc/rc.d/init.d/rc 1
l2:2:wait:/etc/rc.d/init.d/rc 2
l3:3:wait:/etc/rc.d/init.d/rc 3
l4:4:wait:/etc/rc.d/init.d/rc 4
l5:5:wait:/etc/rc.d/init.d/rc 5
l6:6:wait:/etc/rc.d/init.d/rc 6

ca:12345:ctrlaltdel:/sbin/shutdown -t1 -a -r now

su:S016:once:/sbin/sulogin

1:2345:respawn:/sbin/agetty --noclear tty1 9600
2:2345:respawn:/sbin/agetty tty2 9600
3:2345:respawn:/sbin/agetty tty3 9600
4:2345:respawn:/sbin/agetty tty4 9600
5:2345:respawn:/sbin/agetty tty5 9600
6:2345:respawn:/sbin/agetty tty6 9600

# Fin de /etc/inittab</literal>
EOF</userinput></screen>

  <para>Vous trouverez une explication de ce fichier d'initialisation dans la
  page de manuel de <emphasis>inittab</emphasis>. Pour LFS, la commande clé qui se lance est
  <command>rc</command>. Le fichier d'initialisation ci-dessus demandera à
  <command>rc</command> de lancer tous les scripts commençant par un S qui sont dans
  le répertoire <filename class="directory">/etc/rc.d/rcS.d</filename>,
  puis tous les scripts commençant par un S du répertoire
  <filename class="directory">/etc/rc.d/rc?.d</filename> où le point d'interrogation
  est spécifié par la valeur initdefault.</para>

  <para>Par commodité, le script <command>rc</command> lit une bibliothèque
  de fonctions dans <filename class="directory">/lib/lsb/init-functions</filename>.
  Cette bibliothèque lit aussi un fichier de configuration facultatif,
  <filename>/etc/sysconfig/rc.site</filename>. Tous les paramètres du
  fichier de configuration du système décrits dans les sections suivantes peuvent
  être mis dans ce fichier, ce qui permet de rassembler tous les paramètres
  systèmes dans un seul fichier.</para>

  <para>Pour faciliter le débogage, le script functions enregistre aussi toute
  la sortie dans <filename>/run/var/bootlog</filename>. Le répertoire <filename
  class="directory">/run</filename> étant un tmpfs, ce fichier n'est pas
  persistant entre les redémarrages, il est cependant envoyé dans le fichier plus
  permanent <filename>/var/log/boot.log</filename> à la fin du processus de démarrage.</para>

  <sect3 id="init-levels" >
  <title>Modifier les niveaux d'exécution</title>

  <para>La commande utilisée pour modifier le niveau d'exécution est
  <command>init
  <replaceable>&lt;[niveau_exécution]&gt;</replaceable></command>, où
  <replaceable>&lt;[niveau_exécution]&gt;</replaceable> est le niveau d'exécution cible.
  Par exemple, pour redémarrer l'ordinateur, un utilisateur pourrait
  lancer la commande <command>init 6</command>
  qui est un alias de la commande <command>reboot</command>. De même,
  <command>init 0</command> est un alias pour la commande <command>halt</command>.</para>

  <para>Il existe un certain nombre de répertoires sous
  <filename class="directory">/etc/rc.d</filename> qui ressemble à
  <filename class="directory">rc?.d</filename> (où ? est le numéro du niveau d'exécution) et
  <filename class="directory">rcsysinit.d</filename>, tous contenant un
  certain nombre de liens symboliques. Certains commencent avec un
  <emphasis>K</emphasis>, les autres avec un <emphasis>S</emphasis>,
  et tous ont deux nombres après la lettre initiale. Le K signifie l'arrêt (kill)
  d'un service et le S son lancement (start).
  Les nombres déterminent l'ordre dans lequel les scripts sont exécutés,
  de 00 à 99 &mdash;&nbsp;plus ce nombre est petit, plus tôt le script correspondant sera exécuté.
  Quand <command>init</command> bascule sur un autre niveau d'exécution, les services appropriés
  sont soit lancés soit tués, suivant le niveau d'exécution choisi.</para>

  <para>Les vrais scripts sont dans <filename class="directory">/etc/rc.d/init.d</filename>.
  Ils font le vrai boulot et les liens symboliques pointent tous vers eux. Les liens K et
  les liens S pointent vers le même script dans <filename class="directory">/etc/rc.d/init.d</filename>.
  Ceci est dû au fait que les scripts peuvent être appelés avec différents paramètres comme
  <parameter>start</parameter>, <parameter>stop</parameter>,
  <parameter>restart</parameter>, <parameter>reload</parameter> et
  <parameter>status</parameter>.
  Quand un lien K est rencontré, le script approprié est lancé avec l'argument
  <parameter>stop</parameter>.
  Quand un lien S est rencontré, le script approprié est lancé avec l'argument
  <parameter>start</parameter>.</para>

  <para>Il existe une exception à cette explication. Les liens
  commençant avec un <emphasis>S</emphasis> dans les répertoires
  <filename class="directory">rc0.d</filename> et
  <filename class="directory">rc6.d</filename> ne lanceront aucun service.
  Ils seront appelés avec l'argument
  <parameter>stop</parameter> pour arrêter quelque chose.
  La logique derrière ceci est que, quand un utilisateur va redémarrer
  ou arrêter le système, rien ne doit être lancé. Le système a seulement besoin d'être arrêté.</para>

  <para>Voici les descriptions de ce que font les arguments des
  scripts&nbsp;:</para>

  <variablelist>

    <varlistentry>
      <term><parameter>start</parameter></term>
      <listitem>
        <para>Le service est lancé.</para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><parameter>stop</parameter></term>
      <listitem>
        <para>Le service est stoppé.</para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><parameter>restart</parameter></term>
      <listitem>
        <para>Le service est stoppé puis relancé.</para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><parameter>reload</parameter></term>
      <listitem>
        <para>La configuration du service est mise à jour.
        Ceci est utilisé après modification du fichier de configuration d'un service, quand
        le service n'a pas besoin d'être redémarré.</para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><parameter>status</parameter></term>
      <listitem>
        <para>Indique si le service est en cours d'exécution ainsi que les PID associés.</para>
      </listitem>
    </varlistentry>

  </variablelist>

  <para>Vous êtes libre de modifier la façon dont le processus de
  démarrage fonctionne (après tout, c'est votre système LFS). Les
  fichiers donnés ici sont un exemple d'une façon de faire.</para>

  </sect3>
  </sect2>
 
  <sect2>
    <title>Les scripts de démarrage Udev</title>

      <para>Le script de démarrage <filename>/etc/rc.d/init.d/udev</filename> 
      lance <command>udevd</command>, récupère les périphériques "branchés à froid" créés 
      d'ores et déjà par le noyau et attend des règles pour se terminer.
      Le script supprime aussi du gestionnaire d'uevent le réglage par défaut
      <filename>/sbin/hotplug </filename>.  On fait cela car le noyau n'a plus besoin
      de faire appel à un binaire externe. Par contre,
      <command>udevd</command> va écouter sur une socket netlink les uevents
      engendrés par le noyau.</para>

      <para>Le script de démarrage <command>/etc/rc.d/init.d/udev_retry</command>
      se charge de récupérer les événements des sous-systèmes dont les règles s'appuient
      sur des systèmes de fichiers non montés jusqu'à ce que le script
      <command>mountfs</command> soit lancé (en particulier, <filename class="directory">/usr</filename>
      et <filename class="directory">/var</filename> peuvent avoir cet effet).
      Ce script s'exécute après le script <command>mountfs</command>, donc ces
      règles (si elles sont de nouveau récupérées) devraient s'appliquer la deuxième fois.
      Il se configure à partir du fichier <filename>/etc/sysconfig/udev_retry</filename>&nbsp;;
      donc tout mot autre que des commentaires dans ce fichier est vu comme un
      nom de sous-système à rattraper lorsqu'il lance le nouvel essai. Pour trouver
      le sous-système d'un périphérique, utilisez <command>udevadm info --attribute-walk &lt;périphérique&gt;</command> où
      &lt;périphérique&gt; est un chemin absolu dans /dev ou /sys comme /dev/sr0 ou
      /sys/class/rtc.</para>

    <sect3>
      <title>Chargement d'un module</title>

      <para>Les pilotes de périphériques compilés en tant que modules peuvent
      avoir des alias compilés en eux. Les
      alias sont visibles dans la sortie du programme <command>modinfo</command>
      et ils sont généralement liés aux identifiants spécifiques des
      bus de périphériques supportés par un module. Par exemple, le pilote <emphasis>snd-fm801</emphasis>
      supporte les périphériques PCI de la marque dont l'ID est 0x1319 et
      l'ID du périphérique est 0x0801, et son alias est <quote>pci:v00001319d00000801sv*sd*bc04sc01i*</quote>.
      Pour la plupart des périphériques, le pilote du périphérique exporte l'alias
      du pilote qui gérerait le périphérique via <systemitem
      class="filesystem">sysfs</systemitem>. Par exemple, le fichier
      <filename>/sys/bus/pci/devices/0000:00:0d.0/modalias</filename> pourrait
      contenir la chaîne
      <quote>pci:v00001319d00000801sv00001319sd00001319bc04sc01i00</quote>.
      Les règles par défaut fournies avec Udev amèneront <command>udevd</command>
      à faire appel à <command>/sbin/modprobe</command> avec le contenu de
      la variable d'environnement de l'uevent <envar>MODALIAS</envar> (qui devrait être
      le même que celui du fichier <filename>modalias</filename> dans sysfs),
      d'où il résulte ainsi que tous les modules dont les alias correspondent à
      cette chaîne, après le développement des jokers.</para>

      <para>Dans cet exemple, cela signifie que, outre
      <emphasis>snd-fm801</emphasis>, le pilote obsolète (et qu'on ne veut pas)
      <emphasis>forte</emphasis> sera chargé s'il est disponible. Voir
      ci-dessous les façons dont on peut empêcher le chargement de pilotes non
      souhaités.</para>

      <para>Le noyau lui-même peut également charger des modules pour les protocoles
      réseaux, les systèmes de fichiers et le support NLS, à la demande.</para>

    </sect3>

    <sect3>
      <title>Gérer les périphériques qu'on branche à chaud/dynamiques</title>

      <para>Quand vous branchez un périphérique, comme un lecteur MP3 USB
      (Universal Serial Bus)  (USB), le noyau identifie que le périphérique est
      connecté et il génère un uevent. Cet uevent est alors géré par
      <command>udevd</command> comme indiqué ci-dessus.</para>

    </sect3>
  </sect2>

  <sect2 id="ch-scripts-clock">
  <title>Configurer l'horloge du système</title>

    <indexterm zone="ch-scripts-clock">
     <primary sortas="d-scripts-setclock">setclock</primary>
     <secondary>configuration</secondary></indexterm>

    <para>Le script <command>setclock</command> lit l'heure à partir de l'horloge
    matérielle, appelée aussi BIOS ou <foreignphrase>Complementary Metal Oxide 
    Semiconductor</foreignphrase> (CMOS). Si l'horloge matérielle est réglée sur
    UTC, ce script convertira l'heure de l'horloge matérielle en heure locale en utilisant
    le fichier <filename>/etc/localtime</filename> (qui indique au programme
    <command>hwclock</command> le fuseau horaire de l'utilisateur). Il n'y a aucun
    moyen de détecter si l'horloge matérielle est réglée sur UTC, donc vous
    devez le configurer manuellement.</para>

    <para>Le script <command>setclock</command> se lance via
    <application>udev</application> quand le noyau détecte le matériel au démarrage. 
    Vous pouvez aussi le lancer à la main avec le paramètre stop pour stocker
    l'heure du système dans l'horloge CMOS.</para>

    <para>Si vous ne vous rappelez pas si l'horloge matérielle est réglée sur UTC,
    assurez-vous-en en lançant la commande <userinput>hwclock --localtime --show</userinput>.
    Cela affichera l'heure actuelle selon l'horloge matérielle. Si elle correspond à 
    ce qu'indique votre montre, l'horloge matérielle est en heure locale. Si la
    sortie de <command>hwclock</command> n'est pas l'heure locale, il y a des
    chances qu'il s'agisse de l'heure UTC. Vérifiez-le en ajoutant ou enlevant
    le bon nombre d'heures du fuseau horaire de l'heure affichée avec 
    <command>hwclock</command>. Par exemple, si vous êtes dans le fuseau MST,
    connu aussi sous le nom GMT -0700, ajoutez sept heures à l'heure locale.</para>

    <para>Passez la valeur de la variable <envar>UTC</envar> ci-dessous
    à la valeur <parameter>0</parameter> (zéro) si vhorloge matérielle
    <emphasis>n'est pas</emphasis> réglée sur l'heure UTC.</para>

    <para>Créez un nouveau fichier <filename>/etc/sysconfig/clock</filename> en
    lançant ce qui suit&nbsp;:</para>

<screen><userinput>cat &gt; /etc/sysconfig/clock &lt;&lt; "EOF"
<literal># Début de /etc/sysconfig/clock

UTC=1

# Mettez ici les options que vous pourriez devoir donner à hwclock,
# comme le type de l'horloge matérielle de la machine pour les Alphas.
CLOCKPARAMS=

# Fin de /etc/sysconfig/clock</literal>
EOF</userinput></screen>

    <para>Une bonne astuce expliquant la gestion de l'heure sur LFS est 
    disponible sur <ulink url="http://www.fr.linuxfromscratch.org/view/astuces/heure.txt"/>.
    Elle traite de sujets tels que les fuseaux horaires, UTC et la variable
    d'environnement <envar>TZ</envar>.</para>

    <note><para>Vous pouvez aussi régler les paramètres CLOCKPARAMS et UTC dans
    le fichier <filename>/etc/sysconfig/rc.site</filename>.</para></note>

  </sect2>

  <sect2 id="ch-scripts-console">
  <?dbhtml filename="console.html"?>

  <title>Configurer la Console Linux</title>

  <indexterm zone="ch-scripts-console">
    <primary sortas="d-console">console</primary>
    <secondary>configuration</secondary>
  </indexterm>

  <para>Cette section discute de la configuration du script de démarrage
  <command>console</command>, initialisant
  la disposition du clavier, la police de la console et le niveau de journalisation du noyau.
  Si des caractères non ASCII (par exemple, les symboles copyright, livre anglaise et Euro) ne seront pas utilisés et que le
  clavier est américain, passez cette section. Sans le fichier de configuration, (ou
  son équivalent dans <filename>rc.site</filename>), le script de démarrage
  <command>console</command> ne fera rien.</para>

  <para>Le script <command>console</command>  lit les informations de configuration du fichier
  <filename>/etc/sysconfig/console</filename>.
  Il décide de la disposition de clavier et de la police de la
  console à utiliser. Différents guides pratiques spécifiques aux
  langues peuvent aussi être d'une grande aide (voir
  <ulink url="http://www.tldp.org/HOWTO/HOWTO-INDEX/other-lang.html"/>).
  Si vous avez toujours des doutes, jetez un &oelig;il dans les
  répertoires <filename class="directory">/usr/share/keymaps</filename> et
  <filename class="directory">/usr/share/consolefonts</filename> pour des dispositions de
  clavier valides et des polices d'écran. Lisez les pages de manuel
  <filename>loadkeys(1)</filename> et <filename>setfont(8)</filename>
  pour déterminer les bons arguments pour ces programmes.</para>

  <para>Le fichier <filename>/etc/sysconfig/console</filename> devrait
  contenir des lignes de la forme&nbsp;: VARIABLE="valeur". Les
  variables suivantes sont reconnues&nbsp;:</para>

  <variablelist>

    <varlistentry>
      <term>LOGLEVEL</term>
      <listitem>
        <para>Cette variable spécifie le niveau de traçage pour les messages du
        noyau envoyés à la console, selon le paramétrage de
        <command>dmesg</command>. Les niveaux valides vont de <quote>1</quote> (aucun
        message) à <quote>8</quote>. Le niveau par défaut est <quote>7</quote>.</para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>KEYMAP</term>
      <listitem>
        <para>Cette variable spécifie les arguments du programme
        <command>loadkeys</command>, en général le nom de la disposition de
        clavier a charger, comme <quote>it</quote>. Si cette variable n'est pas réglée,
        le script de démarrage ne lancera pas le programme <command>loadkeys</command>
        et la disposition du clavier du noyau par défaut sera utilisée. Remarquez
        que certaines dispositions ont plusieurs versions ayant le même nom
        (cz et ses variantes dans qwerty/ et qwertz/, es dans olpc/ et qwerty/, et trf dans fgGIod/ et
        qwerty/). Dans ces cas, vous devriez aussi spécifier le répertoire parent
        (comme qwerty/es) pour vous assurer que la disposition sera bien chargée.</para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>KEYMAP_CORRECTIONS</term>
      <listitem>
        <para>Cette variable (rarement utilisée) spécifie les arguments du
        second appel au programme <command>loadkeys</command>. C'est
        utile si la disposition du clavier stocké n'est pas totalement satisfaisant
        et que vous devez faire un petit ajustement. Par exemple, pour inclure le
		signe Euro dans une disposition de clavier qui ne l'a normalement pas, réglez
		cette variable à <quote>euro2</quote>.</para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>FONT</term>
      <listitem>
        <para>Cette variable spécifie les arguments du programme
        <command>setfont</command>. En principe, ceci inclut le nom de la police,
        <quote>-m</quote> et le nom de la disposition de clavier de l'application
        à charger. Par exemple, pour charger la police <quote>lat1-16</quote>
        avec la disposition de clavier de l'application <quote>8859-1</quote>, (comme
        il convient aux États-Unis),
        <!-- because of the copyright sign -->
        réglez cette variable à <quote>lat1-16 -m 8859-1</quote>.
        En mode UTF-8, le noyau utilise la disposition de clavier de l'application
        pour la conversion de codes de touche 8-bits composés dans la disposition de
        clavier en UTF-8, et ainsi vous devriez initialiser l'argument du
        paramètre "-m" à l'encodage des codes de touche composés dans la disposition de clavier.</para>

      </listitem>
    </varlistentry>

    <varlistentry>
      <term>UNICODE</term>
      <listitem>
        <para>Réglez cette variable à <quote>1</quote>, <quote>yes</quote> ou
	    <quote>true</quote> afin de mettre la console en mode UTF-8. Ceci
        est utile pour les locales basées sur UTF-8 et nuisible sinon.</para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>LEGACY_CHARSET</term>
      <listitem>
        <para>Pour beaucoup de types de clavier, il n'y a pas de disposition de
        clavier pour le stock Unicode dans le paquet Kbd. Le script de démarrage
        <command>console</command> convertira une disposition de clavier disponible en
        UTF-8 au vol si cette variable est réglée à l'encodage de la disposition du clavier non UTF-8 disponible.</para>
      </listitem>
    </varlistentry>

  </variablelist>

  <para>Quelques exemples&nbsp;:</para>

  <itemizedlist>

    <listitem>
      <para>Pour une initialisation non Unicode, en général seules les
      variables KEYMAP et FONT sont nécessaires. Par exemple, pour
      l'initialisation en polonais, on utiliserait&nbsp;:</para>

<screen role="nodump"><userinput>cat &gt; /etc/sysconfig/console &lt;&lt; "EOF"
<literal># Début de /etc/sysconfig/console

KEYMAP="pl2"
FONT="lat2a-16 -m 8859-2"

# Fin de /etc/sysconfig/console</literal>
EOF</userinput></screen>
    </listitem>

    <listitem>
      <para>Comme mentionné ci-dessus, il est parfois nécessaire d'ajuster
      légèrement une disposition de clavier stockée. L'exemple suivant ajoute le symbole
      Euro a la disposition allemande du clavier&nbsp;:</para>

<screen role="nodump"><userinput>cat &gt; /etc/sysconfig/console &lt;&lt; "EOF"
<literal># Début de /etc/sysconfig/console

KEYMAP="de-latin1"
KEYMAP_CORRECTIONS="euro2"
FONT="lat0-16 -m 8859-15"

# Fin de /etc/sysconfig/console</literal>
EOF</userinput></screen>
    </listitem>

    <listitem>
      <para>Ce qui suit est un exemple avec l'Unicode activé pour le bulgare, où
      une disposition du clavier UTF-8 stockée existe&nbsp;:</para>

<screen role="nodump"><userinput>cat &gt; /etc/sysconfig/console &lt;&lt; "EOF"
<literal># Début de /etc/sysconfig/console

UNICODE="1"
KEYMAP="bg_bds-utf8"
FONT="LatArCyrHeb-16"

# Fin de /etc/sysconfig/console</literal>
EOF</userinput></screen>
    </listitem>

    <listitem>
      <para>Du fait de l'utilisation d'une police 512-glyph LatArCyrHeb-16 dans
      l'exemple précédent, les couleurs brillantes ne sont plus disponibles
      sur la console Linux à moins qu'un framebuffer soit utilisé. Si vous
      voulez avoir les couleurs brillantes sans framebuffer et que vous pouvez
     vivre sans caractère n'appartenant pas à votre langue, il est encore
      possible d'utiliser une police 256-glyph spécifique à votre langue,
      comme illustré ci-dessous&nbsp;:</para>

<screen role="nodump"><userinput>cat &gt; /etc/sysconfig/console &lt;&lt; "EOF"
<literal># Début de /etc/sysconfig/console

UNICODE="1"
KEYMAP="bg_bds-utf8"
FONT="cyr-sun16"

# Fin de /etc/sysconfig/console</literal>
EOF</userinput></screen>
    </listitem>

    <listitem>
      <para>L'exemple suivant illustre l'auto-conversion de la disposition de clavier
      d'utf-85 vers UTF-8 et l'activation des touches mortes en mode Unicode&nbsp;:</para>

<screen role="nodump"><userinput>cat &gt; /etc/sysconfig/console &lt;&lt; "EOF"
<literal># Début de /etc/sysconfig/console

UNICODE="1"
KEYMAP="de-latin1"
KEYMAP_CORRECTIONS="euro2"
LEGACY_CHARSET="iso-8859-15"
FONT="LatArCyrHeb-16 -m 8859-15"

# Fin de /etc/sysconfig/console</literal>
EOF</userinput></screen>
    </listitem>

    <listitem>
      <para>Certaines dispositions de codage ont des touches mortes (c-à-d que
      les touches qui ne produisent pas un caractère en elles-mêmes, mais mettent
       un accent sur le caractère produit par la touche suivante) ou définissent
      des règles de comportement (comme&nbsp;: <quote>Appuyez sur Ctrl+. A E pour
      obtenir &AElig;</quote> dans la disposition du clavier par défaut).
      Linux-&linux-version; n'interprète correctement les touches mortes et les règles de
      composition que quand les caractères source qui seront composés ensembles
      sont multi-octet. Ce défaut n'affecte pas les dispositions de clavier pour les
      langues européennes, car il y a des accents ajoutés à des caractères
      ASCII non accentués, ou deux caractères ASCII sont composés ensemble.
      Néanmoins en mode UTF-8, c'est un problème, comme pour la langue grecque,
      où on a parfois besoin de mettre un accent sur la lettre
      <quote>alpha</quote>.
      La solution consiste soit à éviter d'utiliser UTF-8, soit à installer le système de fenêtrage X
      qui n'a pas cette limitation dans sa gestion de l'entrée.</para>
    </listitem>

    <listitem>
      <para>Pour le chinois, le Japonais, le Coréen et certaines autres langues,
      la console Linux ne peut pas être configurée pour afficher les caractères
      nécessaires. Les utilisateurs qui ont besoin de telles langues devraient
      installer le système de fenêtrage X, dont les polices couvrent la plage de
      caractères nécessaire et qui a la bonne méthode d'entrée (par exemple
      SCIM prend en charge une large variété de langues).</para>
    </listitem>

  </itemizedlist>

  <!-- Added because folks keep posting their console file with X questions
  to blfs-support list -->
  <note>
    <para>Le fichier <filename>/etc/sysconfig/console</filename> ne contrôle
     que la localisation de la console texte de Linux. Cela n'a rien à voir
     avec le bon paramétrage du type de clavier et des polices du terminal dans
    le système de fenêtrage X, avec les sessions ssh ou une console série. Dans de
    telles situations, les limitations mentionnées dans les deux derniers points
    de la liste ci-dessus ne s'appliquent pas.</para>
  </note>

  </sect2>

  <sect2 id="ch-scripts-createfiles">
    <title>Créer des fichiers au démarrage</title>
  
    <indexterm zone="ch-scripts-createfiles">
      <primary sortas="d-createfiles">File creation at boot</primary>
      <secondary>configuring</secondary>
    </indexterm>
  
    <para>Parfois, on veut créer des fichiers lors du démarrage. Par exemple,
    vous pouvez souhaiter un répertoire <filename class="directory">/tmp/.ICE-unix</filename>.
    Vous pouvez le faire en modifiant une entrée du script de configuration
    <filename>/etc/sysconfig/createfiles</filename>. Le format ce ce fichier est
    indiqué dans les commentaires du fichier de configuration par défaut.</para>
  </sect2>

  <sect2 id="ch-scripts-sysklogd">
    <title>Configurer le script sysklogd</title>

  <indexterm zone="ch-scripts-sysklogd">
    <primary sortas="d-sysklogd">sysklogd</primary>
    <secondary>configuration</secondary>
  </indexterm>

  <para>Le script <filename>sysklogd</filename> invoque le
  programme <command>syslogd</command> faisant partie de l'initialisation par System V. L'option 
  <parameter>-m 0</parameter> désactive la marque
  périodique que <command>syslogd</command> écrit par défaut dans les fichiers
  journaux toutes les 20 minutes. Si vous voulez activer cet horodatage,
  éditez <filename>/etc/sysconfig/rc.site</filename> et définissez
  la variable SYSKLOGD_PARMS à la valeur désirée. Par exemple, pour supprimer
  tous les paramètres, réglez la variable à la valeur null&nbsp;:</para>

<screen role="nodump">SYSKLOGD_PARMS=</screen>

  <para>Voir <userinput>man syslogd</userinput> pour plus d'options.</para>
  </sect2>

  <sect2 id="ch-scripts-site">
    <title>Le fichier rc.site</title>

  <indexterm zone="ch-scripts-site">
    <primary sortas="a-rc.site">rc.site</primary>
  </indexterm>

  <para>Le fichier facultatif <filename>/etc/sysconfig/rc.site</filename>
  contient les paramètres réglés automatiquement pour chaque script de démarrage de System V.
  Il peut aussi contrôler les valeurs des fichiers <filename>hostname</filename>,
  <filename>console</filename> et <filename>clock</filename> du répertoire
  <filename class='directory'>/etc/sysconfig/</filename>. Si les variables
  associées se trouvent à la fois dans ces fichiers distincts et dans
  <filename>rc.site</filename>, les valeurs des fichiers spécifiques ont la préséance.</para>

  <para><filename>rc.site</filename> contient aussi des paramètres pour
  personnaliser d'autres aspects du processus de démarrage. Le réglage de la
  variable IPROMPT permettra un lancement sélectif des scripts de démarrage.
  D'autres options sont décrites dans les commentaires du fichier. La version
  par défaut du fichier est ci-dessous&nbsp;:</para>

  <!-- Use role to fix a pdf generation problem -->
  <screen role="auto">&site;</screen>

  <sect3>
    <title>Personnaliser les scripts de démarrage et d'extinction</title>

    <para>Les scripts de démarrage LFS démarrent et arrêtent un système d'une
    façon très efficace, mais vous pouvez faire quelques bidouillages dans le
    fichier rc.site pour améliorer encore davantage la vitesse et ajuster les
    messages selon vos préférences. Pour cela, ajustez les paramètres du fichier
    <filename>/etc/sysconfig/rc.site</filename> ci-dessus.</para>

    <itemizedlist>

    <listitem><para>Pendant le script de démarrage <filename>udev</filename>,
    un appel à <command>udev settle</command> demande du temps pour s'achever.
    Ce temps peut être ou pas nécessaire pour des périphériques présents dans
    votre système. Si vous n'avez que des partitions simples et une seule carte
    ethernet, le processus de démarrage n'aura probablement pas besoin d'attendre
    cette commande. Pour la sauter, définissez la variable OMIT_UDEV_SETTLE=y.</para></listitem>

    <listitem><para>Le script de démarrage <filename>udev_retry</filename> lance
    aussi par défaut <command>udev settle</command>. Cette commande n'est nécessaire
    par défaut que si le répertoire <filename class='directory'>/var</filename>
     est monté séparément. Ceci car la vérification a besoin du fichier
    <filename>/var/lib/hwclock/adjtime</filename>.  D'autres personnalisations 
    peuvent nécessiter d'attendre qu'udev se termine mais dans beaucoup d'installations,
    ce n'est pas nécessaire. Sautez la commande en définissant la variable 
    OMIT_UDEV_RETRY_SETTLE=y.
    </para></listitem>

    <listitem><para>Par défaut, les vérifications des systèmes de fichiers sont
    sans message. Cela peut être vu comme un délai pendant le processus de démarrage.
    Pour activer la sortie de <command>fsck</command>, définissez la variable VERBOSE_FSCK=y.
    </para></listitem>

    <listitem><para>Lors du redémarrage, il se peut que vous vouliez sauter 
    la vérification du système de fichiers,
    <command>fsck</command>, complètement.  Pour cela, soit créez le fichier
    <filename>/fastboot</filename>, soit redémarrez le système avec la
    commande <command>/sbin/shutdown -f -r now</command>. Inversement, vous
    pouvez forcer la vérification de tous les systèmes de fichiers en créant
    <filename>/forcefsck</filename> ou en lançant <command>shutdown</command> 
    avec le paramètre <parameter>-F</parameter> plutôt que <parameter>-f</parameter>.  
    </para>
    
    <para>La définition de la variable FASTBOOT=y désactivera <command>fsck</command>
    lors du processus de démarrage jusqu'à ce qu'il soit supprimé. Ce n'est pas 
    recommandé de façon permanente.</para></listitem>

    <listitem><para>En principe, tous les fichiers du répertoire <filename
    class='directory'>/tmp</filename> sont effacés au moment du démarrage.
    Selon le nombre de fichiers ou de répertoires présents, cela peut provoquer
    un délai important dans le processus de démarrage. Pour sauter la suppression
    de ces fichiers, définissez la
    variable SKIPTMPCLEAN=y.</para></listitem>

    <listitem><para>Lors de l'extinction, le programme <command>init</command>
    envoie un signal TERM à chaque programme qu'il a démarré (comme agetty), il
    attend un moment de définition (par défaut, 3 secondes), et il envoie à
    chaque processus un signal KILL puis attend de nouveau. Ce processus se
    répète dans le script <command>sendsignals</command> pour tous les processus
    non terminés par leurs propres scripts.  Le délai de <command>init</command>
    peut être défini en passant un paramètre. Par
    exemple, pour supprimer le délai dans <command>init</command>, passez le
    paramètre -t0 lors de l'extinction ou du redémarrage (comme
    <command>/sbin/shutdown
    -t0 -r now</command>).  Le délai du script <command>sendsignals</command>
    peut être sauté en définissant le paramètre
    KILLDELAY=0.</para></listitem>

    </itemizedlist>

  </sect3>
  </sect2>
</sect1>
