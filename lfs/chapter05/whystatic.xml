<sect1 id="ch05-whystatic">
<title>Pourquoi utiliser une édition de lien statique ?</title> 
<?dbhtml filename="whystatic.html" dir="chapter05"?> 
 
<para>La plupart des programmes réalisent, en dehors de leur fonctions
spécifiques, un certain nombre d'opérations communes et triviales, telles que
allouer de la mémoire, rechercher des répertoires, ouvrir et fermer des
fichiers, les lire et les écrire, gérer des mots, chercher des modèles, calculer
et ainsi de suite. Au lieu d'obliger chaque programme à réinventer la roue, le
système GNU apporte toutes les fonctions de base dans des bibliothèques. La
bibliothèque principale est <filename>glibc</filename>. Pour avoir une idée de
ce qu'elle contient, jetez un oeil sur <filename>glibc/index.html</filename>
quelque part sur votre système hôte.</para>

<para>
Il existe deux manières d'attacher les fonctions des librairies aux programmes
qui les utilisent : statiquement ou dynamiquement.
Quand un programme est lié statiquement, le code des fonctions utilisées est
inclus dans l'exécutable, le résultat est un programme assez volumineux.
Quand un programme est lié dynamiquement, il n'inclus qu'une référence pour le
programme d'attachement, le nom de la bibliothèque etcelui de la fonction,
ceci produit un exécutable beaucoup plus petit. Sous certaines circonstances,
cet exécutable a le désavantage d'être quelque peu plus lent que la version liée
statiquement car les liens au lancement prennent un peu de temps. Il doit
cependant être noté que sous des circonstances normales avec un matériel actuel,
un exécutable lié dynamiquement sera plus rapide que sa version liée
statiquement car les fonctions des bibliothèques appelées appelées par
l'exécutable lié dynamiquement a une bonne chance d'être déjà chargé dans la
mémoire de votre système.</para>

<para>
En contrepartie de ce léger inconvénient, l'attachement dynamique a deux 
avantages majeurs par rapport à l'attachement statique. Premièrement vous
n'avez besoin qued'une seule copie du code de la bibliothèque sur votre disque,
plutôt que d'avoir de multiples copies du même code incluses dans un grand
nombre de programmes -- ce qui préserve l'espace disque. Deuxièmement, 
lorsque plusieurs programmes utilisent la même fonction de bibliothèque en même temps, une seule copie du code de cette fonction sera nécéssaire en mémoire 
-- ce qui préserve l'espace mémoire.
</para>

<para>
De nos jours, sauver quelques mégabytes d'espace ne semble pas grand chose, 
mais, il y a bien des lunes, lorsque les disques étaient mesurés en
mégabytes et la mémoire en kilobytes, une telle sauvagarde était primordiale.
Il s'agissait d'être capable de conserver plusieurs programmes en mémoire en 
même temps et de faire tenir un système Unix complet sur peu de volume 
disques.
</para>

<para>
Une troisième avantage, mineur celui là, de l'attachement dynamique est que 
lorsqu'une bibliothèque voit un bogue réparer ou est améliorée, vous devez
seulement recompiler la bibliothèque elle même, sans avoir à recompiler tous
les programmes qui utilisent la fonction améliorée.
</para>
 
<para>
En résumé, nous pouvons dire que l'attachement dynamique troc de la vitesse
d'éxécution contre de l'espace mémoire et disque ainsi que du temps de 
re-compilation.
</para>

<para>Mais si l'édition de liens dynamiques sauve tant de place disque, pourquoi
choisissons-nous de lier les deux premiers packages de ce chapitre de façon
statique? La raison est que nous les rendons indépendants des bibliothèques
présentes sur votre système hôte. L'avantage est que, si vous êtes pressé, vous pouvez passer
le deuxième tour avec GCC et Binutils et utiliser seulement les versions
statiques pour compiler le reste de ce chapitre et les quelques premiers
packages du suivant. Comme ,dans le chapitre suivant, nous serons entré dans la
prison chroot de la partition LFS et que la Glibc de votre système hôte ne sera
plus disponible, les programmes provenant de GCC et Binutils doivent être
indépendants, c'est-à-dire liés statiquement. Nénamoins, nous vous recommendons
forcément de ne <emphasis>pas</emphasis> oublier la deuxième passe.</para>

</sect1>

