<sect1 id="ch05-toolchaintechnotes">
<title>Notes techniques sur l'atelier d'outils</title>
<?dbhtml filename="toolchaintechnotes.html" dir="chapter05"?>

<para>Cette section essaie d'expliquer quelques détails techniques et logiques
concernant la méthode de construction. Il n'est pas essentiel de comprendre tout
immédiatement. La plupart des explications prendra du sens une fois que vous
aurez réalisé une construction complète. Vous pouvez aussi vous y référer plus
tard.</para>

<para>Le but global du <xref linkend="chapter05"/> est d'apporter un
environnement sain et temporaire dans lequel nous pouvons entrer avec chroot et
à partir duquel nous pouvons constuire un système LFS propre, sans problème lors
du <xref linkend="chapter06"/>. Pendant ce temps, nous essayons de nous séparer
du système hôte autant que possible en créant un atelier (ensemble d'outils) qui
se suffit. Il doit être noté que le processus de construction a été construit
d'une telle façon que les risques sont minimisés pour les nouveaux lecteurs et
qu'il apporte une valeur éducationnelle maximum en même temps. En d'autres
termes, des techniques plus avancées pourraient être utilisées pour construire
le système.</para>

<important>
<para>Avant de continuer, vous devez réellement savoir le nom de votre
plateforme actuel, souvent aussi appelé le <emphasis>triplé clible</emphasis>.
Pour beaucoup de personnes, ce triplé sera, par exemple&nbsp;:
<emphasis>i686-pc-linux-gnu</emphasis>. Une façon simple de déterminer votre
triplé cible est de lancer le script <filename>config.guess</filename> venant
avec le source de nombreux packages. Déballez les sources de Binutils, lancez
le script&nbsp; <userinput>./config.guess</userinput> et notez la sortie.</para>

<para>Vous aurez aussi besoin de connaître le nom de l'<emphasis>éditeur de
liens dynamiques</emphasis> de votre plateforme, aussi appelé <emphasis>chargeur
dynamique</emphasis>, à ne pas confondre avec l'éditeur de liens standard
<emphasis>ld</emphasis> faisant partie de Binutils. L'éditeur de liens dynamique
est fourni par Glibc et a pour but de trouver et charger les bibliothèques
dynamiques nécessaires à un programme, préparant l'exécution de ce programme et
le lançant. Pour la plupart des personnes, le nom de l'éditeur de liens
dynamique ser <emphasis>ld-linux.so.2</emphasis>. Sur des plateformes moins
communes, le nom pourrait être <emphasis>ld.so.1</emphasis> et pour les
nouvelles plateformes 64 bit, cela pourrait être complètement différent. Vous
devez être capable de déterminer le nom de l'éditeur de liens dynamiques de
votre plateforme en regardant dans le répertoire
<filename class="directory">/lib</filename> de votre système hôte. Vous pouvez
inspecter un binaire quelconque sur votre système hôte en lançant&nbsp;
<userinput>'readelf -l &lt;name of binary&gt; | grep interpreter'</userinput>
et en notant la sortie. La référence concernant toutes les plateformes est dans
le fichier <filename>shlib-versions</filename> à la racine du répertoires des
sources de Glibc.</para>
</important>

<para>Quelques points techniques clés sur la façon dont fonctionne la méthode de
construction au <xref linkend="chapter05"/>&nbsp;:</para>

<itemizedlist>
<listitem><para>Similaire en principe à la cross-compilation où des outils
installés avec le même préfixe fonctionnent en coopération et donc utilisent un
peu de "magie" GNU.</para></listitem>

<listitem><para>Des manipulations attentionnées du chemin de recherche des
bibliothèques de l'éditeur de liens standard pour vous assurer que les
programmes sont liés uniquement avec les bibliothèques que nous avons choisi.
</para></listitem>

<listitem><para>Des manipulations attentionnées du fichier
<emphasis>specs</emphasis> de <userinput>gcc</userinput> pour indiquer au
compilateur où l'éditeur de liens dynamique cible sera utilisé.</para></listitem>
</itemizedlist>

<para>Binutils est installé en premier parce que GCC et Glibc réalisent des
tests de fonctionnalités sur l'assembleur et l'éditeur de liens durant leur
lancement respectif de <userinput>./configure</userinput> pour déterminer les
fonctionnalités (dés)activer pour le logiciel. Ceci est plus important que ce
que vous pouvez imaginer. Un GCC ou Glibc mal configuré peut résulter en un
ensemble d'outils subtilement bogué où l'impact d'une telle erreur n'apparaîtra
qu'à la fin de la construction de la distribution complète. Heureusement, un
échec de le suite de tests nous alertera habituellement avant que trop de temps
ne se soit passé.</para>

<para>Binutils installe son assembleur et son éditeur de liens en deux
emplacements, <filename class="directory">/tools/bin</filename> et
<filename class="directory">/tools/$TARGET_TRIPLET/bin</filename>. En fait, les
outils dans un emplacement sont des liens vers les autres. Une importante
facette de l'éditeur de liens réside dans l'ordre de son chemin de recherche des
bibliothèques. Des informations détaillées sont disponibles sur
<userinput>ld</userinput> en lui passant l'option
<emphasis>--verbose</emphasis>. Par exemple,
<userinput>'ld --verbose | grep SEARCH'</userinput> vous montrera le chemin
actuel et leur ordre. Vous pouvez voir quels fichiers sont actuellement liés par
<userinput>ld</userinput> en compilant un programme et en ajoutant l'option
<emphasis>--verbose</emphasis> switch. Par exemple,
<userinput>'gcc dummy.c -Wl,--verbose 2>&amp;1 | grep succeeded'</userinput>
vous affichera tous les fichiers ouverts avec succès lors du liens.</para>

<para>Le prochain package installé est GCC et, lors de exécution de
<userinput>./configure</userinput>, vous verrez par exemple&nbsp;:</para>

<blockquote><screen>checking what assembler to use... /tools/i686-pc-linux-gnu/bin/as
checking what linker to use... /tools/i686-pc-linux-gnu/bin/ld</screen></blockquote>

<para>Ceci est important pour les raisons mentionnées ci-dessus. Cela démontre
aussi que le script configure de GCC ne cherche pas dans les répertoires $PATH
pour trouver les outils à utiliser. Néanmoins, lors des opérations sur
<userinput>gcc</userinput> lui-même, les mêmes chemins de recherche ne sont pas
nécessairement utilisés. Vous pouvez trouver quel éditeur de liens standard
<userinput>gcc</userinput> va utiliser en lançant&nbsp;:
<userinput>'gcc -print-prog-name=ld'</userinput>.
Des informations détaillées peuvent être obtenues à partir de
<userinput>gcc</userinput> en lui passant l'option <emphasis>-v</emphasis> lors
de la compilation d'un programme. Par exemple&nbsp;:
<userinput>'gcc -v dummy.c'</userinput> vous affichera des informations sur le
préprocesseur, les étapes de compilation et d'assemblage en incluant les chemins
de recherche des en-têtes de <userinput>gcc</userinput> ainsi que leur ordre.
</para>
 
<para>Le prochaine package installé est Glibc. Les considérations les plus
importantes lors de la compilation de Glibc sont le compilateur, les outils
Le compilateur n'est généralement pas un problème car Glibc utilise toujours le
<userinput>gcc</userinput> trouvé dans un répertoire de $PATH. Les outils
binaires et les en-têtes du noyau peuvent poser plus de problèmes. Donc, nous ne
prenons aucun risque et utilisons les options disponibles par configure. Après
le lancement de <userinput>./configure</userinput>, vous pouvez vérifier le
contenu du fichier <filename>config.make</filename> du répertoire
<filename class="directory">glibc-build</filename> pour tous les détails
importantes. Vous noterez des éléments intéressants comme l'utilisation de
<userinput>CC="gcc -B/tools/bin/"</userinput> pour contrôler quels outils
binaires sont utilisés, mais aussi l'utilisation des options
<emphasis>-nostdinc</emphasis> et <emphasis>-isystem</emphasis> pour contrôler
le chemin de recherche des fichiers include du compilateur. Ces éléments aident
à souligner un aspect important du package Glibc&nbsp;: il est tout à fait
suffisant en terme de machinerie de construction et ne repose pas en général sur
les valeurs par défaut de l'ensemble des outils.</para>

<para>Après l'installation de Glibc, nous faisons quelques ajustements pour nous
assurer que la recherche et l'édition de liens prennent place dans notre préfixe
<filename>/tools</filename>. Nous installons un <userinput>ld</userinput>
personnalisé, disposant d'un chemin de recherche en dur vers
<filename class="directory">/tools/lib</filename>. Ensuite, nous modifions le
fichier specs de <userinput>gcc</userinput> pour pointer vers notre éditeur de
liens dynamique dans <filename class="directory">/tools/lib</filename>. Cette
dernière étape est <emphasis>vitale</emphasis> pour tout le processus. Comme
mentionné ci-dessus, un chemin codé en dur vers un éditeur de liens dynamiques
est émbarqué dans chaque exécutable ELF. Vous pouvez l'inspecter en
lançant&nbsp;:
<userinput>'readelf -l &lt;name of binary&gt; | grep interpreter'</userinput>.
En modifiant le fichier specs de <userinput>gcc</userinput>nous nous assurons
que tout programme compilé ici (et jusqu'à la fin du <xref
linkend="chapter05"/>) utilisera notre nouvel éditeur de liens compris dans
<filename class="directory">/tools/lib</filename>.</para>

<para>Le besoin d'utiliser le nouvel éditeur de liens dynamiques est aussi la
raison pour laquelle nous appliquons le correctif Specs lors de la deuxième
passe pour GCC. Echouer en ce faisant résultera en des programmes GCC comprenant
le nom de l'éditeur de liens du répertoire <filename
class="directory">/lib</filename> sur le système hôte, ce qui ferait échouer
notre but de s'éloigner de l'hôte.</para>

<para>Lors de la deuxième passe pour Binutils, nous sommes capable d'utiliser
l'option configure <emphasis>--with-lib-path</emphasis> pour contrôler le chemin
de recherche de la bibliothèque de <userinput>ld</userinput>. A partir de ce
moment, notre atelier principal d'outils se suffit à lui-même. Le reste des
packages du <xref linkend="chapter05"/> sera construit avec le répertoire
<filename class="directory">/tools</filename>.</para>

<para>En entrant dans l'environnement chroot <xref linkend="chapter06"/>, le
premier package majeur que nous installons est Glibc, dûe à sa nature auto
suffisante. Une fois que cette Glibc est installée dans
<filename class="directory">/usr</filename>, nous réalisons un rapide changement
dans les paramètres par défaut de l'atelier des outils, puis procédons à la
construction du reste de la cible <xref linkend="chapter06"/>.</para>

<sect2>
<title>Notes sur l'édition de liens statiques</title>

<para>La plupart des programmes doivent réaliser, en plus de leur tâches
spécifiques, beaucoup d'opérations communes et quelques fois triviales. Cela
inclut l'allocation de mémoire, la recherche dans des répertoires, la lecture et
l'écriture de fichiers, la gestion de chaînes de caractères, la correspondance
de modèles, l'arithmétique et bien d'autres tâches. Au lieu d'obliger tout
programme de réinventer la roue, le système GNU apport toutes les fonctions de
base dans des bibliothèques toutes prêtes. La bibliothèque principale sur tout
système Linux est <emphasis>Glibc</emphasis>.</para>

<para>Il existe principalement deux façons de lier les fonctions d'une
bibliothèque à un programme qui les utilise&nbsp;: statiquement ou
dynamiquement. Quand un programme est lié statiquement, le code des fonctions
utilisées est inclut dans l'exécutable, générant ainsi un programme lourd.
Lorsqu'un programme est lié dynamiquement, ce qui est inclus est une référence
de l'éditeur de liens, du nom de la bibliothèque et du nom de la fonction,
résultant en un exécutable bien plus petit. (Une troisième façon est d'utiliser
l'interface de programmation de l'éditeur de liens. Voir la page man
<emphasis>dlopen</emphasis> pour plus d'informations.)</para>

<para>L'édition de liens dynamiques est réalisée par défaut sur Linux et a trois
avantages majeurs sur l'édition de liens statiques. Tout d'abord, vous n'avez
besoin que d'une copie du code de la bibliothèque exécutable sur votre disque
dur au lieu d'avoir plusieurs copies du même code inclut dans un grand nombre de
programmes, donc en sauvant de l'espace disque. Deuxièmement, quand plusieurs
programmes utilisent la même fonction d'une bibliothèque en même temps, seule
une copie de la fonction de la bibliothèque est requis dans le coeur, ce qui
sauve de l'espace mémoire. Enfin, quand une bibliothèque de fonction est
déboguée ou améliorée, vous n'avez besoin que de recompiler cette bibliothèque,
au lieu d'avoir à recompiler tous les programmes utilisant la fonction
améliorée.</para>

<para>Si l'édition de liens a plusieurs avantages, alors pourquoi lier
statiquement les deux premiers packages de ce chapitre&nbsp;? Il existe trois
raisons&nbsp;: historique, éducationnel et technique. Historique parce que les
anciennes versions de LFS liaient statiquement tous les programmes de ce
chapitre. Educationnel parce que connaître la différence est utile. Technique
parce que nous gagnons un élément d'indépendance de lhôte. Néanmois, il est bon
de rappeller qu'une construction complère et réussie de LFS peut toujours
s'achever lorsque les deux premiers packages sont liés dynamiquement.</para>

</sect2>

</sect1>

