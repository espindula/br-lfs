# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-12-24 16:18+0000\n"
"PO-Revision-Date: 2020-09-02 08:10+0000\n"
"Last-Translator: Xi Ruoyao <xry111@mengyan1223.wang>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Pootle 2.8\n"
"X-POOTLE-MTIME: 1599034210.382167\n"

#. type: Content of: <sect1><title>
#: lfs-en/chapter08/pkgmgt.xml:11
msgid "Package Management"
msgstr "软件包管理"

#. type: Content of: <sect1><para>
#: lfs-en/chapter08/pkgmgt.xml:13
#, fuzzy
#| msgid ""
#| "Package Management is an often requested addition to the LFS Book. A "
#| "Package Manager allows tracking the installation of files making it easy "
#| "to remove and upgrade packages. As well as the binary and library files, "
#| "a package manager will handle the installation of configuration files.  "
#| "Before you begin to wonder, NO&mdash;this section will not talk about nor "
#| "recommend any particular package manager. What it provides is a roundup "
#| "of the more popular techniques and how they work. The perfect package "
#| "manager for you may be among these techniques or may be a combination of "
#| "two or more of these techniques. This section briefly mentions issues "
#| "that may arise when upgrading packages."
msgid ""
"Package Management is an often requested addition to the LFS Book. A Package "
"Manager tracks the installation of files, making it easier to remove and "
"upgrade packages. A good package manager will also handle the configuration "
"files specially to keep the user configuration when the package is "
"reinstalled or upgraded.  Before you begin to wonder, NO&mdash;this section "
"will not talk about nor recommend any particular package manager. What it "
"does provide is a roundup of the more popular techniques and how they work. "
"The perfect package manager for you may be among these techniques, or it may "
"be a combination of two or more of these techniques. This section briefly "
"mentions issues that may arise when upgrading packages."
msgstr ""
"经常有人请求将软件包管理加入 LFS 手册。包管理器可以跟踪文件的安装过程，简化移"
"除或升级软件包的工作。如同处理二进制程序和库文件一样，包管理器也会处理配置文"
"件的安装过程。在您开始想入非非前，不 —— 本节不会讨论或者推荐任何一个特定的包"
"管理器。本节对软件包管理的流行技术及其工作原理进行综述。对您来说，完美的包管"
"理器可能是其中的某个技术，也可能是几个技术的结合。本节还会简要介绍在升级软件"
"包时可能遇到的问题。"

#. type: Content of: <sect1><para>
#: lfs-en/chapter08/pkgmgt.xml:25
msgid ""
"Some reasons why no package manager is mentioned in LFS or BLFS include:"
msgstr "LFS 或 BLFS 不介绍任何包管理器的原因包括："

#. type: Content of: <sect1><itemizedlist><listitem><para>
#: lfs-en/chapter08/pkgmgt.xml:30
msgid ""
"Dealing with package management takes the focus away from the goals of these "
"books&mdash;teaching how a Linux system is built."
msgstr "处理软件包管理会偏离这两本手册的目标 —— 讲述如何构建 Linux 系统。"

#. type: Content of: <sect1><itemizedlist><listitem><para>
#: lfs-en/chapter08/pkgmgt.xml:35
#, fuzzy
#| msgid ""
#| "There are multiple solutions for package management, each having its "
#| "strengths and drawbacks.  Including one that satisfies all audiences is "
#| "difficult."
msgid ""
"There are multiple solutions for package management, each having its "
"strengths and drawbacks.  Finding one solution that satisfies all audiences "
"is difficult."
msgstr ""
"存在多种软件包管理的解决方案，它们各有优缺点。很难找到一种让所有读者满意的方"
"案。"

#. type: Content of: <sect1><para>
#: lfs-en/chapter08/pkgmgt.xml:41
#, fuzzy
#| msgid ""
#| "There are some hints written on the topic of package management. Visit "
#| "the <ulink url=\"&hints-root;\">Hints Project</ulink> and see if one of "
#| "them fits your need."
msgid ""
"There are some hints written on the topic of package management. Visit the "
"<ulink url=\"&hints-root;\">Hints Project</ulink> and see if one of them "
"fits your needs."
msgstr ""
"已经有人写了一些关于软件包管理这一主题的短文。您可以访问 <ulink url=\"&hints-"
"root;\">Hints Project</ulink> 并看一看是否有符合您的需求的方案。"

#. type: Content of: <sect1><sect2><title>
#: lfs-en/chapter08/pkgmgt.xml:46
msgid "Upgrade Issues"
msgstr "升级问题"

#. type: Content of: <sect1><sect2><para>
#: lfs-en/chapter08/pkgmgt.xml:48
msgid ""
"A Package Manager makes it easy to upgrade to newer versions when they are "
"released. Generally the instructions in the LFS and BLFS books can be used "
"to upgrade to the newer versions. Here are some points that you should be "
"aware of when upgrading packages, especially on a running system."
msgstr ""
"使用包管理器可以在软件包新版本发布后容易地完成升级。一般来说，使用 LFS 或者 "
"BLFS 手册给出的构建方法即可升级软件包。下面是您在升级时必须注意的重点，特别是"
"升级正在运行的系统时。"

#. type: Content of: <sect1><sect2><itemizedlist><listitem><para>
#: lfs-en/chapter08/pkgmgt.xml:55
msgid ""
"If the Linux kernel needs to be upgraded (for example, from 5.10.17 to "
"5.10.18 or 5.11.1), nothing else needs to be rebuilt.  The system will keep "
"working fine thanks to the well-defined interface between the kernel and "
"userspace.  Specifically, Linux API headers need not be (and should not be, "
"see the next item) upgraded along with the kernel.  You will merely need to "
"reboot your system to use the upgraded kernel."
msgstr ""

#. type: Content of: <sect1><sect2><itemizedlist><listitem><para>
#: lfs-en/chapter08/pkgmgt.xml:65
#, fuzzy
#| msgid ""
#| "If Glibc needs to be upgraded to a newer version, (e.g.  from glibc-2.31 "
#| "to glibc-2.32), it is safer to rebuild LFS.  Though you <emphasis>may</"
#| "emphasis> be able to rebuild all the packages in their dependency order, "
#| "we do not recommend it."
msgid ""
"If the Linux API headers or Glibc need to be upgraded to a newer version, (e."
"g., from Glibc-2.31 to Glibc-2.32), it is safer to rebuild LFS.  Though you "
"<emphasis>may</emphasis> be able to rebuild all the packages in their "
"dependency order, we do not recommend it."
msgstr ""
"如果需要升级 Glibc (例如从 Glibc-2.31 升级到 Glibc-2.32)，最安全的方法是重新"
"构建 LFS。尽管您<emphasis>或许</emphasis>能按依赖顺序重新构建所有软件包，但我"
"们不推荐这样做。"

#. type: Content of: <sect1><sect2><itemizedlist><listitem><para>
#: lfs-en/chapter08/pkgmgt.xml:72
#, fuzzy
#| msgid ""
#| "If a package containing a shared library is updated, and if the name of "
#| "the library changes, then any the packages dynamically linked to the "
#| "library need to be recompiled in order to link against the newer "
#| "library.  (Note that there is no correlation between the package version "
#| "and the name of the library.) For example, consider a package foo-1.2.3 "
#| "that installs a shared library with name <filename "
#| "class='libraryfile'>libfoo.so.1</filename>. If you upgrade the package to "
#| "a newer version foo-1.2.4 that installs a shared library with name "
#| "<filename class='libraryfile'>libfoo.so.2</filename>. In this case, any "
#| "packages that are dynamically linked to <filename "
#| "class='libraryfile'>libfoo.so.1</filename> need to be recompiled to link "
#| "against <filename class='libraryfile'>libfoo.so.2</filename> in order to "
#| "use the new library version. You should not remove the previous libraries "
#| "unless all the dependent packages are recompiled."
msgid ""
"If a package containing a shared library is updated, and if the name of the "
"library changes, then any packages dynamically linked to the library must be "
"recompiled, to link against the newer library.  (Note that there is no "
"correlation between the package version and the name of the library.) For "
"example, consider a package foo-1.2.3 that installs a shared library with "
"the name <filename class='libraryfile'>libfoo.so.1</filename>. Suppose you "
"upgrade the package to a newer version foo-1.2.4 that installs a shared "
"library with the name <filename class='libraryfile'>libfoo.so.2</filename>. "
"In this case, any packages that are dynamically linked to <filename "
"class='libraryfile'>libfoo.so.1</filename> need to be recompiled to link "
"against <filename class='libraryfile'>libfoo.so.2</filename> in order to use "
"the new library version. You should not remove the old libraries until all "
"the dependent packages have been recompiled."
msgstr ""
"如果更新了一个包含共享库的软件包，而且共享库的名称发生改变，那么所有动态链接"
"到这个库的软件包都需要重新编译，以链接到新版本的库。(注意软件包的版本和共享库"
"的名称没有关系。) 例如，考虑一个软件包 foo-1.2.3 安装了名为 <filename "
"class='libraryfile'>libfoo.so.1</filename> 的共享库，如果您把该软件包升级到了"
"新版本 foo-1.2.4，它安装了名为 <filename class='libraryfile'>libfoo.so.2</"
"filename> 的共享库。那么，所有链接到 <filename class='libraryfile'>libfoo."
"so.1</filename> 的软件包都要重新编译以链接到 <filename "
"class='libraryfile'>libfoo.so.2</filename>。注意，您不能删除旧版本的库，直到"
"将所有依赖它的软件包都重新编译完成。"

#. type: Content of: <sect1><sect2><itemizedlist><listitem><para>
#: lfs-en/chapter08/pkgmgt.xml:88
msgid ""
"If a package containing a shared library is updated, and the name of the "
"library doesn't change, but the version number of the library <emphasis "
"role=\"bold\">file</emphasis> decreases (for example, the library is still "
"named <filename class='libraryfile'>libfoo.so.1</filename>, but the name of "
"the library file is changed from <filename class='libraryfile'>libfoo."
"so.1.25</filename> to <filename class='libraryfile'>libfoo.so.1.24</"
"filename>), you should remove the library file from the previously installed "
"version (<filename class='libraryfile'>libfoo.so.1.25</filename> in this "
"case).  Otherwise, a <command>ldconfig</command> command (invoked by "
"yourself from the command line, or by the installation of some package) will "
"reset the symlink <filename class='libraryfile'>libfoo.so.1</filename> to "
"point to the old library file because it seems to be a <quote>newer</quote> "
"version; its version number is larger.  This situation may arise if you have "
"to downgrade a package, or if the authors change the versioning scheme for "
"library files."
msgstr ""

#. type: Content of: <sect1><sect2><itemizedlist><listitem><para>
#: lfs-en/chapter08/pkgmgt.xml:106
msgid ""
"If a package containing a shared library is updated, and the name of the "
"library doesn't change, but a severe issue (especially, a security "
"vulnerability) is fixed, all running programs linked to the shared library "
"should be restarted.  The following command, run as <systemitem "
"class=\"username\">root</systemitem> after the update is complete, will list "
"which processes are using the old versions of those libraries (replace "
"<replaceable>libfoo</replaceable> with the name of the library):"
msgstr ""

#. type: Content of: <sect1><sect2><itemizedlist><listitem><screen>
#: lfs-en/chapter08/pkgmgt.xml:115
#, no-wrap
msgid ""
"<userinput>grep -l  -e '<replaceable>libfoo</replaceable>.*deleted' /proc/*/maps |\n"
"   tr -cd 0-9\\\\n | xargs -r ps u</userinput>"
msgstr ""

#. type: Content of: <sect1><sect2><itemizedlist><listitem><para>
#: lfs-en/chapter08/pkgmgt.xml:119
msgid ""
"If <application>OpenSSH</application> is being used to access the system and "
"it is linked to the updated library, you must restart the <command>sshd</"
"command> service, then logout, login again, and rerun the preceding ps "
"command to confirm that nothing is still using the deleted libraries."
msgstr ""

#. type: Content of: <sect1><sect2><itemizedlist><listitem><para>
#: lfs-en/chapter08/pkgmgt.xml:127
msgid ""
"If the <command>systemd</command> daemon (running as PID 1) is linked to the "
"updated library, you can restart it without rebooting by running "
"<command>systemctl daemon-reexec</command> as the <systemitem "
"class='username'>root</systemitem> user."
msgstr ""

#. type: Content of: <sect1><sect2><itemizedlist><listitem><para>
#: lfs-en/chapter08/pkgmgt.xml:134
msgid ""
"If an executable program or a shared library is overwritten, the processes "
"using the code or data in that program or library may crash.  The correct "
"way to update a program or a shared library without causing the process to "
"crash is to remove it first, then install the new version. The "
"<command>install</command> command provided by <application>coreutils</"
"application> has already implemented this, and most packages use that "
"command to install binary files and libraries.  This means that you won't be "
"troubled by this issue most of the time.  However, the install process of "
"some packages (notably Mozilla JS in BLFS) just overwrites the file if it "
"exists; this causes a crash. So it's safer to save your work and close "
"unneeded running processes before updating a package."
msgstr ""

#. type: Content of: <sect1><sect2><title>
#: lfs-en/chapter08/pkgmgt.xml:152
msgid "Package Management Techniques"
msgstr "软件包管理技术"

#. type: Content of: <sect1><sect2><para>
#: lfs-en/chapter08/pkgmgt.xml:154
#, fuzzy
#| msgid ""
#| "The following are some common package management techniques. Before "
#| "making a decision on a package manager, do some research on the various "
#| "techniques, particularly the drawbacks of the particular scheme."
msgid ""
"The following are some common package management techniques. Before making a "
"decision on a package manager, do some research on the various techniques, "
"particularly the drawbacks of each particular scheme."
msgstr ""
"以下是几种常见的软件包管理技术。在决定使用某种包管理器前，请研读这些技术，特"
"别是要了解特定技术的不足。"

#. type: Content of: <sect1><sect2><sect3><title>
#: lfs-en/chapter08/pkgmgt.xml:159
msgid "It is All in My Head!"
msgstr "这都在我的脑袋里！"

#. type: Content of: <sect1><sect2><sect3><para>
#: lfs-en/chapter08/pkgmgt.xml:161
#, fuzzy
#| msgid ""
#| "Yes, this is a package management technique. Some folks do not find the "
#| "need for a package manager because they know the packages intimately and "
#| "know what files are installed by each package. Some users also do not "
#| "need any package management because they plan on rebuilding the entire "
#| "system when a package is changed."
msgid ""
"Yes, this is a package management technique. Some folks do not need a "
"package manager because they know the packages intimately and know which "
"files are installed by each package. Some users also do not need any package "
"management because they plan on rebuilding the entire system whenever a "
"package is changed."
msgstr ""
"没错，这是一种包管理技术。有些人觉得不需要管理软件包，因为他们十分了解软件"
"包，知道每个软件包安装了什么文件。有的用户则计划每次有软件包发生变动时就重新"
"构建系统，所以不需要管理软件包。"

#. type: Content of: <sect1><sect2><sect3><title>
#: lfs-en/chapter08/pkgmgt.xml:170
msgid "Install in Separate Directories"
msgstr "安装到独立目录"

#. type: Content of: <sect1><sect2><sect3><para>
#: lfs-en/chapter08/pkgmgt.xml:172
#, fuzzy
#| msgid ""
#| "This is a simplistic package management that does not need any extra "
#| "package to manage the installations. Each package is installed in a "
#| "separate directory. For example, package foo-1.1 is installed in "
#| "<filename class='directory'>/usr/pkg/foo-1.1</filename> and a symlink is "
#| "made from <filename>/usr/pkg/foo</filename> to <filename "
#| "class='directory'>/usr/pkg/foo-1.1</filename>. When installing a new "
#| "version foo-1.2, it is installed in <filename class='directory'>/usr/pkg/"
#| "foo-1.2</filename> and the previous symlink is replaced by a symlink to "
#| "the new version."
msgid ""
"This is a simplistic package management technique that does not need a "
"special program to manage the packages. Each package is installed in a "
"separate directory. For example, package foo-1.1 is installed in <filename "
"class='directory'>/usr/pkg/foo-1.1</filename> and a symlink is made from "
"<filename>/usr/pkg/foo</filename> to <filename class='directory'>/usr/pkg/"
"foo-1.1</filename>. When a new version foo-1.2 comes along, it is installed "
"in <filename class='directory'>/usr/pkg/foo-1.2</filename> and the previous "
"symlink is replaced by a symlink to the new version."
msgstr ""
"这是一种最简单的软件包管理方式，它不需要任何额外的软件来控制软件包的安装。每"
"个软件包都被安装在单独的目录中。例如，软件包 foo-1.1 将会被安装在 <filename "
"class='directory'>/usr/pkg/foo-1.1</filename>，然后创建一个符号链接 "
"<filename>/usr/pkg/foo</filename> 指向 <filename class='directory'>/usr/pkg/"
"foo-1.1</filename>。在安装新版本 foo-1.2 的时候，把它安装到 <filename "
"class='directory'>/usr/pkg/foo-1.2</filename>，然后把之前的符号链接替换为指向"
"新版本的符号链接。"

#. type: Content of: <sect1><sect2><sect3><para>
#: lfs-en/chapter08/pkgmgt.xml:182
#, fuzzy
#| msgid ""
#| "Environment variables such as <envar>PATH</envar>, "
#| "<envar>LD_LIBRARY_PATH</envar>, <envar>MANPATH</envar>, <envar>INFOPATH</"
#| "envar> and <envar>CPPFLAGS</envar> need to be expanded to include "
#| "<filename>/usr/pkg/foo</filename>. For more than a few packages, this "
#| "scheme becomes unmanageable."
msgid ""
"Environment variables such as <envar>PATH</envar>, <envar>LD_LIBRARY_PATH</"
"envar>, <envar>MANPATH</envar>, <envar>INFOPATH</envar> and <envar>CPPFLAGS</"
"envar> need to be expanded to include <filename>/usr/pkg/foo</filename>. If "
"you install more than a few packages, this scheme becomes unmanageable."
msgstr ""
"<envar>PATH</envar>、<envar>LD_LIBRARY_PATH</envar>、<envar>MANPATH</envar>、"
"<envar>INFOPATH</envar> 和 <envar>CPPFLAGS</envar> 等环境变量需要被扩充，以包"
"含 <filename>/usr/pkg/foo</filename>。一旦软件包的数量较多，这种架构就会变得"
"无法管理。"

#. type: Content of: <sect1><sect2><sect3><title>
#: lfs-en/chapter08/pkgmgt.xml:191
msgid "Symlink Style Package Management"
msgstr "符号链接风格的软件包管理"

#. type: Content of: <sect1><sect2><sect3><para>
#: lfs-en/chapter08/pkgmgt.xml:193
#, fuzzy
#| msgid ""
#| "This is a variation of the previous package management technique.  Each "
#| "package is installed similar to the previous scheme. But instead of "
#| "making the symlink, each file is symlinked into the <filename "
#| "class='directory'>/usr</filename> hierarchy. This removes the need to "
#| "expand the environment variables. Though the symlinks can be created by "
#| "the user to automate the creation, many package managers have been "
#| "written using this approach. A few of the popular ones include Stow, "
#| "Epkg, Graft, and Depot."
msgid ""
"This is a variation of the previous package management technique.  Each "
"package is installed as in the previous scheme. But instead of making the "
"symlink via a generic package name, each file is symlinked into the "
"<filename class='directory'>/usr</filename> hierarchy. This removes the need "
"to expand the environment variables. Though the symlinks can be created by "
"the user, many package managers use this approach, and automate the creation "
"of the symlinks. A few of the popular ones include Stow, Epkg, Graft, and "
"Depot."
msgstr ""
"这是前一种软件包管理技术的变种。和前一种方式一样，将各个软件包同样安装在独立"
"的目录中。但不是建立目录的符号链接，而是把其中的每个文件符号链接到 <filename "
"class='directory'>/usr</filename> 目录树中对应的位置。这样就不需要修改环境变"
"量。虽然这些符号链接可以由用户自己创建，但已经有许多包管理器能够自动化这一过"
"程。一些流行的包管理器如 Stow、Epkg、Graft 和 Depot 使用这种管理方式。"

#. type: Content of: <sect1><sect2><sect3><para>
#: lfs-en/chapter08/pkgmgt.xml:202
#, fuzzy
#| msgid ""
#| "The installation needs to be faked, so that the package thinks that it is "
#| "installed in <filename class=\"directory\">/usr</filename> though in "
#| "reality it is installed in the <filename class=\"directory\">/usr/pkg</"
#| "filename> hierarchy. Installing in this manner is not usually a trivial "
#| "task. For example, consider that you are installing a package libfoo-1.1. "
#| "The following instructions may not install the package properly:"
msgid ""
"The installation script needs to be fooled, so the package thinks it is "
"installed in <filename class=\"directory\">/usr</filename> though in reality "
"it is installed in the <filename class=\"directory\">/usr/pkg</filename> "
"hierarchy. Installing in this manner is not usually a trivial task. For "
"example, suppose you are installing a package libfoo-1.1. The following "
"instructions may not install the package properly:"
msgstr ""
"安装过程需要伪装，使得软件包认为它处于 <filename class=\"directory\">/usr</"
"filename> 中，尽管它实际上被安装在 <filename class=\"directory\">/usr/pkg</"
"filename> 目录结构中。这种安装过程一般是超出常规的。例如，考虑安装软件包 "
"libfoo-1.1。下面的指令可能不能正确安装该软件包："

#. type: Content of: <sect1><sect2><sect3><screen>
#: lfs-en/chapter08/pkgmgt.xml:210
#, no-wrap
msgid ""
"<userinput>./configure --prefix=/usr/pkg/libfoo/1.1\n"
"make\n"
"make install</userinput>"
msgstr ""
"<userinput>./configure --prefix=/usr/pkg/libfoo/1.1\n"
"make\n"
"make install</userinput>"

#. type: Content of: <sect1><sect2><sect3><para>
#: lfs-en/chapter08/pkgmgt.xml:214
#, fuzzy
#| msgid ""
#| "The installation will work, but the dependent packages may not link to "
#| "libfoo as you would expect. If you compile a package that links against "
#| "libfoo, you may notice that it is linked to <filename "
#| "class='libraryfile'>/usr/pkg/libfoo/1.1/lib/libfoo.so.1</filename> "
#| "instead of <filename class='libraryfile'>/usr/lib/libfoo.so.1</filename> "
#| "as you would expect. The correct approach is to use the <envar>DESTDIR</"
#| "envar> strategy to fake installation of the package. This approach works "
#| "as follows:"
msgid ""
"The installation will work, but the dependent packages may not link to "
"libfoo as you would expect. If you compile a package that links against "
"libfoo, you may notice that it is linked to <filename class='libraryfile'>/"
"usr/pkg/libfoo/1.1/lib/libfoo.so.1</filename> instead of <filename "
"class='libraryfile'>/usr/lib/libfoo.so.1</filename> as you would expect. The "
"correct approach is to use the <envar>DESTDIR</envar> variable to direct the "
"installation. This approach works as follows:"
msgstr ""
"尽管安装过程本身可以顺利进行，但依赖于它的软件包可能不会像您期望的那样链接 "
"libfoo 库。如果要编译一个依赖于 libfoo 的软件包，您可能发现它链接到了 "
"<filename class='libraryfile'>/usr/pkg/libfoo/1.1/lib/libfoo.so.1</filename> "
"而不是您期望的 <filename class='libraryfile'>/usr/lib/libfoo.so.1</"
"filename>。正确的做法是使用 <envar>DESTDIR</envar> 策略伪装软件包的安装过程。"
"就像下面这样做："

#. type: Content of: <sect1><sect2><sect3><screen>
#: lfs-en/chapter08/pkgmgt.xml:223
#, no-wrap
msgid ""
"<userinput>./configure --prefix=/usr\n"
"make\n"
"make DESTDIR=/usr/pkg/libfoo/1.1 install</userinput>"
msgstr ""
"<userinput>./configure --prefix=/usr\n"
"make\n"
"make DESTDIR=/usr/pkg/libfoo/1.1 install</userinput>"

#. type: Content of: <sect1><sect2><sect3><para>
#: lfs-en/chapter08/pkgmgt.xml:227
#, fuzzy
#| msgid ""
#| "Most packages support this approach, but there are some which do not.  "
#| "For the non-compliant packages, you may either need to manually install "
#| "the package, or you may find that it is easier to install some "
#| "problematic packages into <filename class='directory'>/opt</filename>."
msgid ""
"Most packages support this approach, but there are some which do not.  For "
"the non-compliant packages, you may either need to install the package "
"manually, or you may find that it is easier to install some problematic "
"packages into <filename class='directory'>/opt</filename>."
msgstr ""
"多数软件包可以这样安装，但有些不能。对于那些不兼容的软件包，您要么亲自动手安"
"装，要么更简单地把一些出问题的软件包安装在 <filename class='directory'>/opt</"
"filename>中。"

#. type: Content of: <sect1><sect2><sect3><title>
#: lfs-en/chapter08/pkgmgt.xml:235
msgid "Timestamp Based"
msgstr "基于时间戳的方案"

#. type: Content of: <sect1><sect2><sect3><para>
#: lfs-en/chapter08/pkgmgt.xml:237
#, fuzzy
#| msgid ""
#| "In this technique, a file is timestamped before the installation of the "
#| "package. After the installation, a simple use of the <command>find</"
#| "command> command with the appropriate options can generate a log of all "
#| "the files installed after the timestamp file was created. A package "
#| "manager written with this approach is install-log."
msgid ""
"In this technique, a file is timestamped before the installation of the "
"package. After the installation, a simple use of the <command>find</command> "
"command with the appropriate options can generate a log of all the files "
"installed after the timestamp file was created. A package manager that uses "
"this approach is install-log."
msgstr ""
"在这种技巧中，安装一个软件包之前，为它创建一个时间戳文件。在安装后，用一行简"
"单的 <command>find</command> 命令，加上正确的参数，就能生成安装日志，包含在时"
"间戳文件创建以后安装的所有文件。有一个采用这个方案的包管理器叫做 install-"
"log。"

#. type: Content of: <sect1><sect2><sect3><para>
#: lfs-en/chapter08/pkgmgt.xml:243
#, fuzzy
#| msgid ""
#| "Though this scheme has the advantage of being simple, it has two "
#| "drawbacks. If, during installation, the files are installed with any "
#| "timestamp other than the current time, those files will not be tracked by "
#| "the package manager. Also, this scheme can only be used when one package "
#| "is installed at a time. The logs are not reliable if two packages are "
#| "being installed on two different consoles."
msgid ""
"Though this scheme has the advantage of being simple, it has two drawbacks. "
"If, during installation, the files are installed with any timestamp other "
"than the current time, those files will not be tracked by the package "
"manager. Also, this scheme can only be used when packages are installed one "
"at a time. The logs are not reliable if two packages are installed "
"simultaneously from two different consoles."
msgstr ""
"尽管这种方式很简单，但它有两个缺点。如果在安装过程中，某些文件没有以当前时间"
"作为时间戳安装，它们就不能被包管理器跟踪。另外，只有每次只安装一个软件包时才"
"能使用这种技术。如果在两个终端中同时安装两个不同的软件包，它们的安装日志就不"
"可靠了。"

#. type: Content of: <sect1><sect2><sect3><title>
#: lfs-en/chapter08/pkgmgt.xml:253
msgid "Tracing Installation Scripts"
msgstr "追踪安装脚本"

#. type: Content of: <sect1><sect2><sect3><para>
#: lfs-en/chapter08/pkgmgt.xml:255
msgid ""
"In this approach, the commands that the installation scripts perform are "
"recorded.  There are two techniques that one can use:"
msgstr "在这种方式中，安装脚本执行的命令被记录下来。有两种技术可以进行记录："

#. type: Content of: <sect1><sect2><sect3><para>
#: lfs-en/chapter08/pkgmgt.xml:258
#, fuzzy
#| msgid ""
#| "The <envar>LD_PRELOAD</envar> environment variable can be set to point to "
#| "a library to be preloaded before installation.  During installation, this "
#| "library tracks the packages that are being installed by attaching itself "
#| "to various executables such as <command>cp</command>, <command>install</"
#| "command>, <command>mv</command> and tracking the system calls that modify "
#| "the filesystem. For this approach to work, all the executables need to be "
#| "dynamically linked without the suid or sgid bit.  Preloading the library "
#| "may cause some unwanted side-effects during installation. Therefore, it "
#| "is advised that one performs some tests to ensure that the package "
#| "manager does not break anything and logs all the appropriate files."
msgid ""
"The <envar>LD_PRELOAD</envar> environment variable can be set to point to a "
"library to be preloaded before installation.  During installation, this "
"library tracks the packages that are being installed by attaching itself to "
"various executables such as <command>cp</command>, <command>install</"
"command>, <command>mv</command> and tracking the system calls that modify "
"the filesystem. For this approach to work, all the executables need to be "
"dynamically linked without the suid or sgid bit.  Preloading the library may "
"cause some unwanted side-effects during installation. Therefore, it's a good "
"idea to perform some tests to ensure that the package manager does not break "
"anything, and that it logs all the appropriate files."
msgstr ""
"在安装前设置 <envar>LD_PRELOAD</envar> 环境变量，将其指向一个库以在安装过程中"
"预加载它。在安装过程中，这个库附加在 <command>cp</command>、"
"<command>install</command>、<command>mv</command> 等可执行文件上，跟踪修改文"
"件系统的系统调用。如果要使用这种方法，所有需要跟踪的可执行文件必须是动态链接"
"的，且没有设定 suid 和 sgid 位。预加载动态库可能在安装过程中导致不希望的副作"
"用。因此，建议在实际使用前进行一些测试，以确保包管理器不会造成破坏，并且记录"
"了所有应该记录的文件。"

#. type: Content of: <sect1><sect2><sect3><para>
#: lfs-en/chapter08/pkgmgt.xml:270
#, fuzzy
#| msgid ""
#| "The second technique is to use <command>strace</command>, which logs all "
#| "system calls made during the execution of the installation scripts."
msgid ""
"Another technique is to use <command>strace</command>, which logs all the "
"system calls made during the execution of the installation scripts."
msgstr ""
"第二种技术是使用 <command>strace</command>，它能够记录安装脚本执行过程中的所"
"有系统调用。"

#. type: Content of: <sect1><sect2><sect3><title>
#: lfs-en/chapter08/pkgmgt.xml:276
msgid "Creating Package Archives"
msgstr "创建软件包档案"

#. type: Content of: <sect1><sect2><sect3><para>
#: lfs-en/chapter08/pkgmgt.xml:278
#, fuzzy
#| msgid ""
#| "In this scheme, the package installation is faked into a separate tree as "
#| "described in the Symlink style package management. After the "
#| "installation, a package archive is created using the installed files.  "
#| "This archive is then used to install the package either on the local "
#| "machine or can even be used to install the package on other machines."
msgid ""
"In this scheme, the package installation is faked into a separate tree as "
"previously described in the symlink style package management section. After "
"the installation, a package archive is created using the installed files.  "
"This archive is then used to install the package on the local machine or "
"even on other machines."
msgstr ""
"在这种架构中，软件包被伪装安装到一个独立的目录树中，就像软链接风格的软件包管"
"理那样。在安装后，使用被安装的文件创建一个软件包档案。它可以被用来在本地机器"
"甚至其他机器上安装该软件包。"

#. type: Content of: <sect1><sect2><sect3><para>
#: lfs-en/chapter08/pkgmgt.xml:284
#, fuzzy
#| msgid ""
#| "This approach is used by most of the package managers found in the "
#| "commercial distributions. Examples of package managers that follow this "
#| "approach are RPM (which, incidentally, is required by the <ulink "
#| "url=\"http://refspecs.linuxfoundation.org/lsb.shtml\">Linux Standard Base "
#| "Specification</ulink>), pkg-utils, Debian's apt, and Gentoo's Portage "
#| "system.  A hint describing how to adopt this style of package management "
#| "for LFS systems is located at <ulink url=\"&hints-root;fakeroot.txt\"/>."
msgid ""
"This approach is used by most of the package managers found in the "
"commercial distributions. Examples of package managers that follow this "
"approach are RPM (which, incidentally, is required by the <ulink "
"url=\"https://refspecs.linuxfoundation.org/lsb.shtml\">Linux Standard Base "
"Specification</ulink>), pkg-utils, Debian's apt, and Gentoo's Portage "
"system.  A hint describing how to adopt this style of package management for "
"LFS systems is located at <ulink url=\"&hints-root;fakeroot.txt\"/>."
msgstr ""
"大多数商业发行版的包管理器采用这种策略。例如 RPM (值得一提的是，它被 <ulink "
"url=\"http://refspecs.linuxfoundation.org/lsb.shtml\">Linux Standard Base 规"
"则</ulink>所要求)、pkg-utils、Debian 的 apt，以及 Gentoo 的 Portage 系统等。"
"LFS Hint 中的一篇短文描述了如何为 LFS 系统适用这种管理方式：<ulink "
"url=\"&hints-root;fakeroot.txt\"/>。"

#. type: Content of: <sect1><sect2><sect3><para>
#: lfs-en/chapter08/pkgmgt.xml:293
#, fuzzy
#| msgid ""
#| "Creation of package files that include dependency information is complex "
#| "and is beyond the scope of LFS."
msgid ""
"The creation of package files that include dependency information is "
"complex, and beyond the scope of LFS."
msgstr "创建包含依赖关系信息的软件包文件十分复杂，超出了 LFS 的范畴。"

#. type: Content of: <sect1><sect2><sect3><para>
#: lfs-en/chapter08/pkgmgt.xml:296
#, fuzzy
#| msgid ""
#| "Slackware uses a <command>tar</command> based system for package "
#| "archives.  This system purposely does not handle package dependencies as "
#| "more complex package managers do.  For details of Slackware package "
#| "management, see <ulink url=\"http://www.slackbook.org/html/package-"
#| "management.html\"/>."
msgid ""
"Slackware uses a <command>tar</command>-based system for package archives.  "
"This system purposely does not handle package dependencies as more complex "
"package managers do.  For details of Slackware package management, see "
"<ulink url=\"https://www.slackbook.org/html/package-management.html\"/>."
msgstr ""
"Slackware 使用一个基于 <command>tar</command> 的系统创建软件包档案。和更复杂"
"的包管理器不同，该系统有意地没有涉及软件包依赖关系。如果想了解 Slackware 包管"
"理器的详细信息，阅读 <ulink url=\"http://www.slackbook.org/html/package-"
"management.html\"/>。"

#. type: Content of: <sect1><sect2><sect3><title>
#: lfs-en/chapter08/pkgmgt.xml:304
msgid "User Based Management"
msgstr "基于用户的软件包管理"

#. type: Content of: <sect1><sect2><sect3><para>
#: lfs-en/chapter08/pkgmgt.xml:306
msgid ""
"This scheme, unique to LFS, was devised by Matthias Benkmann, and is "
"available from the <ulink url=\"&hints-root;\">Hints Project</ulink>. In "
"this scheme, each package is installed as a separate user into the standard "
"locations. Files belonging to a package are easily identified by checking "
"the user ID. The features and shortcomings of this approach are too complex "
"to describe in this section. For the details please see the hint at <ulink "
"url=\"&hints-root;more_control_and_pkg_man.txt\"/>."
msgstr ""
"这种架构是 LFS 特有的，由 Matthias Benkmann 提出，可以在 <ulink url=\"&hints-"
"root;\">Hints Project</ulink> 查阅。在该架构中，每个软件包都由一个单独的用户"
"安装到标准位置。只要检查文件所有者，就能找出属于一个软件包的所有文件。它的优"
"缺点十分复杂，无法在本节讨论。如果想详细了解，请访问 <ulink url=\"&hints-"
"root;more_control_and_pkg_man.txt\"/> 阅读。"

#. type: Content of: <sect1><sect2><title>
#: lfs-en/chapter08/pkgmgt.xml:319
msgid "Deploying LFS on Multiple Systems"
msgstr "在多个系统上部署 LFS"

#.  D. Bryant created LFS 11.2 in October 2022; 900MB is (roughly) the size of his rsync archive. 
#. type: Content of: <sect1><sect2><para>
#: lfs-en/chapter08/pkgmgt.xml:321
#, fuzzy
#| msgid ""
#| "One of the advantages of an LFS system is that there are no files that "
#| "depend on the position of files on a disk system.  Cloning an LFS build "
#| "to another computer with the same architecture as the base system is as "
#| "simple as using <command>tar</command> on the LFS partition that contains "
#| "the root directory (about 250MB uncompressed for a base LFS build), "
#| "copying that file via network transfer or CD-ROM to the new system and "
#| "expanding it.  From that point, a few configuration files will have to be "
#| "changed.  Configuration files that may need to be updated include: "
#| "<filename>/etc/hosts</filename>, <filename>/etc/fstab</filename>, "
#| "<filename>/etc/passwd</filename>, <filename>/etc/group</filename>, "
#| "<phrase revision=\"systemd\"> <filename>/etc/shadow</filename>, and "
#| "<filename>/etc/ld.so.conf</filename>.  </phrase> <phrase "
#| "revision=\"sysv\"> <filename>/etc/shadow</filename>, <filename>/etc/ld.so."
#| "conf</filename>, <filename>/etc/sysconfig/rc.site</filename>, <filename>/"
#| "etc/sysconfig/network</filename>, and <filename>/etc/sysconfig/ifconfig."
#| "eth0</filename>.  </phrase>"
msgid ""
"One of the advantages of an LFS system is that there are no files that "
"depend on the position of files on a disk system.  Cloning an LFS build to "
"another computer with the same architecture as the base system is as simple "
"as using <command>tar</command> on the LFS partition that contains the root "
"directory (about 900MB uncompressed for a basic LFS build), copying that "
"file via network transfer or CD-ROM / USB stick to the new system, and "
"expanding it.  After that, a few configuration files will have to be "
"changed.  Configuration files that may need to be updated include: "
"<filename>/etc/hosts</filename>, <filename>/etc/fstab</filename>, <filename>/"
"etc/passwd</filename>, <filename>/etc/group</filename>, <phrase "
"revision=\"systemd\"> <filename>/etc/shadow</filename>, and <filename>/etc/"
"ld.so.conf</filename>.  </phrase> <phrase revision=\"sysv\"> <filename>/etc/"
"shadow</filename>, <filename>/etc/ld.so.conf</filename>, <filename>/etc/"
"sysconfig/rc.site</filename>, <filename>/etc/sysconfig/network</filename>, "
"and <filename>/etc/sysconfig/ifconfig.eth0</filename>.  </phrase>"
msgstr ""
"LFS 系统的一项优势是，没有依赖于磁盘系统中文件位置的文件。将构建好的 LFS 系统"
"复制到另一台具有相同硬件架构的计算机很简单，只要用 <command>tar</command> 命"
"令把包含根目录的 LFS 分区打包 (未压缩的情况下，一个基本的 LFS 系统需要 250 "
"MB)，然后通过网络或者 CD-ROM 复制到新的系统上，再展开即可。这时，个别配置文件"
"需要修改。可能需要更新的配置文件有：<filename>/etc/hosts</filename>，"
"<filename>/etc/fstab</filename>，<filename>/etc/passwd</filename>，"
"<filename>/etc/group</filename>，<phrase revision=\"systemd\"><filename>/etc/"
"shadow</filename>，以及 <filename>/etc/ld.so.conf</filename>。</"
"phrase><phrase revision=\"sysv\"><filename>/etc/shadow</filename>，"
"<filename>/etc/ld.so.conf</filename>，<filename>/etc/sysconfig/rc.site</"
"filename>，<filename>/etc/sysconfig/network</filename>，以及 <filename>/etc/"
"sysconfig/ifconfig.eth0</filename>。</phrase>"

#. type: Content of: <sect1><sect2><para>
#: lfs-en/chapter08/pkgmgt.xml:347
#, fuzzy
#| msgid ""
#| "A custom kernel may need to be built for the new system depending on "
#| "differences in system hardware and the original kernel configuration."
msgid ""
"A custom kernel may be needed for the new system, depending on differences "
"in system hardware and the original kernel configuration."
msgstr "由于系统硬件和原始内核配置的区别，可能需要为新系统重新配置并构建内核。"

#. type: Content of: <sect1><sect2><note><para>
#: lfs-en/chapter08/pkgmgt.xml:351
#, fuzzy
#| msgid ""
#| "There have been some reports of issues when copying between similar but "
#| "not identical architectures. For instance, the instruction set for an "
#| "Intel system is not identical with an AMD processor and later versions of "
#| "some processors may have instructions that are unavailable in earlier "
#| "versions."
msgid ""
"There have been some reports of issues when copying between similar but not "
"identical architectures. For instance, the instruction set for an Intel "
"system is not identical with the AMD processor's instructions, and later "
"versions of some processors may provide instructions that are unavailable "
"with earlier versions."
msgstr ""
"有一些报告反映称，在架构相近但不完全一致的计算机之间拷贝 LFS 系统时出现问题。"
"例如，Intel 系统使用的指令集和 AMD 处理器不完全相同，且较新的处理器可能包含旧"
"处理器没有的指令。"

#. type: Content of: <sect1><sect2><para>
#: lfs-en/chapter08/pkgmgt.xml:357
#, fuzzy
#| msgid ""
#| "Finally the new system has to be made bootable via <xref linkend=\"ch-"
#| "bootable-grub\"/>."
msgid ""
"Finally, the new system has to be made bootable via <xref linkend=\"ch-"
"bootable-grub\"/>."
msgstr ""
"最后，按照<xref linkend=\"ch-bootable-grub\"/>中的说明，为新系统配置引导加载"
"器。"
