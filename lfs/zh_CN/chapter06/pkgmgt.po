# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2019-09-03 10:12+0000\n"
"PO-Revision-Date: 2019-11-16 19:19+0000\n"
"Last-Translator: Xi Ruoyao <xry111@mengyan1223.wang>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Pootle 2.8\n"
"X-POOTLE-MTIME: 1573931971.063891\n"

#. type: Content of: <sect1><title>
#: lfs-en/chapter06/pkgmgt.xml:11
msgid "Package Management"
msgstr "软件包管理"

#. type: Content of: <sect1><para>
#: lfs-en/chapter06/pkgmgt.xml:13
msgid ""
"Package Management is an often requested addition to the LFS Book. A Package "
"Manager allows tracking the installation of files making it easy to remove "
"and upgrade packages. As well as the binary and library files, a package "
"manager will handle the installation of configuration files.  Before you "
"begin to wonder, NO&mdash;this section will not talk about nor recommend any "
"particular package manager. What it provides is a roundup of the more "
"popular techniques and how they work. The perfect package manager for you "
"may be among these techniques or may be a combination of two or more of "
"these techniques. This section briefly mentions issues that may arise when "
"upgrading packages."
msgstr ""
"经常有人请求将软件包管理加入 LFS "
"手册。包管理器可以跟踪文件的安装过程，简化移除或升级软件包的工作。如同处理二进制程序和库文件一样，包管理器也会处理配置文件的安装过程。  "
"在您开始想入非非前，不 —— 本节不会讨论或者推荐任何一个特定的包管理器。本节对软件包管理的流行技术及其工作原理进行综述。对您来说， "
"完美的包管理器可能是其中的某个技术，也可能是几个技术的结合。本节还会简要介绍在升级软件包时可能遇到的问题。"

#. type: Content of: <sect1><para>
#: lfs-en/chapter06/pkgmgt.xml:24
msgid "Some reasons why no package manager is mentioned in LFS or BLFS include:"
msgstr "LFS 或 BLFS 不介绍任何包管理器的原因包括："

#. type: Content of: <sect1><itemizedlist><listitem><para>
#: lfs-en/chapter06/pkgmgt.xml:29
msgid ""
"Dealing with package management takes the focus away from the goals of these "
"books&mdash;teaching how a Linux system is built."
msgstr "处理软件包管理会偏离这两本手册的目标 —— 讲述如何构建 Linux 系统。"

#. type: Content of: <sect1><itemizedlist><listitem><para>
#: lfs-en/chapter06/pkgmgt.xml:34
msgid ""
"There are multiple solutions for package management, each having its "
"strengths and drawbacks.  Including one that satisfies all audiences is "
"difficult."
msgstr "存在多种软件包管理的解决方案，它们各有优缺点。  很难找到一种让所有读者满意的方案。"

#. type: Content of: <sect1><para>
#: lfs-en/chapter06/pkgmgt.xml:40
msgid ""
"There are some hints written on the topic of package management. Visit the "
"<ulink url=\"&hints-index;\">Hints Project</ulink> and see if one of them "
"fits your need."
msgstr ""
"已经有人写了一些关于软件包管理这一主题的短文。您可以访问 <ulink url=\"&hints-index;\">Hints "
"Project</ulink> 并看一看是否有符合您的需求的方案。"

#. type: Content of: <sect1><sect2><title>
#: lfs-en/chapter06/pkgmgt.xml:45
msgid "Upgrade Issues"
msgstr "升级问题"

#. type: Content of: <sect1><sect2><para>
#: lfs-en/chapter06/pkgmgt.xml:47
msgid ""
"A Package Manager makes it easy to upgrade to newer versions when they are "
"released. Generally the instructions in the LFS and BLFS Book can be used to "
"upgrade to the newer versions. Here are some points that you should be aware "
"of when upgrading packages, especially on a running system."
msgstr ""
"使用包管理器可以在软件包新版本发布后容易地完成升级。一般来说， 使用 LFS 或者 BLFS "
"手册中的指令即可升级软件包。下面是您在升级时必须注意的重点，特别是升级正在运行的系统时。"

#. type: Content of: <sect1><sect2><itemizedlist><listitem><para>
#: lfs-en/chapter06/pkgmgt.xml:54
msgid ""
"If Glibc needs to be upgraded to a newer version, (e.g.  from glibc-2.19 to "
"glibc-2.20), it is safer to rebuild LFS.  Though you "
"<emphasis>may</emphasis> be able to rebuild all the packages in their "
"dependency order, we do not recommend it."
msgstr ""
"如果需要升级 Glibc  (例如从 Glibc-2.19 升级到 Glibc-2.20)，最安全的方法是重新构建 LFS 。  尽管您 "
"<emphasis>或许</emphasis> 能按依赖顺序重新构建所有软件包，但我们不推荐这样做。"

#. type: Content of: <sect1><sect2><itemizedlist><listitem><para>
#: lfs-en/chapter06/pkgmgt.xml:61
msgid ""
"If a package containing a shared library is updated, and if the name of the "
"library changes, then all the packages dynamically linked to the library "
"need to be recompiled to link against the newer library.  (Note that there "
"is no correlation between the package version and the name of the library.) "
"For example, consider a package foo-1.2.3 that installs a shared library "
"with name <filename class='libraryfile'>libfoo.so.1</filename>. Say you "
"upgrade the package to a newer version foo-1.2.4 that installs a shared "
"library with name <filename class='libraryfile'>libfoo.so.2</filename>. In "
"this case, all packages that are dynamically linked to <filename "
"class='libraryfile'>libfoo.so.1</filename> need to be recompiled to link "
"against <filename class='libraryfile'>libfoo.so.2</filename>. Note that you "
"should not remove the previous libraries until the dependent packages are "
"recompiled."
msgstr ""
"如果更新了一个包含共享库的软件包，而且共享库的名称发生改变，那么所有动态链接到这个库的软件包都需要重新编译，以链接到新版本的库。  "
"(注意软件包的版本和共享库的名称没有关系。) 例如，如果一个软件包 foo-1.2.3 安装了名为 <filename "
"class='libraryfile'>libfoo.so.1</filename>的共享库，您把该软件包升级到了新版本 foo-1.2.4，"
"它安装了名为 <filename class='libraryfile'>libfoo.so.2</filename>的共享库。那么，所有链接到 <"
"filename class='libraryfile'>libfoo.so.1</filename> 的软件包都要重新编译以链接到 <filename "
"class='libraryfile'>libfoo.so.2</filename>。注意，在重新编译这些软件包之前，您不能删除旧版本的库。"

#. type: Content of: <sect1><sect2><title>
#: lfs-en/chapter06/pkgmgt.xml:82
msgid "Package Management Techniques"
msgstr "软件包管理技术"

#. type: Content of: <sect1><sect2><para>
#: lfs-en/chapter06/pkgmgt.xml:84
msgid ""
"The following are some common package management techniques. Before making a "
"decision on a package manager, do some research on the various techniques, "
"particularly the drawbacks of the particular scheme."
msgstr "以下是几种常见的软件包管理技术。在决定使用某种包管理器前，请研读这些技术，特别是要了解特定技术的不足。"

#. type: Content of: <sect1><sect2><sect3><title>
#: lfs-en/chapter06/pkgmgt.xml:89
msgid "It is All in My Head!"
msgstr "这都在我的脑袋里！"

#. type: Content of: <sect1><sect2><sect3><para>
#: lfs-en/chapter06/pkgmgt.xml:91
msgid ""
"Yes, this is a package management technique. Some folks do not find the need "
"for a package manager because they know the packages intimately and know "
"what files are installed by each package. Some users also do not need any "
"package management because they plan on rebuilding the entire system when a "
"package is changed."
msgstr ""
"没错，这是一种包管理技术。有些人觉得不需要管理软件包，因为他们十分了解软件包，知道每个软件包安装了什么文件。有的用户则计划每次有软件包发生变动时就重新构建"
"系统，所以不需要管理软件包。"

#. type: Content of: <sect1><sect2><sect3><title>
#: lfs-en/chapter06/pkgmgt.xml:100
msgid "Install in Separate Directories"
msgstr "安装到独立目录"

#. type: Content of: <sect1><sect2><sect3><para>
#: lfs-en/chapter06/pkgmgt.xml:102
msgid ""
"This is a simplistic package management that does not need any extra package "
"to manage the installations. Each package is installed in a separate "
"directory. For example, package foo-1.1 is installed in <filename "
"class='directory'>/usr/pkg/foo-1.1</filename> and a symlink is made from "
"<filename>/usr/pkg/foo</filename> to <filename "
"class='directory'>/usr/pkg/foo-1.1</filename>. When installing a new version "
"foo-1.2, it is installed in <filename "
"class='directory'>/usr/pkg/foo-1.2</filename> and the previous symlink is "
"replaced by a symlink to the new version."
msgstr ""
"这是一种最简单的软件包管理方式，它不需要任何额外的软件来控制软件包的安装。每个软件包都被安装在单独的目录中。例如，软件包 foo-1.1 将会被安装在 <"
"filename class='directory'>/usr/pkg/foo-1.1</filename> ，然后创建一个符号链接 "
"<filename>/usr/pkg/foo</filename> 指向 <filename "
"class='directory'>/usr/pkg/foo-1.1</filename>。在安装新版本 foo-1.2 的时候，把它安装到 <"
"filename class='directory'>/usr/pkg/foo-1.2</filename> "
"，然后把之前的符号链接替换为指向新版本的符号链接。"

#. type: Content of: <sect1><sect2><sect3><para>
#: lfs-en/chapter06/pkgmgt.xml:112
msgid ""
"Environment variables such as <envar>PATH</envar>, "
"<envar>LD_LIBRARY_PATH</envar>, <envar>MANPATH</envar>, "
"<envar>INFOPATH</envar> and <envar>CPPFLAGS</envar> need to be expanded to "
"include <filename>/usr/pkg/foo</filename>. For more than a few packages, "
"this scheme becomes unmanageable."
msgstr ""
"<envar>PATH</envar>、<envar>LD_LIBRARY_PATH</envar>、 "
"<envar>MANPATH</envar>、<envar>INFOPATH</envar> 和 <envar>CPPFLAGS</envar> "
"等环境变量需要被扩充，以包含 <filename>/usr/pkg/foo</filename>。一旦软件包的数量较多， 这种架构就会变得无法管理。"

#. type: Content of: <sect1><sect2><sect3><title>
#: lfs-en/chapter06/pkgmgt.xml:121
msgid "Symlink Style Package Management"
msgstr "符号链接风格的软件包管理"

#. type: Content of: <sect1><sect2><sect3><para>
#: lfs-en/chapter06/pkgmgt.xml:123
msgid ""
"This is a variation of the previous package management technique.  Each "
"package is installed similar to the previous scheme. But instead of making "
"the symlink, each file is symlinked into the <filename "
"class='directory'>/usr</filename> hierarchy. This removes the need to expand "
"the environment variables. Though the symlinks can be created by the user to "
"automate the creation, many package managers have been written using this "
"approach. A few of the popular ones include Stow, Epkg, Graft, and Depot."
msgstr ""
"这是前一种软件包管理技术的变种。  和前一种方式一样，将各个软件包同样安装在独立的目录中。但不是建立目录的符号链接，而是把其中的每个文件符号链接到 <"
"filename class='directory'>/usr</filename> "
"目录树中对应的位置。这样就不需要修改环境变量。虽然这些符号链接可以由用户自己创建，但已经有许多包管理器能够自动化这一过程。一些流行的包管理器如 "
"Stow、Epkg、Graft 和 Depot 使用这种管理方式。"

#. type: Content of: <sect1><sect2><sect3><para>
#: lfs-en/chapter06/pkgmgt.xml:132
msgid ""
"The installation needs to be faked, so that the package thinks that it is "
"installed in <filename class=\"directory\">/usr</filename> though in reality "
"it is installed in the <filename class=\"directory\">/usr/pkg</filename> "
"hierarchy. Installing in this manner is not usually a trivial task. For "
"example, consider that you are installing a package libfoo-1.1. The "
"following instructions may not install the package properly:"
msgstr ""
"安装过程需要伪装，使得软件包认为它处于 <filename class=\"directory\">/usr</filename> 中，"
"尽管它实际上被安装在 <filename class=\"directory\">/usr/pkg</filename> "
"目录结构中。这种安装过程一般是超出常规的。例如，考虑安装软件包 libfoo-1.1。下面的指令可能不能正确安装该软件包："

#. type: Content of: <sect1><sect2><sect3><screen>
#: lfs-en/chapter06/pkgmgt.xml:140
#, no-wrap
msgid ""
"<userinput>./configure --prefix=/usr/pkg/libfoo/1.1\n"
"make\n"
"make install</userinput>"
msgstr ""
"<userinput>./configure --prefix=/usr/pkg/libfoo/1.1\n"
"make\n"
"make install</userinput>"

#. type: Content of: <sect1><sect2><sect3><para>
#: lfs-en/chapter06/pkgmgt.xml:144
msgid ""
"The installation will work, but the dependent packages may not link to "
"libfoo as you would expect. If you compile a package that links against "
"libfoo, you may notice that it is linked to <filename "
"class='libraryfile'>/usr/pkg/libfoo/1.1/lib/libfoo.so.1</filename> instead "
"of <filename class='libraryfile'>/usr/lib/libfoo.so.1</filename> as you "
"would expect. The correct approach is to use the <envar>DESTDIR</envar> "
"strategy to fake installation of the package. This approach works as "
"follows:"
msgstr ""
"尽管安装过程本身可以顺利进行，但依赖于它的软件包可能不会像您期望的那样链接 libfoo 库。如果要编译一个依赖于 libfoo 的软件包，"
"您可能发现它链接到了 <filename "
"class='libraryfile'>/usr/pkg/libfoo/1.1/lib/libfoo.so.1</filename> 而不是您期望的 <"
"filename class='libraryfile'>/usr/lib/libfoo.so.1</filename> 。正确的做法是使用 "
"<envar>DESTDIR</envar> 策略伪装软件包的安装过程。就像下面这样做："

#. type: Content of: <sect1><sect2><sect3><screen>
#: lfs-en/chapter06/pkgmgt.xml:153
#, no-wrap
msgid ""
"<userinput>./configure --prefix=/usr\n"
"make\n"
"make DESTDIR=/usr/pkg/libfoo/1.1 install</userinput>"
msgstr ""
"<userinput>./configure --prefix=/usr\n"
"make\n"
"make DESTDIR=/usr/pkg/libfoo/1.1 install</userinput>"

#. type: Content of: <sect1><sect2><sect3><para>
#: lfs-en/chapter06/pkgmgt.xml:157
msgid ""
"Most packages support this approach, but there are some which do not.  For "
"the non-compliant packages, you may either need to manually install the "
"package, or you may find that it is easier to install some problematic "
"packages into <filename class='directory'>/opt</filename>."
msgstr ""
"多数软件包可以这样安装，但有些不能。  对于那些不兼容的软件包，您要么亲自动手安装，要么更简单地把一些出问题的软件包安装在 <filename "
"class='directory'>/opt</filename>中。"

#. type: Content of: <sect1><sect2><sect3><title>
#: lfs-en/chapter06/pkgmgt.xml:165
msgid "Timestamp Based"
msgstr "基于时间戳的方案"

#. type: Content of: <sect1><sect2><sect3><para>
#: lfs-en/chapter06/pkgmgt.xml:167
msgid ""
"In this technique, a file is timestamped before the installation of the "
"package. After the installation, a simple use of the <command>find</command> "
"command with the appropriate options can generate a log of all the files "
"installed after the timestamp file was created. A package manager written "
"with this approach is install-log."
msgstr ""
"在这种技巧中，安装一个软件包之前，为它创建一个时间戳文件。在安装后，用一行简单的 <command>find</command> "
"命令，加上正确的参数，就能生成安装日志，包含在时间戳文件创建以后安装的所有文件。有一个采用这个方案的包管理器叫做 install-log。"

#. type: Content of: <sect1><sect2><sect3><para>
#: lfs-en/chapter06/pkgmgt.xml:173
msgid ""
"Though this scheme has the advantage of being simple, it has two "
"drawbacks. If, during installation, the files are installed with any "
"timestamp other than the current time, those files will not be tracked by "
"the package manager. Also, this scheme can only be used when one package is "
"installed at a time. The logs are not reliable if two packages are being "
"installed on two different consoles."
msgstr ""
"尽管这种方式很简单，但它有两个缺点。如果在安装过程中，某些文件没有以当前时间作为时间戳安装，它们就不能被包管理器跟踪。另外，只有每次只安装一个软件包时才能"
"使用这种技术。如果在两个终端中同时安装两个不同的软件包，它们的安装日志就不可靠了。"

#. type: Content of: <sect1><sect2><sect3><title>
#: lfs-en/chapter06/pkgmgt.xml:183
msgid "Tracing Installation Scripts"
msgstr "追踪安装脚本"

#. type: Content of: <sect1><sect2><sect3><para>
#: lfs-en/chapter06/pkgmgt.xml:185
msgid ""
"In this approach, the commands that the installation scripts perform are "
"recorded.  There are two techniques that one can use:"
msgstr "在这种方式中，安装脚本执行的命令被记录下来。  有两种技术可以进行记录："

#. type: Content of: <sect1><sect2><sect3><para>
#: lfs-en/chapter06/pkgmgt.xml:188
msgid ""
"The <envar>LD_PRELOAD</envar> environment variable can be set to point to a "
"library to be preloaded before installation.  During installation, this "
"library tracks the packages that are being installed by attaching itself to "
"various executables such as <command>cp</command>, "
"<command>install</command>, <command>mv</command> and tracking the system "
"calls that modify the filesystem. For this approach to work, all the "
"executables need to be dynamically linked without the suid or sgid bit.  "
"Preloading the library may cause some unwanted side-effects during "
"installation. Therefore, it is advised that one performs some tests to "
"ensure that the package manager does not break anything and logs all the "
"appropriate files."
msgstr ""
"在安装前设置 <envar>LD_PRELOAD</envar> 环境变量，将其指向一个库以在安装过程中预加载它。  在安装过程中，这个库附加在 "
"<command>cp</command>、<command>install</command>、<command>mv</command> "
"等可执行文件上，跟踪修改文件系统的系统调用。如果要使用这种方法，所有需要跟踪的可执行文件必须是动态链接的，且没有设定 suid 和 sgid 位。  "
"预加载动态库可能在安装过程中导致不希望的副作用。因此，建议在实际使用前进行一些测试，以确保包管理器不会造成破坏，并且记录了所有应该记录的文件。"

#. type: Content of: <sect1><sect2><sect3><para>
#: lfs-en/chapter06/pkgmgt.xml:200
msgid ""
"The second technique is to use <command>strace</command>, which logs all "
"system calls made during the execution of the installation scripts."
msgstr "第二种技术是使用 <command>strace</command>，它能够记录安装脚本执行过程中的所有系统调用。"

#. type: Content of: <sect1><sect2><sect3><title>
#: lfs-en/chapter06/pkgmgt.xml:206
msgid "Creating Package Archives"
msgstr "创建软件包档案"

#. type: Content of: <sect1><sect2><sect3><para>
#: lfs-en/chapter06/pkgmgt.xml:208
msgid ""
"In this scheme, the package installation is faked into a separate tree as "
"described in the Symlink style package management. After the installation, a "
"package archive is created using the installed files.  This archive is then "
"used to install the package either on the local machine or can even be used "
"to install the package on other machines."
msgstr ""
"在这种架构中，软件包被伪装安装到一个独立的目录树中，就像软链接风格的软件包管理那样。在安装后，使用被安装的文件创建一个软件包档案。  "
"它可以被用来在本地机器甚至其他机器上安装该软件包。"

#. type: Content of: <sect1><sect2><sect3><para>
#: lfs-en/chapter06/pkgmgt.xml:214
msgid ""
"This approach is used by most of the package managers found in the "
"commercial distributions. Examples of package managers that follow this "
"approach are RPM (which, incidentally, is required by the <ulink "
"url=\"http://refspecs.linuxfoundation.org/lsb.shtml\">Linux Standard Base "
"Specification</ulink>), pkg-utils, Debian's apt, and Gentoo's Portage "
"system.  A hint describing how to adopt this style of package management for "
"LFS systems is located at <ulink url=\"&hints-root;fakeroot.txt\"/>."
msgstr ""
"大多数商业发行版的包管理器采用这种策略。例如 RPM (值得一提的是，它被 <ulink url=\""
"http://refspecs.linuxfoundation.org/lsb.shtml\">Linux Standard Base "
"规则</ulink>所要求)、pkg-utils、Debian 的 apt，以及 Gentoo 的 Portage 系统等。  LFS Hint "
"中的一篇短文描述了如何为 LFS 系统适用这种管理方式：<ulink url=\"&hints-root;fakeroot.txt\"/>。"

#. type: Content of: <sect1><sect2><sect3><para>
#: lfs-en/chapter06/pkgmgt.xml:223
msgid ""
"Creation of package files that include dependency information is complex and "
"is beyond the scope of LFS."
msgstr "创建包含依赖关系信息的软件包文件十分复杂，超出了 LFS 的范畴。"

#. type: Content of: <sect1><sect2><sect3><para>
#: lfs-en/chapter06/pkgmgt.xml:226
msgid ""
"Slackware uses a <command>tar</command> based system for package archives.  "
"This system purposely does not handle package dependencies as more complex "
"package managers do.  For details of Slackware package management, see "
"<ulink url=\"http://www.slackbook.org/html/package-management.html\"/>."
msgstr ""
"Slackware 使用一个基于 <command>tar</command> 的系统创建软件包档案。  "
"和更复杂的包管理器不同，该系统有意地没有涉及软件包依赖关系。  如果想了解 Slackware 包管理器的详细信息，阅读 <ulink url=\""
"http://www.slackbook.org/html/package-management.html\"/>。"

#. type: Content of: <sect1><sect2><sect3><title>
#: lfs-en/chapter06/pkgmgt.xml:234
msgid "User Based Management"
msgstr "基于用户的软件包管理"

#. type: Content of: <sect1><sect2><sect3><para>
#: lfs-en/chapter06/pkgmgt.xml:236
msgid ""
"This scheme, unique to LFS, was devised by Matthias Benkmann, and is "
"available from the <ulink url=\"&hints-index;\">Hints Project</ulink>. In "
"this scheme, each package is installed as a separate user into the standard "
"locations. Files belonging to a package are easily identified by checking "
"the user ID. The features and shortcomings of this approach are too complex "
"to describe in this section. For the details please see the hint at <ulink "
"url=\"&hints-root;more_control_and_pkg_man.txt\"/>."
msgstr ""
"这种架构是 LFS 特有的，由 Matthias Benkmann 提出，可以在 <ulink url=\"&hints-index;\">Hints P"
"roject</ulink>查阅。在该架构中，每个软件包都由一个单独的用户安装到标准位置。只要检查文件所有者，就能找出属于一个软件包的所有文件。它的优缺点"
"十分复杂，无法在本节讨论。如果想详细了解，请访问 <ulink url=\"&hints-root;more_control_and_pkg_man."
"txt\"/>阅读。"

#. type: Content of: <sect1><sect2><title>
#: lfs-en/chapter06/pkgmgt.xml:249
msgid "Deploying LFS on Multiple Systems"
msgstr "在多个系统上部署 LFS"

#. type: Content of: <sect1><sect2><para>
#: lfs-en/chapter06/pkgmgt.xml:251
msgid ""
"One of the advantages of an LFS system is that there are no files that "
"depend on the position of files on a disk system.  Cloning an LFS build to "
"another computer with the same architecture as the base system is as simple "
"as using <command>tar</command> on the LFS partition that contains the root "
"directory (about 250MB uncompressed for a base LFS build), copying that file "
"via network transfer or CD-ROM to the new system and expanding it.  From "
"that point, a few configuration files will have to be changed.  "
"Configuration files that may need to be updated include: "
"<filename>/etc/hosts</filename>, <filename>/etc/fstab</filename>, "
"<filename>/etc/passwd</filename>, <filename>/etc/group</filename>, <phrase "
"revision=\"systemd\"> <filename>/etc/shadow</filename>, and "
"<filename>/etc/ld.so.conf</filename>.  </phrase> <phrase revision=\"sysv\"> "
"<filename>/etc/shadow</filename>, <filename>/etc/ld.so.conf</filename>, "
"<filename>/etc/sysconfig/rc.site</filename>, "
"<filename>/etc/sysconfig/network</filename>, and "
"<filename>/etc/sysconfig/ifconfig.eth0</filename>.  </phrase>"
msgstr ""
"LFS 系统的一项优势是，没有依赖于磁盘系统中文件位置的文件。  将构建好的 LFS 系统复制到另一台具有相同硬件架构的计算机很简单，只要用 "
"<command>tar</command> 命令把包含根目录的 LFS 分区打包 (未压缩的情况下，一个基本的 LFS 系统需要 250 MB)，"
"然后通过网络或者 CD-ROM 复制到新的系统上，再展开即可。  这时，个别配置文件需要修改。  "
"可能需要更新的配置文件有：<filename>/etc/hosts</filename>, <filename>/etc/fstab</filename>"
", <filename>/etc/passwd</filename>, <filename>/etc/group</filename>, <phrase "
"revision=\"systemd\"> <filename>/etc/shadow</filename>, 以及 "
"<filename>/etc/ld.so.conf</filename>。  </phrase> <phrase revision=\"sysv\"> "
"<filename>/etc/shadow</filename>, <filename>/etc/ld.so.conf</filename>, "
"<filename>/etc/sysconfig/rc.site</filename>, "
"<filename>/etc/sysconfig/network</filename>, 以及 "
"<filename>/etc/sysconfig/ifconfig.eth0</filename>。  </phrase>"

#. type: Content of: <sect1><sect2><para>
#: lfs-en/chapter06/pkgmgt.xml:276
msgid ""
"A custom kernel may need to be built for the new system depending on "
"differences in system hardware and the original kernel configuration."
msgstr "由于系统硬件和原始内核配置的区别，可能需要为新系统重新配置并构建内核。"

#. type: Content of: <sect1><sect2><note><para>
#: lfs-en/chapter06/pkgmgt.xml:280
msgid ""
"There have been some reports of issues when copying between similar but not "
"identical architectures. For instance, the instruction set for an Intel "
"system is not identical with an AMD processor and later versions of some "
"processors may have instructions that are unavailable in earlier versions."
msgstr ""
"有一些报告反映称，在架构相近但不完全一致的计算机之间拷贝 LFS 系统时出现问题。例如，Intel 系统使用的指令集和 AMD "
"处理器不完全相同，且较新的处理器可能包含旧处理器没有的指令。"

#. type: Content of: <sect1><sect2><para>
#: lfs-en/chapter06/pkgmgt.xml:286
msgid ""
"Finally the new system has to be made bootable via <xref "
"linkend=\"ch-bootable-grub\"/>."
msgstr "最后，按照 <xref linkend=\"ch-bootable-grub\"/>中的指示，为新系统配置引导加载器。"
