# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2019-09-03 09:51+0000\n"
"PO-Revision-Date: 2019-09-07 04:13+0000\n"
"Last-Translator: Xi Ruoyao <xry111@mengyan1223.wang>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Pootle 2.8\n"
"X-POOTLE-MTIME: 1567829593.383736\n"

#. type: Content of: <sect1><title>
#: lfs-en/chapter06/kernfs.xml:11
msgid "Preparing Virtual Kernel File Systems"
msgstr "准备虚拟内核文件系统"

#. type: Content of: <sect1><indexterm><primary>
#: lfs-en/chapter06/kernfs.xml:14
msgid "/dev/*"
msgstr "/dev/*"

#. type: Content of: <sect1><para>
#: lfs-en/chapter06/kernfs.xml:17
msgid ""
"Various file systems exported by the kernel are used to communicate to and "
"from the kernel itself. These file systems are virtual in that no disk space "
"is used for them. The content of the file systems resides in memory."
msgstr "内核对外提供了一些文件系统，以便自己和用户空间进行通信。 它们是虚拟文件系统，并不占用磁盘空间，其内容保留在内存中。"

#. type: Content of: <sect1><para>
#: lfs-en/chapter06/kernfs.xml:22
msgid "Begin by creating directories onto which the file systems will be mounted:"
msgstr "首先创建这些文件系统的挂载点："

#. type: Content of: <sect1><screen>
#: lfs-en/chapter06/kernfs.xml:25
#, no-wrap
msgid "<userinput>mkdir -pv $LFS/{dev,proc,sys,run}</userinput>"
msgstr "<userinput>mkdir -pv $LFS/{dev,proc,sys,run}</userinput>"

#. type: Content of: <sect1><sect2><title>
#: lfs-en/chapter06/kernfs.xml:28
msgid "Creating Initial Device Nodes"
msgstr "创建初始设备节点"

#. type: Content of: <sect1><sect2><para>
#: lfs-en/chapter06/kernfs.xml:30
msgid ""
"When the kernel boots the system, it requires the presence of a few device "
"nodes, in particular the <filename class=\"devicefile\">console</filename> "
"and <filename class=\"devicefile\">null</filename> devices. The device nodes "
"must be created on the hard disk so that they are available before "
"<command>udevd</command> has been started, and additionally when Linux is "
"started with <parameter>init=/bin/bash</parameter>. Create the devices by "
"running the following commands:"
msgstr ""
"在内核引导系统时，它需要一些设备节点，特别是 <filename class=\"devicefile\">console</filename> 和 <"
"filename class=\"devicefile\">null</filename> 两个设备。它们需要创建在硬盘上，这样在 "
"<command>udevd</command> 启动前即可使用，特别是在 Linux 使用 "
"<parameter>init=/bin/bash</parameter> 内核选项启动的时候。运行以下命令创建它们："

#. type: Content of: <sect1><sect2><screen>
#: lfs-en/chapter06/kernfs.xml:39
#, no-wrap
msgid ""
"<userinput>mknod -m 600 $LFS/dev/console c 5 1\n"
"mknod -m 666 $LFS/dev/null c 1 3</userinput>"
msgstr ""
"<userinput>mknod -m 600 $LFS/dev/console c 5 1\n"
"mknod -m 666 $LFS/dev/null c 1 3</userinput>"

#. type: Content of: <sect1><sect2><title>
#: lfs-en/chapter06/kernfs.xml:45
msgid "Mounting and Populating /dev"
msgstr "挂载和填充 /dev"

#. type: Content of: <sect1><sect2><para>
#: lfs-en/chapter06/kernfs.xml:47
msgid ""
"The recommended method of populating the <filename "
"class=\"directory\">/dev</filename> directory with devices is to mount a "
"virtual filesystem (such as <systemitem "
"class=\"filesystem\">tmpfs</systemitem>) on the <filename "
"class=\"directory\">/dev</filename> directory, and allow the devices to be "
"created dynamically on that virtual filesystem as they are detected or "
"accessed. Device creation is generally done during the boot process by "
"Udev. Since this new system does not yet have Udev and has not yet been "
"booted, it is necessary to mount and populate <filename "
"class=\"directory\">/dev</filename> manually. This is accomplished by bind "
"mounting the host system's <filename class=\"directory\">/dev</filename> "
"directory. A bind mount is a special type of mount that allows you to create "
"a mirror of a directory or mount point to some other location. Use the "
"following command to achieve this:"
msgstr ""
"用设备文件填充 <filename class=\"directory\">/dev</filename> 目录的推荐方法是挂载一个虚拟文件系统 (例如 "
"<systemitem class=\"filesystem\">tmpfs</systemitem>) 到 <filename class=\""
"directory\">/dev</filename>， 然后在设备被发现或访问时动态地创建设备文件。这个工作通常由 Udev 在系统引导时完成。然而，"
"我们的新系统还没有 Udev，也没有被引导过，因此必须手工挂载和填充 <filename class=\"directory\""
">/dev</filename>。这可以通过绑定挂载宿主系统的 <filename class=\"directory\">/dev</filename>"
" 目录就实现。绑定挂载是一种特殊挂载类型， 它允许在另外的位置创建某个目录或挂载点的映像。运行以下命令进行绑定挂载："

#. type: Content of: <sect1><sect2><screen>
#: lfs-en/chapter06/kernfs.xml:62
#, no-wrap
msgid "<userinput>mount -v --bind /dev $LFS/dev</userinput>"
msgstr "<userinput>mount -v --bind /dev $LFS/dev</userinput>"

#. type: Content of: <sect1><sect2><title>
#: lfs-en/chapter06/kernfs.xml:67
msgid "Mounting Virtual Kernel File Systems"
msgstr "挂载虚拟内核文件系统"

#. type: Content of: <sect1><sect2><para>
#: lfs-en/chapter06/kernfs.xml:69
msgid "Now mount the remaining virtual kernel filesystems:"
msgstr "现在挂载其余的虚拟内核文件系统："

#. type: Content of: <sect1><sect2><screen>
#: lfs-en/chapter06/kernfs.xml:71
#, no-wrap
msgid ""
"<userinput>mount -vt devpts devpts $LFS/dev/pts -o gid=5,mode=620\n"
"mount -vt proc proc $LFS/proc\n"
"mount -vt sysfs sysfs $LFS/sys\n"
"mount -vt tmpfs tmpfs $LFS/run</userinput>"
msgstr ""
"<userinput>mount -vt devpts devpts $LFS/dev/pts -o gid=5,mode=620\n"
"mount -vt proc proc $LFS/proc\n"
"mount -vt sysfs sysfs $LFS/sys\n"
"mount -vt tmpfs tmpfs $LFS/run</userinput>"

#. type: Content of: <sect1><sect2><variablelist><title>
#: lfs-en/chapter06/kernfs.xml:77
msgid "The meaning of the mount options for devpts:"
msgstr "devpts 挂载选项的含义："

#. type: Content of: <sect1><sect2><variablelist><varlistentry><term>
#: lfs-en/chapter06/kernfs.xml:80
msgid "<parameter>gid=5</parameter>"
msgstr "<parameter>gid=5</parameter>"

#. type: Content of: <sect1><sect2><variablelist><varlistentry><listitem><para>
#: lfs-en/chapter06/kernfs.xml:82
msgid ""
"This ensures that all devpts-created device nodes are owned by group ID 5.  "
"This is the ID we will use later on for the <systemitem "
"class=\"groupname\">tty</systemitem> group.  We use the group ID instead of "
"a name, since the host system might use a different ID for its <systemitem "
"class=\"groupname\">tty</systemitem> group."
msgstr ""
"这保证 devpts 创建的所有设备节点都属于 ID 为 5 的组。  我们之后会把这个 ID 分配给 <systemitem class=\""
"groupname\"> tty</systemitem> 组。  这里使用组 ID 而不是名称，因为宿主系统的 <systemitem class=\""
"groupname\">tty</systemitem> 组可能有不同的 ID。"

#. type: Content of: <sect1><sect2><variablelist><varlistentry><term>
#: lfs-en/chapter06/kernfs.xml:91
msgid "<parameter>mode=0620</parameter>"
msgstr "<parameter>mode=0620</parameter>"

#. type: Content of: <sect1><sect2><variablelist><varlistentry><listitem><para>
#: lfs-en/chapter06/kernfs.xml:93
msgid ""
"This ensures that all devpts-created device nodes have mode 0620 (user "
"readable and writable, group writable).  Together with the option above, "
"this ensures that devpts will create device nodes that meet the requirements "
"of grantpt(), meaning the Glibc <command>pt_chown</command> helper binary "
"(which is not installed by default) is not necessary."
msgstr ""
"该选项确保 devpts 创建的所有设备节点具有权限码 0620 (所有者可读写，组成员可写)。  与上一个选项结合使用， 可以保证 devpts "
"创建符合 grantpt() 要求的设备节点，摆脱对 Glibc <command>pt_chown</command> 辅助程序 (默认不安装) "
"的依赖。"

#. type: Content of: <sect1><sect2><para>
#: lfs-en/chapter06/kernfs.xml:104
msgid ""
"In some host systems, <filename>/dev/shm</filename> is a symbolic link to "
"<filename class=\"directory\">/run/shm</filename>.  The /run tmpfs was "
"mounted above so in this case only a directory needs to be created."
msgstr ""
"在某些宿主系统上，<filename>/dev/shm</filename> 是一个指向 <filename class=\"directory\""
">/run/shm</filename> 的符号链接。  我们已经在 /run 下挂载了 tmpfs 文件系统，因此在这里只需要创建一个目录。"

#. type: Content of: <sect1><sect2><screen>
#: lfs-en/chapter06/kernfs.xml:109
#, no-wrap
msgid ""
"<userinput>if [ -h $LFS/dev/shm ]; then\n"
"  mkdir -pv $LFS/$(readlink $LFS/dev/shm)\n"
"fi</userinput>"
msgstr ""
"<userinput>if [ -h $LFS/dev/shm ]; then\n"
"  mkdir -pv $LFS/$(readlink $LFS/dev/shm)\n"
"fi</userinput>"
