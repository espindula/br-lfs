# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-11-17 02:18+0000\n"
"PO-Revision-Date: 2022-09-21 05:47+0000\n"
"Last-Translator: roptat <julien@lepiller.eu>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"
"X-Generator: Pootle 2.8\n"
"X-POOTLE-MTIME: 1663739252.604020\n"

#. type: Content of: <sect1><title>
#: lfs-en/chapter07/kernfs.xml:11
msgid "Preparing Virtual Kernel File Systems"
msgstr "Préparer les systèmes de fichiers virtuels du noyau"

#. type: Content of: <sect1><indexterm><primary>
#: lfs-en/chapter07/kernfs.xml:14
msgid "/dev/*"
msgstr "/dev/*"

#. type: Content of: <sect1><para>
#: lfs-en/chapter07/kernfs.xml:17
#, fuzzy
#| msgid ""
#| "Various file systems exported by the kernel are used to communicate to "
#| "and from the kernel itself. These file systems are virtual in that no "
#| "disk space is used for them. The content of the file systems resides in "
#| "memory."
msgid ""
"Applications running in user space utilize various file systems created by "
"the kernel to communicate with the kernel itself. These file systems are "
"virtual: no disk space is used for them. The content of these file systems "
"resides in memory. These file systems must be mounted in the $LFS directory "
"tree so the applications can find them in the chroot environment."
msgstr ""
"Différents systèmes de fichiers exportés par le noyau sont utilisés pour "
"communiquer avec le noyau lui-même. Ces systèmes de fichiers sont virtuels "
"du fait qu'aucun espace disque n'est utilisé pour eux. Le contenu de ces "
"systèmes de fichiers réside en mémoire."

#. type: Content of: <sect1><para>
#: lfs-en/chapter07/kernfs.xml:24
#, fuzzy
#| msgid ""
#| "Begin by creating directories onto which the file systems will be mounted:"
msgid ""
"Begin by creating the directories on which these virtual file systems will "
"be mounted:"
msgstr ""
"Commencez en créant les répertoires dans lesquels les systèmes de fichiers "
"seront montés&nbsp;:"

#. type: Content of: <sect1><screen>
#: lfs-en/chapter07/kernfs.xml:27
#, no-wrap
msgid "<userinput>mkdir -pv $LFS/{dev,proc,sys,run}</userinput>"
msgstr "<userinput>mkdir -pv $LFS/{dev,proc,sys,run}</userinput>"

#. type: Content of: <sect1><sect2><title>
#: lfs-en/chapter07/kernfs.xml:30
msgid "Mounting and Populating /dev"
msgstr "Monter et peupler /dev"

#. type: Content of: <sect1><sect2><para>
#: lfs-en/chapter07/kernfs.xml:32
#, fuzzy
#| msgid ""
#| "During a normal boot, the kernel automatically mounts the <systemitem "
#| "class=\"filesystem\">devtmpfs</systemitem> filesystem on the <filename "
#| "class=\"directory\">/dev</filename> directory, and allow the devices to "
#| "be created dynamically on that virtual filesystem as they are detected or "
#| "accessed. Device creation is generally done during the boot process by "
#| "the kernel and Udev.  Since this new system does not yet have Udev and "
#| "has not yet been booted, it is necessary to mount and populate <filename "
#| "class=\"directory\">/dev</filename> manually. This is accomplished by "
#| "bind mounting the host system's <filename class=\"directory\">/dev</"
#| "filename> directory. A bind mount is a special type of mount that allows "
#| "you to create a mirror of a directory or mount point to some other "
#| "location. Use the following command to achieve this:"
msgid ""
"During a normal boot of an LFS system, the kernel automatically mounts the "
"<systemitem class=\"filesystem\">devtmpfs</systemitem> file system on the "
"<filename class=\"directory\">/dev</filename> directory; the kernel creates "
"device nodes on that virtual file system during the boot process, or when a "
"device is first detected or accessed. The udev daemon may change the "
"ownership or permissions of the device nodes created by the kernel, and "
"create new device nodes or symlinks, to ease the work of distro maintainers "
"and system administrators.  (See <xref linkend='ch-config-udev-device-node-"
"creation'/> for details.)  If the host kernel supports &devtmpfs;, we can "
"simply mount a &devtmpfs; at <filename class='directory'>$LFS/dev</filename> "
"and rely on the kernel to populate it (i.e., the udev daemon will do the "
"necessary work automatically)."
msgstr ""
"Lors d'un démarrage normal, le noyau monte automatiquement le système de "
"fichiers <systemitem class=\"filesystem\">devtmpfs</systemitem> sur le "
"répertoire <filename class=\"directory\">/dev</filename> et permet la "
"création dynamique de périphériques sur ce système de fichiers virtuel quand "
"ils sont détectés ou demandés.  La création de périphériques au démarrage "
"est généralement faite par le noyau et Udev. Comme ce nouveau système ne "
"contient pas encore Udev et n'a pas encore été démarré, il est nécessaire de "
"monter et de remplir <filename class=\"directory\">/dev</filename> "
"manuellement. Cela se fait en montant en double le répertoire <filename "
"class=\"directory\">/dev</filename> du système hôte. Le montage en double "
"est un type spécial de montage qui vous permet de créer le miroir d'un "
"répertoire ou d'un point de montage à un autre endroit. Utilisez la commande "
"suivante pour réaliser cela&nbsp;:"

#. type: Content of: <sect1><sect2><para>
#: lfs-en/chapter07/kernfs.xml:47
#, fuzzy
#| msgid ""
#| "During a normal boot, the kernel automatically mounts the <systemitem "
#| "class=\"filesystem\">devtmpfs</systemitem> filesystem on the <filename "
#| "class=\"directory\">/dev</filename> directory, and allow the devices to "
#| "be created dynamically on that virtual filesystem as they are detected or "
#| "accessed. Device creation is generally done during the boot process by "
#| "the kernel and Udev.  Since this new system does not yet have Udev and "
#| "has not yet been booted, it is necessary to mount and populate <filename "
#| "class=\"directory\">/dev</filename> manually. This is accomplished by "
#| "bind mounting the host system's <filename class=\"directory\">/dev</"
#| "filename> directory. A bind mount is a special type of mount that allows "
#| "you to create a mirror of a directory or mount point to some other "
#| "location. Use the following command to achieve this:"
msgid ""
"But some host kernels lack &devtmpfs; support; these host distros use "
"different methods to create the content of <filename class=\"directory\">/"
"dev</filename>.  So the only host-agnostic way to populate the <filename "
"class=\"directory\">$LFS/dev</filename> directory is by bind mounting the "
"host system's <filename class=\"directory\">/dev</filename> directory. A "
"bind mount is a special type of mount that generates a duplicate copy of a "
"directory or mount point at some other location. Use the following command "
"to do this."
msgstr ""
"Lors d'un démarrage normal, le noyau monte automatiquement le système de "
"fichiers <systemitem class=\"filesystem\">devtmpfs</systemitem> sur le "
"répertoire <filename class=\"directory\">/dev</filename> et permet la "
"création dynamique de périphériques sur ce système de fichiers virtuel quand "
"ils sont détectés ou demandés.  La création de périphériques au démarrage "
"est généralement faite par le noyau et Udev. Comme ce nouveau système ne "
"contient pas encore Udev et n'a pas encore été démarré, il est nécessaire de "
"monter et de remplir <filename class=\"directory\">/dev</filename> "
"manuellement. Cela se fait en montant en double le répertoire <filename "
"class=\"directory\">/dev</filename> du système hôte. Le montage en double "
"est un type spécial de montage qui vous permet de créer le miroir d'un "
"répertoire ou d'un point de montage à un autre endroit. Utilisez la commande "
"suivante pour réaliser cela&nbsp;:"

#. type: Content of: <sect1><sect2><screen>
#: lfs-en/chapter07/kernfs.xml:58
#, no-wrap
msgid "<userinput>mount -v --bind /dev $LFS/dev</userinput>"
msgstr "<userinput>mount -v --bind /dev $LFS/dev</userinput>"

#. type: Content of: <sect1><sect2><title>
#: lfs-en/chapter07/kernfs.xml:63
msgid "Mounting Virtual Kernel File Systems"
msgstr "Monter les systèmes de fichiers virtuels du noyau"

#. type: Content of: <sect1><sect2><para>
#: lfs-en/chapter07/kernfs.xml:65
#, fuzzy
#| msgid "Now mount the remaining virtual kernel filesystems:"
msgid "Now mount the remaining virtual kernel file systems:"
msgstr ""
"Montez maintenant les systèmes de fichiers virtuels du noyau restants&nbsp;:"

#. type: Content of: <sect1><sect2><screen>
#: lfs-en/chapter07/kernfs.xml:67
#, no-wrap
msgid ""
"<userinput>mount -v --bind /dev/pts $LFS/dev/pts\n"
"mount -vt proc proc $LFS/proc\n"
"mount -vt sysfs sysfs $LFS/sys\n"
"mount -vt tmpfs tmpfs $LFS/run</userinput>"
msgstr ""
"<userinput>mount -v --bind /dev/pts $LFS/dev/pts\n"
"mount -vt proc proc $LFS/proc\n"
"mount -vt sysfs sysfs $LFS/sys\n"
"mount -vt tmpfs tmpfs $LFS/run</userinput>"

#. type: Content of: <sect1><sect2><para>
#: lfs-en/chapter07/kernfs.xml:100
msgid ""
"In some host systems, <filename>/dev/shm</filename> is a symbolic link to "
"<filename class=\"directory\">/run/shm</filename>.  The /run tmpfs was "
"mounted above so in this case only a directory needs to be created."
msgstr ""
"Dans certains systèmes hôtes, <filename>/dev/shm</filename> est un lien "
"symbolique vers <filename class=\"directory\">/run/shm</filename>. Le tmpfs /"
"run a été monté tout à l'heure, donc vous ne devez créer un répertoire que "
"dans ce cas précis."

#. type: Content of: <sect1><sect2><para>
#: lfs-en/chapter07/kernfs.xml:105
#, fuzzy
#| msgid ""
#| "In other cases <filename>/dev/shm</filename> is a mountpoint for a tmpfs. "
#| "In that case the mount of /dev above will only create /dev/shm in the "
#| "chroot environment as a directory. In this situation we explicitly mount "
#| "a tmpfs,"
msgid ""
"In other host systems <filename>/dev/shm</filename> is a mount point for a "
"tmpfs. In that case the mount of /dev above will only create /dev/shm as a "
"directory in the chroot environment. In this situation we must explicitly "
"mount a tmpfs:"
msgstr ""
"Dans d'autres cas <filename>/dev/shm</filename> est un point de montage pour "
"un tmpfs. Dans ce cas le montage de /dev ci-dessus ne créera /dev/shm "
"uniquement dans l'environnement chroot en tant que répertoire. Dans cette "
"situtation, nous montons explicitement un tmpfs."

#. type: Content of: <sect1><sect2><screen>
#: lfs-en/chapter07/kernfs.xml:110
#, no-wrap
msgid ""
"<userinput>if [ -h $LFS/dev/shm ]; then\n"
"  mkdir -pv $LFS/$(readlink $LFS/dev/shm)\n"
"else\n"
"  mount -t tmpfs -o nosuid,nodev tmpfs $LFS/dev/shm\n"
"fi</userinput>"
msgstr ""
"<userinput>if [ -h $LFS/dev/shm ]; then\n"
"  mkdir -pv $LFS/$(readlink $LFS/dev/shm)\n"
"else\n"
"  mount -t tmpfs -o nosuid,nodev tmpfs $LFS/dev/shm\n"
"fi</userinput>"

#~ msgid "Creating Initial Device Nodes"
#~ msgstr "Création des nœuds initiaux vers les périphériques"

#~ msgid ""
#~ "When the kernel boots the system, it requires the presence of a few "
#~ "device nodes, in particular the <filename class=\"devicefile\">console</"
#~ "filename> and <filename class=\"devicefile\">null</filename> devices. The "
#~ "device nodes must be created on the hard disk so that they are available "
#~ "before the kernel populates <systemitem class=\"filesystem\">/dev</"
#~ "systemitem>), and additionally when Linux is started with "
#~ "<parameter>init=/bin/bash</parameter>. Create the devices by running the "
#~ "following commands:"
#~ msgstr ""
#~ "Quand le noyau démarre le système, il a besoin de la présence de quelques "
#~ "fichiers de périphériques, en particulier les périphériques <filename "
#~ "class=\"devicefile\">console</filename> et <filename "
#~ "class=\"devicefile\">null</filename>. Les nœuds de périphérique doivent "
#~ "être créés sur le disque dur afin d'être disponible avant que le noyau ne "
#~ "remplisse <systemitem class=\"filesystem\">/dev</systemitem>, et aussi "
#~ "quand Linux est démarré avec <parameter>init=/bin/bash</parameter>. Créez "
#~ "les périphériques en exécutant les commandes suivantes&nbsp;:"

#~ msgid ""
#~ "<userinput>mknod -m 600 $LFS/dev/console c 5 1\n"
#~ "mknod -m 666 $LFS/dev/null c 1 3</userinput>"
#~ msgstr ""
#~ "<userinput>mknod -m 600 $LFS/dev/console c 5 1\n"
#~ "mknod -m 666 $LFS/dev/null c 1 3</userinput>"

#~ msgid "The meaning of the mount options for devpts:"
#~ msgstr "Voici la signification des options de montage de devpts&nbsp;:"

#~ msgid "<parameter>gid=5</parameter>"
#~ msgstr "<parameter>gid=5</parameter>"

#~ msgid ""
#~ "This ensures that all devpts-created device nodes are owned by group ID "
#~ "5.  This is the ID we will use later on for the <systemitem "
#~ "class=\"groupname\">tty</systemitem> group.  We use the group ID instead "
#~ "of a name, since the host system might use a different ID for its "
#~ "<systemitem class=\"groupname\">tty</systemitem> group."
#~ msgstr ""
#~ "Cela garantit que tous les n&oelig;uds de périphérique créés par devpts "
#~ "appartiennent au groupe dont l'ID est 5. C'est l'ID que nous utiliserons "
#~ "plus tard pour le groupe <systemitem class=\"groupname\">tty</"
#~ "systemitem>.  Nous utilisons l'ID de groupe au lieu du nom, car il se "
#~ "pourrait que le système hôte utilise un ID différent pour son groupe "
#~ "<systemitem class=\"groupname\">tty</systemitem>."

#~ msgid "<parameter>mode=0620</parameter>"
#~ msgstr "<parameter>mode=0620</parameter>"

#~ msgid ""
#~ "This ensures that all devpts-created device nodes have mode 0620 (user "
#~ "readable and writable, group writable).  Together with the option above, "
#~ "this ensures that devpts will create device nodes that meet the "
#~ "requirements of grantpt(), meaning the Glibc <command>pt_chown</command> "
#~ "helper binary (which is not installed by default) is not necessary."
#~ msgstr ""
#~ "Cela garantit que tous les n&oelig;uds de périphérique créés par devpts "
#~ "ont le mode 0620 (lecture et écriture par l'utilisateur, écriture par le "
#~ "groupe). Combinée à l'option ci-dessus, cela garantit que devts créera "
#~ "des n&oelig;uds de périphérique correspondant aux exigences de grantpt(), "
#~ "c'est-à-dire que le binaire d'aide <command>pt_chown</command> de Glibc "
#~ "(qui n'est pas installé par défaut) n'est pas nécessaire."
