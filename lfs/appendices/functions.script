#!/bin/sh
########################################################################
# Begin $rc_base/init.d/functions
#
# Description : Run Level Control Functions
#
# Authors     : Gerard Beekmans - gerard@linuxfromscratch.org
#
# Version     : 00.00
#
# Notes       : With code based on Matthias Benkmann&apos;s simpleinit-msb
#        http://winterdrache.de/linux/newboot/index.html
#
########################################################################

## Environmental setup
# Setup default values for environment
umask 022
export PATH=&quot;/bin:/usr/bin:/sbin:/usr/sbin&quot;

# Signal sent to running processes to refresh their configuration
RELOADSIG=&quot;HUP&quot;

# Number of seconds between STOPSIG and FALLBACK when stopping processes
KILLDELAY=&quot;3&quot;

## Screen Dimensions
# Find current screen size
if [ -z &quot;${COLUMNS}&quot; ]; then
    COLUMNS=$(stty size)
    COLUMNS=${COLUMNS##* }
fi

# When using remote connections, such as a serial port, stty size returns 0
if [ &quot;${COLUMNS}&quot; = &quot;0&quot; ]; then 
    COLUMNS=80
fi

## Measurements for positioning result messages
COL=$((${COLUMNS} - 8))
WCOL=$((${COL} - 2))

## Provide an echo that supports -e and -n
# If formatting is needed, $ECHO should be used
case &quot;`echo -e -n test`&quot; in
    -[en]*)
        ECHO=/bin/echo
        ;;
    *)
        ECHO=echo
        ;;
esac

## Set Cursor Position Commands, used via $ECHO
SET_COL=&quot;\\033[${COL}G&quot;      # at the $COL char
SET_WCOL=&quot;\\033[${WCOL}G&quot;    # at the $WCOL char
CURS_UP=&quot;\\033[1A\\033[0G&quot;   # Up one line, at the 0&apos;th char

## Set color commands, used via $ECHO
# Please consult `man console_codes for more information
# under the &quot;ECMA-48 Set Graphics Rendition&quot; section
#
# Warning: when switching from a 8bit to a 9bit font,
# the linux console will reinterpret the bold (1;) to
# the top 256 glyphs of the 9bit font.  This does
# not affect framebuffer consoles
NORMAL=&quot;\\033[0;39m&quot;         # Standard console grey
SUCCESS=&quot;\\033[1;32m&quot;        # Success is green
WARNING=&quot;\\033[1;33m&quot;        # Warnings are yellow
FAILURE=&quot;\\033[1;31m&quot;        # Failures are red
INFO=&quot;\\033[1;36m&quot;           # Information is light cyan
BRACKET=&quot;\\033[1;34m&quot;        # Brackets are blue

STRING_LENGTH=&quot;0&quot;   # the length of the current message

#*******************************************************************************
# Function - boot_mesg()
#
# Purpose:      Sending information from bootup scripts to the console
#
# Inputs:       $1 is the message
#               $2 is the colorcode for the console
#
# Outputs:      Standard Output
#
# Dependencies: - sed for parsing strings.
#            - grep for counting string length.
#               
# Todo:         
#*******************************************************************************
boot_mesg()
{
    local ECHOPARM=&quot;&quot;

    while true
    do
        case &quot;${1}&quot; in
            -n)
                ECHOPARM=&quot; -n &quot;
                shift 1
                ;;
            -*)
                echo &quot;Unknown Option: ${1}&quot;
                return 1
                ;;
            *)
                break
                ;;
        esac
    done

    ## Figure out the length of what is to be printed to be used
    ## for warning messages. 
    STRING_LENGTH=$((${#1} + 1))

    # Print the message to the screen
    ${ECHO} ${ECHOPARM} -e &quot;${2}${1}&quot;
    
}

boot_mesg_flush()
{
    # Reset STRING_LENGTH for next message
    STRING_LENGTH=&quot;0&quot;
}

boot_log()
{
    # Left in for backwards compatibility
    :
}

echo_ok()
{
    ${ECHO} -n -e &quot;${CURS_UP}${SET_COL}${BRACKET}[${SUCCESS}  OK  ${BRACKET}]&quot;
    ${ECHO} -e &quot;${NORMAL}&quot;
        boot_mesg_flush
}

echo_failure()
{
    ${ECHO} -n -e &quot;${CURS_UP}${SET_COL}${BRACKET}[${FAILURE} FAIL ${BRACKET}]&quot;
    ${ECHO} -e &quot;${NORMAL}&quot;
        boot_mesg_flush
}

echo_warning()
{
    ${ECHO} -n -e &quot;${CURS_UP}${SET_COL}${BRACKET}[${WARNING} WARN ${BRACKET}]&quot;
    ${ECHO} -e &quot;${NORMAL}&quot;
        boot_mesg_flush
}

print_error_msg()
{
    echo_failure
    # $i is inherited by the rc script
    boot_mesg -n &quot;FAILURE:\n\nYou should not be reading this error message.\n\n&quot; ${FAILURE}
    boot_mesg -n &quot; It means that an unforeseen error took&quot;
    boot_mesg -n &quot; place in ${i}, which exited with a return value of&quot;
    boot_mesg &quot; ${error_value}.\n&quot;
    boot_mesg_flush
    boot_mesg -n &quot;If you&apos;re able to track this&quot;
    boot_mesg -n &quot; error down to a bug in one of the files provided by&quot;
    boot_mesg -n &quot; the LFS book, please be so kind to inform us at&quot;
    boot_mesg &quot; lfs-dev@linuxfromscratch.org.\n&quot;
    boot_mesg_flush
    boot_mesg -n &quot;Press Enter to continue...&quot; ${INFO}
    boot_mesg &quot;&quot; ${NORMAL}
    read ENTER
}

check_script_status()
{
    # $i is inherited by the rc script
    if [ ! -f ${i} ]; then
        boot_mesg &quot;${i} is not a valid symlink.&quot; ${WARNING}
        echo_warning
        continue
    fi

    if [ ! -x ${i} ]; then
        boot_mesg &quot;${i} is not executable, skipping.&quot; ${WARNING}
        echo_warning
        continue
    fi
}

evaluate_retval()
{
    error_value=&quot;${?}&quot;

    if [ ${error_value} = 0 ]; then
        echo_ok
    else
        echo_failure
    fi

    # This prevents the &apos;An Unexpected Error Has Occurred&apos; from trivial
    # errors.
    return 0
}

print_status()
{
    if [ &quot;${#}&quot; = &quot;0&quot; ]; then
        echo &quot;Usage: ${0} {success|warning|failure}&quot;
        return 1
    fi

    case &quot;${1}&quot; in

        success)
            echo_ok
            ;;

        warning)
            # Leave this extra case in because old scripts
            # may call it this way.
            case &quot;${2}&quot; in
                running)
                    ${ECHO} -e -n &quot;${CURS_UP}&quot;
                    ${ECHO} -e -n &quot;\\033[${STRING_LENGTH}G   &quot;
                    boot_mesg &quot;Already running.&quot; ${WARNING}
                    echo_warning
                    ;;
                not_running)
                    ${ECHO} -e -n &quot;${CURS_UP}&quot;
                    ${ECHO} -e -n &quot;\\033[${STRING_LENGTH}G   &quot;
                    boot_mesg &quot;Not running.&quot; ${WARNING}
                    echo_warning
                    ;;
                not_available)
                    ${ECHO} -e -n &quot;${CURS_UP}&quot;
                    ${ECHO} -e -n &quot;\\033[${STRING_LENGTH}G   &quot;
                    boot_mesg &quot;Not available.&quot; ${WARNING}
                    echo_warning
                    ;;
                *)
                    # This is how it is supposed to
                    # be called
                    echo_warning
                    ;;
            esac
        ;;

        failure)
            echo_failure
        ;;

    esac

}

reloadproc()
{
    local pidfile=&quot;&quot;
    local failure=0

    while true
    do
        case &quot;${1}&quot; in
            -p)
                pidfile=&quot;${2}&quot;
                shift 2
                ;;
            -*)
                log_failure_msg &quot;Unknown Option: ${1}&quot;
                return 2
                ;;
            *)
                break
                ;;
        esac
    done

    if [ &quot;${#}&quot; -lt &quot;1&quot; ]; then
        log_failure_msg &quot;Usage: reloadproc [-p pidfile] pathname&quot;
        return 2
    fi

    # This will ensure compatibility with previous LFS Bootscripts
    if [ -n &quot;${PIDFILE}&quot; ];    then
        pidfile=&quot;${PIDFILE}&quot;
    fi

    # Is the process running?
    if [ -z &quot;${pidfile}&quot; ];    then
        pidofproc -s &quot;${1}&quot;
    else
        pidofproc -s -p &quot;${pidfile}&quot; &quot;${1}&quot;
    fi

    # Warn about stale pid file
    if [ &quot;$?&quot; = 1 ]; then
        boot_mesg -n &quot;Removing stale pid file: ${pidfile}. &quot; ${WARNING}
        rm -f &quot;${pidfile}&quot;
    fi

    if [ -n &quot;${pidlist}&quot; ];    then
        for pid in ${pidlist}
        do
            kill -&quot;${RELOADSIG}&quot; &quot;${pid}&quot; || failure=&quot;1&quot;
        done

        (exit ${failure})
        evaluate_retval

    else
        boot_mesg &quot;Process ${1} not running.&quot; ${WARNING}
        echo_warning
    fi
}

statusproc()
{
    local pidfile=&quot;&quot;
    local base=&quot;&quot;
    local ret=&quot;&quot;

    while true
    do
        case &quot;${1}&quot; in
            -p)
                pidfile=&quot;${2}&quot;
                shift 2
                ;;
            -*)
                log_failure_msg &quot;Unknown Option: ${1}&quot;
                return 2
                ;;
            *)
                break
                ;;
        esac
    done

    if [ &quot;${#}&quot; != &quot;1&quot; ]; then
        shift 1
        log_failure_msg &quot;Usage: statusproc [-p pidfile] pathname&quot;
        return 2
    fi

    # Get the process basename
    base=&quot;${1##*/}&quot;

    # This will ensure compatibility with previous LFS Bootscripts
    if [ -n &quot;${PIDFILE}&quot; ];    then
        pidfile=&quot;${PIDFILE}&quot;
    fi

    # Is the process running?
    if [ -z &quot;${pidfile}&quot; ];    then
        pidofproc -s &quot;${1}&quot;
    else
        pidofproc -s -p &quot;${pidfile}&quot; &quot;${1}&quot;
    fi

    # Store the return status
    ret=$?

    if [ -n &quot;${pidlist}&quot; ];    then
        ${ECHO} -e &quot;${INFO}${base} is running with Process&quot;\
            &quot;ID(s) ${pidlist}.${NORMAL}&quot;
    else
        if [ -n &quot;${base}&quot; -a -e &quot;/var/run/${base}.pid&quot; ]; then
            ${ECHO} -e &quot;${WARNING}${1} is not running but&quot;\
                &quot;/var/run/${base}.pid exists.${NORMAL}&quot;
        else
            if [ -n &quot;${pidfile}&quot; -a -e &quot;${pidfile}&quot; ]; then
                ${ECHO} -e &quot;${WARNING}${1} is not running&quot;\
                    &quot;but ${pidfile} exists.${NORMAL}&quot;
            else
                ${ECHO} -e &quot;${INFO}${1} is not running.${NORMAL}&quot;
            fi
        fi
    fi

    # Return the status from pidofproc
    return $ret
}

# The below functions are documented in the LSB-generic 2.1.0

#*******************************************************************************
# Function - pidofproc [-s] [-p pidfile] pathname
#
# Purpose: This function returns one or more pid(s) for a particular daemon
#
# Inputs: -p pidfile, use the specified pidfile instead of pidof
#         pathname, path to the specified program
#
# Outputs: return 0 - Success, pid&apos;s in stdout
#          return 1 - Program is dead, pidfile exists
#          return 2 - Invalid or excessive number of arguments, 
#                     warning in stdout
#          return 3 - Program is not running
#
# Dependencies: pidof, echo, head
#
# Todo: Remove dependency on head
#       This depreciates getpids
#       Test changes to pidof
#
#*******************************************************************************
pidofproc()
{
    local pidfile=&quot;&quot;
    local lpids=&quot;&quot;
    local silent=&quot;&quot;
    pidlist=&quot;&quot;
    while true
    do
        case &quot;${1}&quot; in
            -p)
                pidfile=&quot;${2}&quot;
                shift 2
                ;;

            -s)
                # Added for legacy opperation of getpids
                # eliminates several &apos;&gt; /dev/null&apos;
                silent=&quot;1&quot;
                shift 1
                ;;
            -*)
                log_failure_msg &quot;Unknown Option: ${1}&quot;
                return 2
                ;;
            *)
                break
                ;;
        esac
    done

    if [ &quot;${#}&quot; != &quot;1&quot; ]; then
        shift 1
        log_failure_msg &quot;Usage: pidofproc [-s] [-p pidfile] pathname&quot;
        return 2
    fi

    if [ -n &quot;${pidfile}&quot; ]; then
        if [ ! -r &quot;${pidfile}&quot; ]; then
            return 3 # Program is not running
        fi

        lpids=`head -n 1 ${pidfile}`
        for pid in ${lpids}
        do
            if [ &quot;${pid}&quot; -ne &quot;$$&quot; -a &quot;${pid}&quot; -ne &quot;${PPID}&quot; ]; then
                kill -0 &quot;${pid}&quot; 2&gt;/dev/null &amp;&amp;
                pidlist=&quot;${pidlist} ${pid}&quot;
            fi
            
            if [ &quot;${silent}&quot; != &quot;1&quot; ]; then
                echo &quot;${pidlist}&quot;
            fi

            test -z &quot;${pidlist}&quot; &amp;&amp; 
            # Program is dead, pidfile exists
            return 1
            # else
            return 0
        done

    else
        pidlist=`pidof -o $$ -o $PPID -x &quot;$1&quot;`
        if [ &quot;${silent}&quot; != &quot;1&quot; ]; then
            echo &quot;${pidlist}&quot;
        fi

        # Get provide correct running status
        if [ -n &quot;${pidlist}&quot; ]; then
            return 0
        else
            return 3
        fi

    fi

    if [ &quot;$?&quot; != &quot;0&quot; ]; then
        return 3 # Program is not running
    fi
}

# This will ensure compatibility with previous LFS Bootscripts
getpids()
{
    if [ -z &quot;${PIDFILE}&quot; ]; then
        pidofproc -s -p &quot;${PIDFILE}&quot; $@
    else
        pidofproc -s $@
    fi
    base=&quot;${1##*/}&quot;
}

#*******************************************************************************
# Function - loadproc [-f] [-n nicelevel] [-p pidfile] pathname [args]
#
# Purpose: This runs the specified program as a daemon
#
# Inputs: -f, run the program even if it is already running
#         -n nicelevel, specifies a nice level. See nice(1).
#         -p pidfile, uses the specified pidfile
#         pathname, pathname to the specified program
#         args, arguments to pass to specified program
#
# Outputs: return 0 - Success
#          return 2 - Invalid of excessive number of arguments, 
#                     warning in stdout
#          return 4 - Program or service status is unknown
#
# Dependencies: nice, rm
#
# Todo: LSB says this should be called start_daemon
#       LSB does not say that it should call evaluate_retval
#       It checks for PIDFILE, which is deprecated.
#         Will be removed after BLFS 6.0
#       loadproc returns 0 if program is already running, not LSB compliant
#
#*******************************************************************************
loadproc()
{
    local pidfile=&quot;&quot;
    local forcestart=&quot;&quot;
    local nicelevel=&quot;10&quot;

# This will ensure compatibility with previous LFS Bootscripts
    if [ -n &quot;${PIDFILE}&quot; ];    then
        pidfile=&quot;${PIDFILE}&quot;
    fi

  while true
    do
        case &quot;${1}&quot; in
            -f)
                forcestart=&quot;1&quot;
                shift 1
                ;;
            -n)
                nicelevel=&quot;${2}&quot;
                shift 2
                ;;
            -p)
                pidfile=&quot;${2}&quot;
                shift 2
                ;;
            -*)
                log_failure_msg &quot;Unknown Option: ${1}&quot;
                return 2 #invalid or excess argument(s)
                ;;
            *)
                break
                ;;
        esac
    done

    if [ &quot;${#}&quot; = &quot;0&quot; ]; then
        log_failure_msg &quot;Usage: loadproc [-f] [-n nicelevel] [-p pidfile] pathname [args]&quot;
        return 2 #invalid or excess argument(s)
    fi

    if [ -z &quot;${forcestart}&quot; ]; then
        if [ -z &quot;${pidfile}&quot; ];    then
            pidofproc -s &quot;${1}&quot;
        else
            pidofproc -s -p &quot;${pidfile}&quot; &quot;${1}&quot;
        fi

        case &quot;${?}&quot; in
            0)
                log_warning_msg &quot;Unable to continue: ${1} is running&quot;
                return 0 # 4
                ;;
            1)
                boot_mesg &quot;Removing stale pid file: ${pidfile}&quot; ${WARNING}
                rm -f &quot;${pidfile}&quot;
                ;;
            3)
                ;;
            *)
                log_failure_msg &quot;Unknown error code from pidofproc: ${?}&quot;
                return 4
                ;;
        esac
    fi

    nice -n &quot;${nicelevel}&quot; &quot;${@}&quot;
    evaluate_retval # This is &quot;Probably&quot; not LSB compliant, but required to be compatible with older bootscripts
    return 0
}

#*******************************************************************************
# Function - killproc  [-p pidfile] pathname [signal]
#
# Purpose:
#
# Inputs: -p pidfile, uses the specified pidfile
#         pathname, pathname to the specified program
#         signal, send this signal to pathname
#
# Outputs: return 0 - Success
#          return 2 - Invalid of excessive number of arguments, 
#                     warning in stdout
#          return 4 - Unknown Status
#
# Dependencies: kill, rm
#
# Todo: LSB does not say that it should call evaluate_retval
#       It checks for PIDFILE, which is deprecated.
#         Will be removed after BLFS 6.0
#
#*******************************************************************************
killproc()
{
    local pidfile=&quot;&quot;
    local killsig=TERM # default signal is SIGTERM
    pidlist=&quot;&quot;

    # This will ensure compatibility with previous LFS Bootscripts
    if [ -n &quot;${PIDFILE}&quot; ];    then
        pidfile=&quot;${PIDFILE}&quot;
    fi

    while true
    do
        case &quot;${1}&quot; in
            -p)
                pidfile=&quot;${2}&quot;
                shift 2
                ;;
            -*)
                log_failure_msg &quot;Unknown Option: ${1}&quot;
                return 2
                ;;
            *)
                 break
                ;;
        esac
    done

    if [ &quot;${#}&quot; = &quot;2&quot; ]; then
        killsig=&quot;${2}&quot;
    elif [ &quot;${#}&quot; != &quot;1&quot; ];    then
        shift 2
        log_failure_msg &quot;Usage: killproc  [-p pidfile] pathname [signal]&quot;
        return 2
    fi

    # Is the process running?
    if [ -z &quot;${pidfile}&quot; ];    then
        pidofproc -s &quot;${1}&quot;
    else
        pidofproc -s -p &quot;${pidfile}&quot; &quot;${1}&quot;
    fi

    # Remove stale pidfile
    if [ &quot;$?&quot; = 1 ]; then
        boot_mesg &quot;Removing stale pid file: ${pidfile}.&quot; ${WARNING}
        rm -f &quot;${pidfile}&quot;
    fi

    # If running, send the signal
    if [ -n &quot;${pidlist}&quot; ]; then
    for pid in ${pidlist}
    do
        kill -${killsig} ${pid} 2&gt;/dev/null

        # Wait up to 3 seconds, for ${pid} to terminate
        case &quot;${killsig}&quot; in
        TERM|SIGTERM|KILL|SIGKILL)
            # sleep in 1/10ths of seconds and
            # multiply KILLDELAY by 10
            local dtime=&quot;${KILLDELAY}0&quot;
            while [ &quot;${dtime}&quot; != &quot;0&quot; ]
            do
                kill -0 ${pid} 2&gt;/dev/null || break
                sleep 0.1
                dtime=$(( ${dtime} - 1))
            done
            # If ${pid} is still running, kill it
            kill -0 ${pid} 2&gt;/dev/null &amp;&amp; kill -KILL ${pid} 2&gt;/dev/null
            ;;
        esac
    done

    # Check if the process is still running if we tried to stop it
    case &quot;${killsig}&quot; in
    TERM|SIGTERM|KILL|SIGKILL)
        if [ -z &quot;${pidfile}&quot; ];    then
            pidofproc -s &quot;${1}&quot;
        else
            pidofproc -s -p &quot;${pidfile}&quot; &quot;${1}&quot;
        fi

        # Program was terminated
        if [ &quot;$?&quot; != &quot;0&quot; ]; then
            # Remove the pidfile if necessary
            if [ -f &quot;${pidfile}&quot; ];    then
                rm -f &quot;${pidfile}&quot;
            fi
            echo_ok
            return 0
        else # Program is still running
            echo_failure
            return 4 # Unknown Status
        fi
        ;;
    *)
        # Just see if the kill returned successfully
        evaluate_retval
        ;;
    esac
    else # process not running
    print_status warning not_running
    fi
}


#*******************************************************************************
# Function - log_success_msg &quot;message&quot;
#
# Purpose: Print a success message
#
# Inputs: $@ - Message
#
# Outputs: Text output to screen
#
# Dependencies: echo
#
# Todo: logging
#
#*******************************************************************************
log_success_msg()
{
    ${ECHO} -n -e &quot;${BOOTMESG_PREFIX}${@}&quot;
    ${ECHO} -e &quot;${SET_COL}&quot;&quot;${BRACKET}&quot;&quot;[&quot;&quot;${SUCCESS}&quot;&quot;  OK  &quot;&quot;${BRACKET}&quot;&quot;]&quot;&quot;${NORMAL}&quot;
    return 0
}

#*******************************************************************************
# Function - log_failure_msg &quot;message&quot;
#
# Purpose: Print a failure message
#
# Inputs: $@ - Message
#
# Outputs: Text output to screen
#
# Dependencies: echo
#
# Todo: logging
#
#*******************************************************************************
log_failure_msg() {
    ${ECHO} -n -e &quot;${BOOTMESG_PREFIX}${@}&quot;
    ${ECHO} -e &quot;${SET_COL}&quot;&quot;${BRACKET}&quot;&quot;[&quot;&quot;${FAILURE}&quot;&quot; FAIL &quot;&quot;${BRACKET}&quot;&quot;]&quot;&quot;${NORMAL}&quot;
    return 0
}

#*******************************************************************************
# Function - log_warning_msg &quot;message&quot;
#
# Purpose: print a warning message
#
# Inputs: $@ - Message
#
# Outputs: Text output to screen
#
# Dependencies: echo
#
# Todo: logging
#
#*******************************************************************************
log_warning_msg() {
    ${ECHO} -n -e &quot;${BOOTMESG_PREFIX}${@}&quot;
    ${ECHO} -e &quot;${SET_COL}&quot;&quot;${BRACKET}&quot;&quot;[&quot;&quot;${WARNING}&quot;&quot; WARN &quot;&quot;${BRACKET}&quot;&quot;]&quot;&quot;${NORMAL}&quot;
    return 0
}

# End $rc_base/init.d/functions
