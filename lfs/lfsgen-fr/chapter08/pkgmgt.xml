<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
  "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../general.ent">
  %general-entities;
]>

<sect1 id="ch-system-pkgmgt">
  <?dbhtml filename="pkgmgt.html"?>

  <title>Gestion de paquets</title>

  <para>La gestion de paquets est un ajout souvent demandé au livre LFS. Un
gestionnaire de paquets permet de conserver une trace des fichiers
installés, simplifiant ainsi leur suppression ou leur mise à jour. Un
gestionnaire de paquets gérera tant les fichiers binaires et de bibliothèque
que l'installation des fichiers de configuration. Avant tout,
NON&mdash;cette section ne parle pas d'un gestionnaire de paquets
particulier, elle n'en recommande pas non plus. Elle fait un tour des
techniques les plus populaires pour indiquer comment elles fonctionnent. Le
parfait gestionnaire de paquets pourrait faire partie de ces techniques ou
pourrait être une combinaison d'une ou plusieurs techniques. Cette section
mentionne brièvement les problèmes pouvant survenir lors de la mise à jour
des paquets.</para>

  <para>Parmi les raisons de l'absence d'un gestionnaire de paquets mentionné dans
LFS ou BLFS&nbsp;:</para>

  <itemizedlist>
    <listitem>
      <para>S'occuper de la gestion de paquets est en dehors des buts de ces
livres&mdash; visant à apprendre comment un système Linux est construit.</para>
    </listitem>

    <listitem>
      <para>Il existe de nombreuses solutions pour la gestion de paquets, chacune ayant
ses forces et ses faiblesses. En inclure une qui satisfait tout le monde est
difficile.</para>
    </listitem>
  </itemizedlist>

  <para>Des astuces ont été écrites sur le thème de la gestion de paquets. Visitez
le <ulink url="&hints-root;">Projet des astuces</ulink> et voyez celui qui
satisfait vos besoins.</para>

  <sect2 id='pkgmgmt-upgrade-issues'>
    <title>Problèmes de mise à jour</title>

    <para>Un gestionnaire de paquets facilite la mise à jour des nouvelles versions au
moment de leur sortie. Généralement, les instructions dans les livres LFS et
BLFS peuvent être utilisées pour mettre à jour vers de nouvelles
versions. Voici quelques points à connaître pour une mise à jour de paquets,
spécifiquement sur un système en cours de fonctionnement.</para>

    <itemizedlist>
      <listitem>
        <para>Si le noyau Linux doit être mis à jour (par exemple de 5.10.17 à 5.10.18 ou
5.11.1), rien d'autre n'a besoin d'être reconstruit. Le système continuera
de fonctionner grâce à l'interface bien définie entre le noyau et l'espace
utilisateur. En particulier, les en-têtes de l'API de Linux n'ont pas besoin
d'être mises à jour (et ne devraient pas l'être, voir le point suivant) avec
le noyau. Vous devrez redémarrer votre système pour utiliser le noyau à
jour.</para>
      </listitem>

      <listitem>
        <para>Si les en-têtes de l'API Linux doivent être mis à jour vers une nouvelle
version, il est plus sûr de reconstruire LFS.  Bien que vous
<emphasis>pourriez</emphasis> être capable de ne pas reconstruire tous les
paquets dans leur ordre de dépendances, nous ne vous le recommandons pas.  </para>
      </listitem>

      <listitem> <para>Si un paquet contenant une bibliothèque partagée est mis à jour et si le nom
de cette dernière est modifié, alors les paquets liés dynamiquement à la
bibliothèque devront être recompilés pour être liés à la nouvelle
bibliothèque. Remarquez qu'il n'y a aucune corrélation entre la version du
paquet et le nom de la bibliothèque. Par exemple, considérez un paquet
foo-1.2.3 qui installe une bibliothèque partagée de nom <filename
class='libraryfile'>libfoo.so.1</filename>.  Disons que vous mettez à jour
le paquet avec une nouvelle version foo-1.2.4 qui installe une bibliothèque
partagée de nom <filename class='libraryfile'>libfoo.so.2</filename>. Dans
ce cas, tous les paquets liés dynamiquement à <filename
class='libraryfile'>libfoo.so.1</filename> doivent être recompilés pour être
liés à <filename class='libraryfile'>libfoo.so.2</filename>. Vous ne devez
pas supprimer les anciennes bibliothèques jusqu'à ce que les paquets
indépendants soient recompilés.</para>
      </listitem>

      <listitem> <para>Si vous mettez à jour un paquet qui contient une bibliothèque partagée, et
que le nom de la bibliothèque ne change pas, mais que le numéro de version
du <emphasis role="bold">fichier</emphasis> de la bibliothèque décroît (par
exemple le nom reste <filename class='libraryfile'>libfoo.so.1</filename>,
mais le nom du fichier de la bibliothèque change de <filename
class='libraryfile'>libfoo.so.1.25</filename> à <filename
class='libraryfile'>libfoo.so.1.24</filename>), vous devrez supprimer le
fichier de bibliothèque de la version précédente (<filename
class='libraryfile'>libfoo.so.1.25</filename> dans ce cas). Sinon, en
lançant <command>ldconfig</command> (par vous-même via la ligne de commande,
ou par l'installation d'un paquet) vous réinitialiserez le lien symbolique
<filename class='libraryfile'>libfoo.so.1</filename> vers l'ancien fichier
de bibliothèque parce qu'il a une version <quote>plus récente</quote>,
puisque le numéro est plus grand. Cette situation arrive quand vous
installez une version précédente d'un paquet, ou que le paquet change de
pratique de nommage des versions.</para> </listitem>

      <listitem> <para>Si un paquet contenant une bibliothèque partagée est mis à jour, et que le
nom de la bibliothèque ne change pas, mais qu'un problème important (en
particulier une vulnérabilité de sécurité) est corrigé, tous les programmes
en cours d'exécution liés à la bibliothèque partagée doivent être
redémarrés. La commande suivante, lancée en <systemitem
class="username">root</systemitem> après la mise à jour, affichera ce qui
utilise les anciennes versions de ces bibliothèques (remplacez
<replaceable>libfoo</replaceable> par le nom de la bibliothèque)&nbsp;:</para>

<screen><userinput role="nodump">grep -l  -e '<replaceable>libfoo</replaceable>.*deleted' /proc/*/maps |
   tr -cd 0-9\\n | xargs -r ps u</userinput></screen>

      <para>
        Si <application>OpenSSH</application> est utilisé pour accéder au système et
qu'il est lié à la bibliothèque mise à jour, vous devrez redémarrer le
service <command>sshd</command>, vous déconnecter, vous reconnecter et
relancer la commande pour confirmer que plus rien n'utilise encore les
bibliothèques supprimées.
      </para></listitem>

      <listitem>
        <para>Si un binaire ou une bibliothèque partagée est remplacé, les processus
utilisant le code ou les données du binaire ou de la bibliothèque peuvent
crasher. La manière correcte de mettre à jour un binaire ou une bibliothèque
partagée sans causer de crash de processus est de le ou la supprimer
d'abord, puis d'installer la nouvelle version. La commande
<command>install</command> fournie par <application>Coreutils</application>
implémente déjà cela et la plupart des paquets l'utilisent pour installer
des binaires et des bibliothèques. Cela signifie que vous n'aurez pas ce
problème la plupart du temps. Cependant, le processus d'installation de
certains paquets (notamment Mozilla JS dans BLFS) se contentent de réécrire
par dessus le fichier s'il existe déjà et cause un crash, donc il est plus
prudent de sauvegarder votre travail et de fermer les processus inutiles
avant de mettre à jour un paquet.</para>
      </listitem>
    </itemizedlist>

  </sect2>

  <sect2>
    <title>Techniques de gestion de paquets</title>

    <para>Ce qui suit est une liste de techniques habituelles de gestion de
paquets. Avant de prendre une décision sur un gestionnaire de paquets,
faites une recherche sur les différentes techniques et notamment leurs
faiblesses.</para>

    <sect3>
      <title>Tout est dans ma tête&nbsp;!</title>

      <para>Oui, c'est une technique de gestion de paquets. Certains n'éprouvent pas le
besoin d'un gestionnaire de paquets parce qu'ils connaissent très bien les
paquets et connaissent les fichiers installés par chaque paquet. Certains
utilisateurs n'en ont pas besoin parce qu'ils planifient la reconstruction
entière de LFS lorsqu'un paquet est modifié.</para>

    </sect3>

    <sect3>
      <title>Installer dans des répertoires séparés</title>

      <para>C'est une gestion des paquets tellement simple qu'elle ne nécessite aucun
paquet supplémentaire pour gérer les installations. Chaque paquet est
installé dans un répertoire séparé. Par exemple, le paquet foo-1.1 est
installé dans <filename class='directory'>/usr/pkg/foo-1.1</filename> et un
lien symbolique est créé de <filename>/usr/pkg/foo</filename> vers <filename
class='directory'>/usr/pkg/foo-1.1</filename>. Lors de l'installation de la
nouvelle version foo-1.2, elle est installée dans <filename
class='directory'>/usr/pkg/foo-1.2</filename> et l'ancien lien symbolique
est remplacé par un lien symbolique vers la nouvelle version.</para>

      <para>Les variables d'environnement telles que <envar>PATH</envar>,
<envar>LD_LIBRARY_PATH</envar>, <envar>MANPATH</envar>,
<envar>INFOPATH</envar> et <envar>CPPFLAGS</envar> ont besoin d'être
étendues pour inclure <filename>/usr/pkg/foo</filename>. Pour plus de
quelques paquets, ce schéma devient ingérable.</para>

    </sect3>

    <sect3>
      <title>Gestion de paquet par lien symbolique</title>

      <para>C'est une variante de la technique précédente. Chaque paquet est installé de
façon similaire au schéma précédent. Mais au lieu de réaliser le lien
symbolique, chaque fichier dispose d'un lien symbolique vers son équivalent
dans la hiérarchie <filename class='directory'>/usr</filename>. Ceci
supprime le besoin d'étendre les variables d'environnement. Bien que les
liens symboliques peuvent être créés par l'utilisateur, pour automatiser la
création, certains gestionnaires de paquets ont été écrits avec cette
approche. Parmi les plus populaires se trouvent Stow, Epkg, Graft et Depot.</para>

      <para>L'installation doit être faussée, de façon à ce que chaque paquet pense
qu'il est installé dans <filename class="directory">/usr</filename> alors
qu'en réalité il est installé dans la hiérarchie <filename
class="directory">/usr/pkg</filename>.  Installer de cette manière n'est
généralement pas une tâche triviale. Par exemple, considérez que vous
installez un paquet libfoo-1.1. Les instructions suivantes pourraient ne pas
installer correctement le paquet&nbsp;:</para>

<screen role="nodump"><userinput>./configure --prefix=/usr/pkg/libfoo/1.1
make
make install</userinput></screen>

      <para>L'installation fonctionnera, mais les paquets dépendants pourraient ne pas
lier libfoo comme vous vous y attendriez. Si vous compilez un paquet qui se
lie à <filename
class='libraryfile'>/usr/pkg/libfoo/1.1/lib/libfoo.so.1</filename> au lieu
de <filename class='libraryfile'>/usr/lib/libfoo.so.1</filename> comme vous
le prévoyez. La bonne approche est d'utiliser la stratégie
<envar>DESTDIR</envar> pour fausser l'installation du paquet. Cette approche
fonctionne ainsi&nbsp;:</para>

<screen role="nodump"><userinput>./configure --prefix=/usr
make
make DESTDIR=/usr/pkg/libfoo/1.1 install</userinput></screen>

      <para>La plupart des paquets prennent en charge cette approche, mais elle pose
problème à certains. Pour les paquets non compatibles, vous pouvez soit les
installer manuellement soit trouver plus simple d'installer les paquets
problématiques dans <filename class='directory'>/opt</filename>.</para>

    </sect3>

    <sect3>
      <title>Basé sur le temps</title>

      <para>Avec cette technique, un fichier est balisé avec l'heure avant
l'installation du paquet. Après l'installation, une simple utilisation de la
commande <command>find</command> avec les options appropriées peut générer
une trace de tous les fichiers installés après que le fichier temps a été
créé.  install-log est un gestionnaire de paquets écrit avec cette approche.</para>

      <para>Bien que ce schéma a l'avantage d'être simple, il a deux inconvénients. Si à
l'installation, les fichiers sont installés sans balise de temps autre que
l'heure actuelle, ces fichiers ne seront pas suivis par le gestionnaire de
paquets. De plus, ce schéma peut seulement être utilisé lorsqu'un seul
paquet est installé à la fois. Les traces ne sont pas fiables si deux
paquets sont installés dans deux consoles différentes.</para>

    </sect3>

    <sect3>
      <title>Tracer les scripts d'installation</title>

      <para>Avec cette approche, les commandes que les scripts d'installation
accomplissent sont enregistrées. Il y a deux techniques que vous pouvez
utiliser&nbsp;:</para>

      <para>Vous pouvez initialiser la variable d'environnement
<envar>LD_PRELOAD</envar> pour qu'elle pointe vers une bibliothèque à
précharger avant l'installation.  Lors de l'utilisation de cette dernière,
cette bibliothèque trace les paquets en cours d'installation en s'attachant
eux-mêmes aux différents exécutables comme <command>cp</command>,
<command>install</command>, <command>mv</command> et trace les appels
système qui modifient le système de fichiers. Pour que cette approche
fonctionne, tous les exécutables ont besoin d'être liés dynamiquement sans
bit suid ou sgid. Le préchargement de la bibliothèque pourrait causer
quelques effets de bord involontaires lors de l'installation&nbsp;; donc,
réalisez quelques tests pour vous assurer que le gestionnaire de paquets ne
casse rien et trace bien tous les fichiers appropriés.</para>

      <para>La seconde technique est d’utiliser <command>strace</command>, qui trace
tous les appels du système faits pendant l'exécution des scripts
d'installation.</para>
    </sect3>

    <sect3>
      <title>Créer des archives de paquets</title>

      <para>Dans ce schéma, l'installation d'un paquet est faussée dans un répertoire
séparé comme décrit plus haut. Après l'installation, une archive du paquet
est créée en utilisant les fichiers installés.  L'archive est ensuite
utilisée pour installer le paquet soit sur la machine locale soit même sûr
d'autres machines.</para>

      <para>Cette approche est utilisée par la plupart des gestionnaires de paquets
trouvés dans les distributions commerciales. Les exemples de gestionnaires
qui suivent cette approche sont RPM (qui est parfois requis par la <ulink
url="http://refspecs.linuxfoundation.org/lsb.shtml">Spécification de base de
Linux Standard</ulink>), pkg-utils, apt de Debian, et le système de portage
de Gentoo. Une astuce décrivant comment adopter ce style de gestion de
paquets pour les systèmes LFS se trouve à <ulink
url="http://www.fr.linuxfromscratch.org/view/astuces/fakeroot-fr.txt"/>.</para>

      <para>La création de fichiers de paquet qui incluent des informations de
dépendance est complexe et va au-delà de l'objectif de LFS.</para>

      <para>Slackware utilise un système basé sur <command>tar</command> pour les
archives de paquets. Ce système ne gère volontairement pas les dépendances
de paquets car d'autres gestionnaires de paquets plus complexes le
font. Pour des détails sur la gestion de paquets, voir <ulink
url="http://www.slackbook.org/html/package-management.html"/>.</para>
    </sect3>

    <sect3>
      <title>Gestion basée sur les utilisateurs</title>

      <para>Cette méthode, unique à LFS, a été décrite par Matthias Benkmann et est
disponible sur le <ulink url="&hints-root;">Projet des astuces</ulink>. Dans
cette méthode, chaque paquet est installé en tant qu'utilisateur séparé dans
les emplacements standards. Les fichiers appartenant à un paquet sont
facilement identifiés grâce à l'identifiant de l'utilisateur. Les avantages
et inconvénients de cette approche sont trop complexes pour les décrire dans
cette section. Pour plus de détails, voir l'astuce sur <ulink
url="http://www.fr.linuxfromscratch.org/view/astuces/gestionnaire-paquets-utilisateur.txt"/>.</para>

    </sect3>

  </sect2>

  <sect2>
    <title>Déployer LFS sur plusieurs systèmes</title>

    <para>Un des avantages du système LFS est qu'il n'y a pas de fichiers dépendant de
la position des fichiers sur un système de disque. Cloner la construction
d'un système LFS sur un autre ordinateur avec une architecture similaire au
système de base est aussi facile que l'utilisation de <command>tar</command>
sur la partition LFS qui contient le répertoire racine (environ 250Mo
décompressés pour une construction LFS de base), en copiant ce fichier via
un transfert par réseau ou par CD-ROM vers le nouveau système et en le
décompressant. À partir de là, vous devrez modifier quelques fichiers de
configuration. Les fichiers de configuration que vous pouvez devoir mettre à
jour comprennent&nbsp;: <filename>/etc/hosts</filename>,
<filename>/etc/fstab</filename>, <filename>/etc/passwd</filename>,
<filename>/etc/group</filename>, <phrase revision="systemd">
<filename>/etc/shadow</filename> et
<filename>/etc/ld.so.conf</filename>. </phrase> <phrase revision="sysv">
<filename>/etc/shadow</filename>, <filename>/etc/ld.so.conf</filename>,
<filename>/etc/sysconfig/rc.site</filename>,
<filename>/etc/sysconfig/network</filename> et
<filename>/etc/sysconfig/ifconfig.eth0</filename>. </phrase>
    </para>

    <para>Vous pouvez construire un noyau personnalisé pour le nouveau système, selon
les différences du matériel du système avec la configuration du noyau
initial.</para>

    <note><para>Il y a eu quelques rapports de problèmes lors de la copie entre
architectures similaires mais non identiques. Par exemple, l'ensemble
d'instructions pour l'architecture Intel n'est pas identique avec celle pour
un processeur AMD et les versions plus récentes de certains processeurs
peuvent avoir des instructions qui ne sont pas disponibles pour des versions
antérieures.</para></note>

    <para>Enfin, vous devez rendre le nouveau système amorçable via <xref
linkend="ch-bootable-grub"/>.</para>

  </sect2>

</sect1>
