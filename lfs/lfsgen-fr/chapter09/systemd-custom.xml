<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
  "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../general.ent">
  %general-entities;
]>

<sect1 id="ch-config-systemd-custom" revision="systemd">
  <?dbhtml filename="systemd-custom.html"?>

  <title>Utilisation et configuration de Systemd</title>

  <indexterm zone="ch-config-systemd-custom">
    <primary sortas="e-Systemd">Personnalisation de Systemd</primary>
  </indexterm>

  <sect2>
    <title>Configuration basique</title>

    <para>Le fichier <filename>/etc/systemd/system.conf</filename> contient un
ensemble d'options pour contrôler les opérations de base de systemd. Le
fichier par défaut a toutes ses entrées commentées indiquant les paramètres
par défaut. Ce fichier est l'endroit où le niveau de journalisation (log)
peut être modifié ainsi que les paramètres de base de journalisation. Voir
la page de manuel de <filename>systemd-system.conf(5)</filename> pour plus
de détails à propos de chaque option de configuration.</para>

  </sect2>

  <sect2>
    <title>Désactiver l'effacement de l'écran durant le démarrage</title>

    <para>Le comportement normal de systemd est d'effacer l'écran à la fin de la
séquence de démarrage. Si désiré, ce comportement peut être changé en
exécutant la commande suivante&nbsp;:</para>

<screen role="nodump"><userinput>mkdir -pv /etc/systemd/system/getty@tty1.service.d

cat &gt; /etc/systemd/system/getty@tty1.service.d/noclear.conf &lt;&lt; EOF
<literal>[Service]
TTYVTDisallocate=no</literal>
EOF</userinput></screen>

    <para>Les messages de démarrage peuvent toujours être examinés en utilisant la
commande <userinput>journalctl -b</userinput> en tant qu'utilisateur
<systemitem class="username">root</systemitem>.</para>

  </sect2>

  <sect2>
    <title>Désactiver tmpfs pour /tmp</title>

    <para>Par défaut, <filename class="directory">/tmp</filename> est créé comme un
tmpfs. Si vous ne le voulez pas, il est possible de l'en empêcher de la
manière suivante&nbsp;:</para>

<screen role="nodump"><userinput>ln -sfv /dev/null /etc/systemd/system/tmp.mount</userinput></screen>

    <para>Autrement, si vous souhaitez avoir une partition séparée pour <filename
class="directory">/tmp</filename>, spécifiez-la dans une entrée de
<filename>/etc/fstab</filename>.</para>

    <warning>
      <para>
        Ne créez pas le lien symbolique ci-dessus si vous utilisez une partition
séparée pour <filename class="directory">/tmp</filename>. Cela empêche la
partition racine (/) d'être remontée en lecture-écriture et rend le système
inutilisable au démarrage.
      </para>
    </warning>

  </sect2>

  <sect2>
    <title>Configurer la création et la suppression automatique de fichiers</title>

    <para>Il existe de nombreux services pour créer ou supprimer des fichiers ou des
dossiers&nbsp;:</para>

    <itemizedlist>
      <listitem><para>systemd-tmpfiles-clean.service</para></listitem>
      <listitem><para>systemd-tmpfiles-setup-dev.service</para></listitem>
      <listitem><para>systemd-tmpfiles-setup.service</para></listitem>
    </itemizedlist>
  
    <para>L'emplacement système des fichiers de configuration est
<filename>/usr/lib/tmpfiles.d/*.conf</filename>. Les fichiers locaux de
configuration sont dans <filename
class="directory">/etc/tmpfiles.d</filename>. Les fichiers dans <filename
class="directory">/etc/tmpfiles.d</filename> prévallent sur les fichiers du
même nom dans <filename
class="directory">/usr/lib/tmpfiles.d</filename>. Voir la page de manuel
<filename>tmpfiles.d(5)</filename> pour plus de détails sur le format de
fichier.</para>

    <para>
      Remarquez que la syntaxe pour les fichiers
<filename>/usr/lib/tmpfiles.d/*.conf</filename> peut être déroutante. Par
exemple, la suppression de fichiers par défaut dans le répertoire /tmp se
trouve dans <filename>/usr/lib/tmpfiles.d/tmp.conf</filename> à cette
ligne&nbsp;: <screen role="nodump">q /tmp 1777 root root 10d</screen>. Le champ type, q, parle de
créer un sous-volume avec des quotas, ce qui n'est vraiment possible que
pour les système de fichiers btrfs. Il référence le type v qui lui-même
référence le type d (répertoire). Cela crée ensuite le répertoire spécifié
s'il n'est pas présent et ajuste ensuite les permissions et la propriété
comme indiqué. Le contenu du répertoire sera sujet au nettoyage basé sur
l'âge si l'argument d'âge est spécifié.
     </para>

     <para>
      Si les paramètres par défaut ne sont pas désirés, alors vous devrez copier
le fichier vers <filename class="directory">/etc/tmpfiles.d</filename> et le
modifier comme vous le voulez. Par exemple&nbsp;: <screen role="nodump"><userinput>mkdir -p /etc/tmpfiles.d
cp /usr/lib/tmpfiles.d/tmp.conf /etc/tmpfiles.d</userinput></screen>
     </para>

  </sect2>

  <sect2>
    <title>Redéfinition des comportements par défaut des services</title>

    <para>Les paramètres d’une unité peuvent être redéfinis en créant un dossier et un
fichier de configuration dans <filename
class="directory">/etc/systemd/system</filename>. Par exemple&nbsp;:</para>

<screen role="nodump"><userinput>mkdir -pv /etc/systemd/system/foobar.service.d

cat > /etc/systemd/system/foobar.service.d/foobar.conf &lt;&lt; EOF
<literal>[Service]
Restart=always
RestartSec=30</literal>
EOF</userinput></screen>

     <para>Voir la page de manuel <filename>systemd.unit(5)</filename> pour plus
d'informations. Après la création du fichier de configuration, exécutez
<userinput>systemctl daemon-reload</userinput> et <userinput>systemctl
restart foobar</userinput> pour activer les changements à un service.</para>

  </sect2>

  <sect2>
    <title>Débogage de la séquence de démarrage</title>

    <para>Plutôt que des scripts shell utilisés par les systèmes d’init du style de
SysVinit ou BSD, systemd utilise un format unifié pour différents types de
fichiers de démarrage (ou unités). La commande <command>systemctl</command>
est utilisée pour activer, désactiver, contrôler l’état et obtenir le statut
d’un fichier d’unité. Voici quelques exemples de commandes fréquentes&nbsp;:</para>

    <itemizedlist>
       <listitem>
         <para><command>systemctl list-units -t <replaceable>&lt;service&gt;</replaceable>
[--all]</command>: liste les fichiers d’unité chargés de type service.</para>
       </listitem>
       <listitem>
         <para><command>systemctl list-units -t <replaceable>&lt;target&gt;</replaceable>
[--all]</command>: liste les fichiers d’unité chargés de type target.</para>
       </listitem>
       <listitem>
         <para><command>systemctl show -p Wants
<replaceable>&lt;multi-user.target&gt;</replaceable></command>&nbsp;: montre
toutes les unités qui dépendent de la cible multi-user. Les cibles sont des
fichiers d’unité spéciaux qui sont analogues aux niveaux d’exécution de
SysVinit.</para>
       </listitem>
       <listitem>
         <para><command>systemctl status
<replaceable>&lt;servicename.service&gt;</replaceable></command>: montre le
statut du service servicename. L’extension .service peut être omise s’il n’y
a pas d’autres fichiers d’unité portant le même nom, comme des fichiers
.socket (qui créent un socket en écoute qui fourni les même fonctionnalités
qu'inetd/xinetd).</para>
       </listitem>
    </itemizedlist>

  </sect2>

  <sect2>
    <title>Utiliser le journal Systemd</title>

    <para>La journalisation d’un système démarré avec systemd est géré par
systemd-journald (par défaut), plutôt qu’un démon syslog unix typique. Vous
pouvez aussi ajouter un démon syslog normal et faire travailler les deux
côte à côte si vous le souhaitez. Le programme systemd-journald stocke les
entrées du journal dans un format binaire plutôt que dans un fichier en
texte brut. La commande <command>journalctl</command> est fournie pour aider
à analyser le fichier. Voici quelques exemples de commandes usuelles&nbsp;:</para>

    <itemizedlist>
       <listitem>
         <para><command>journalctl -r</command>&nbsp;: montre tout le contenu du journal en
sens chronologique inverse.</para>
       </listitem>
       <listitem>
         <para><command>journalctl -u <replaceable>UNIT</replaceable></command>&nbsp;:
montre les entrées du journal associées avec le fichier UNIT spécifié.</para>
       </listitem>
       <listitem>
         <para><command>journalctl -b[=ID] -r</command>&nbsp;: montre les entrées du
journal depuis le dernier démarrage réussi (ou pour le démarrage
d’identifiant ID) en sens chronologique inverse.</para>
       </listitem>
       <listitem>
         <para><command>journalctl -f</command>&nbsp;: fournit une fonctionnalité similaire
à tail -f (suivre).</para>
       </listitem>
    </itemizedlist>

  </sect2>

  <sect2>
    <title>Travailler avec les core dumps</title>

    <para>Les «&nbsp;core dumps&nbsp;» sont utiles pour déboguer des programmes
crashés, surtout quand un processus démon plante. Sur un système démarré
avec systemd, les core dumps sont gérés par
<command>systemd-coredump</command>. Il enregistrera le core dump das le
journal et stockera le fichier core dans <filename
class="directory">/var/lib/systemd/coredump</filename>. Pour récupérer et
utiliser le fichier core, système fourni l'outil
<command>coredumpctl</command>. Voici quelques exemples de commandes
fréquentes&nbsp;:
    </para>

    <itemizedlist>
      <listitem>
        <para><command>coredumpctl -r</command>&nbsp;: montre tous les core dumps en ordre
chronologique inverse.</para>
      </listitem>
      <listitem>
        <para><command>coredumpctl -1 info</command>&nbsp;: montre les informations du
dernier core dump.</para>
      </listitem>
      <listitem>
        <para><command>coredumpctl -1 debug</command>&nbsp;: charge le dernier core dump
dans <ulink url="&blfs-book;general/gdb.html">GDB</ulink>.
        </para>
      </listitem>
    </itemizedlist>

    <para>Les core dumps peuvent utiliser beaucoup d'espace disque. L'espace disque
maximal utilisé par les core dumps se limite en créant un fichier de
configuration dans <filename
class="directory">/etc/systemd/coredump.conf.d</filename>. Par
exemple&nbsp;:</para>

<screen role="nodump"><userinput>mkdir -pv /etc/systemd/coredump.conf.d

cat &gt; /etc/systemd/coredump.conf.d/maxuse.conf &lt;&lt; EOF
<literal>[Coredump]
MaxUse=5G</literal>
EOF</userinput></screen>

    <para>Voir les pages de manuel <filename>systemd-coredump(8)</filename>,
<filename>coredumpctl(1)</filename>, and
<filename>coredump.conf.d(5)</filename> pour plus d'information.</para>
  </sect2>

  <sect2>
    <title>Processus lancés durablement</title>

    <para>Depuis la version systemd-230, tous les processus utilisateurs sont tués
lorsque la session utilisateur se termine, même en utilisant nohup, ou que
le processus utilise les fonctions <function>daemon()</function> ou
<function>setsid()</function>. Ceci est un changement délibéré par rapport à
un environnement historiquement plus permissif vers un environnement plus
restrictif. Le nouveau comportement peut causer des problèmes si vous
dépendez de programmes lancés durablement (par exemple,
<command>screen</command> ou <command>tmux</command>) qui restent actifs
après la fin de votre session utilisateur. Il y a trois moyens de permettre
la persistance des processus après la fin d'une session utilisateur.</para>

    <itemizedlist>
      <listitem>
        <para>
          <emphasis>N'activez les processus persistants que pour les utilisateurs qui
en ont besoin</emphasis>&nbsp;: les utilisateurs ont la possibilité
d'activer les processus persistants avec la commande <command>loginctl
enable-linger</command> pour eux-mêmes. Les administrateurs systèmes peuvent
utiliser la même commande avec un argument
<parameter>utilisateur</parameter> pour les activer pour un utilisateur. Cet
utilisateur peut alors utiliser la commande <command>systemd-run</command>
pour débuter une tâche durable. Par exemple&nbsp;: <command>systemd-run
--scope --user /usr/bin/screen</command>. Si vous souhaitez activer les
tâches durables pour votre utilisateur, le service user@.service sera
toujours présent même après la fermeture de toutes les sessions, et
démarrera automatiquement au démarrage du système. Ceci a l'avantage
d'autoriser et d'interdire explicitement aux programmes de s'exécuter après
que la session utilisateur est fermée, mais cela casse la
rétro-compatibilité avec des outils comme <command>nohup</command> et les
utilitaires qui utilisent <function>daemon()</function>.
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis>Activer les processus persistant sur tout le
système</emphasis>&nbsp;: vous pouvez définir
<parameter>KillUserProcesses=no</parameter> dans
<filename>/etc/systemd/logind.conf</filename> pour autoriser globalement la
persistance pour tous les utilisateurs. Ceci a l'avantage de laisser
disponibles les vieilles méthodes à tous les utilisateurs au prix de la
perte de contrôle explicite.
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis>Désactiver à la construction</emphasis>&nbsp;: vous pouvez
autoriser les processus persistants par défaut pendant la construction de
systemd en ajoutant le paramètre
<parameter>-Ddefault-kill-user-processes=false</parameter> à la commande
<command>meson</command> de systemd. Ceci désactive complètement la capacité
que systemd a de tuer les processus utilisateurs à la fin de la session.
        </para>
      </listitem>
    </itemizedlist>

  </sect2>

</sect1>
