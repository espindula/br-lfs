<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
  "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../general.ent">
  %general-entities;
]>

<sect1 id="ch-config-udev">
  <?dbhtml filename="udev.html"?>

  <title>Manipulation des périphériques et modules</title>

  <indexterm zone="ch-config-udev">
    <primary sortas="a-Udev">Udev</primary>
    <secondary>utilisation</secondary>
  </indexterm>

  <para>Au <xref linkend="chapter-building-system"/>, nous avons installé le paquet
udev en construisant <phrase revision="sysv">eudev</phrase> <phrase
revision="systemd">systemd</phrase>. Avant d'entrer dans les détails
concernant son fonctionnement, un bref historique des méthodes précédentes
de gestion des périphériques est nécessaire.</para>

  <para>Traditionnellement, les systèmes Linux utilisaient une méthode de création
de périphériques statiques avec laquelle un grand nombre de nœuds de
périphériques étaient créés sous <filename class="directory">/dev</filename>
(quelques fois littéralement des milliers de nœuds), que le matériel
correspondant existait ou non.  Ceci était fait le plus souvent avec un
script <command>MAKEDEV</command>, qui contient des appels au programme
<command>mknod</command> avec les numéros de périphériques majeurs et
mineurs pour chaque périphérique possible qui pourrait exister dans le
monde.</para>

  <para>En utilisant la méthode udev, seuls les nœuds des périphériques détectés par
le noyau sont créés. Comme ces n&oelig;uds de périphériques seront créés à
chaque lancement du système, ils seront stockés dans un système de fichiers
<systemitem class="filesystem">devtmpfs</systemitem> (un système de fichiers
virtuel qui réside entièrement dans la mémoire du système).  Les n&oelig;uds
de périphériques ne requièrent pas beaucoup d'espace, donc la mémoire
utilisée est négligeable.</para>

  <sect2>
    <title>Historique</title>

    <para>En février 2000, un nouveau système de fichiers appelé <systemitem
class="filesystem">devfs</systemitem> a été intégré au noyau 2.3.46 et rendu
disponible pour la série 2.4 des noyaux stables.  Bien qu'il soit présent
dans les sources du noyau, cette méthode de création dynamique des
périphériques n'a jamais reçu un support inconditionnel des développeurs du
noyau.</para>

    <para>Le principal problème de l'approche adopté par <systemitem
class="filesystem">devfs</systemitem> était la façon dont il gérait la
détection, la création et le nommage des périphériques. Ce dernier problème,
le nommage des périphériques, était peut-être le plus critique. Il est
généralement accepté que s'il est possible de configurer les noms des
périphériques, alors la politique de nommage des périphériques revient à
l'administrateur du système, et non imposée par quelque développeur. Le
système de fichiers <systemitem class="filesystem">devfs</systemitem>
souffrait aussi de restrictions particulières inhérentes à sa conception et
qui ne pouvaient être corrigées sans une revue importante du noyau. Il a
aussi été marqué comme obsolète pendant une longue période &mdash;&nbsp;à
cause d'un manque de maintenance&nbsp;&mdash; et a finalement été supprimé
du noyau en juin 2006.</para>

    <para>Avec le développement de la branche instable 2.5 du noyau, sortie ensuite
avec la série 2.6 des noyaux stables, un nouveau système de fichiers virtuel
appelé <systemitem class="filesystem">sysfs</systemitem> est arrivé. Le rôle
de <systemitem class="filesystem">sysfs</systemitem> est d'exporter une vue
de la configuration matérielle du système pour les processus en espace
utilisateur.  Avec cette représentation visible en espace utilisateur, la
possibilité de développer un remplacement en espace utilisateur de
<systemitem class="filesystem">devfs</systemitem> est devenu beaucoup plus
réaliste.</para>

  </sect2>

  <sect2>
    <title>Implémentation d'Udev</title>

    <sect3>
      <title>Sysfs</title>

      <para>Le système de fichier <systemitem class="filesystem">sysfs</systemitem> a
été brièvement mentionné ci-dessus. On pourrait se demander comment
<systemitem class="filesystem">sysfs</systemitem> connaît les périphériques
présents sur un système et quels numéros de périphériques devraient être
utilisés. Les pilotes qui ont été compilés directement dans le noyau
enregistrent leurs objets avec le <systemitem
class="filesystem">sysfs</systemitem> (en interne, devtmpfs) quand ils sont
détectés par le noyau. Pour les pilotes compilés en tant que modules, cet
enregistrement surviendra quand le module sera chargé. Une fois que le
système de fichier <systemitem class="filesystem">sysfs</systemitem> est
monté (sur /sys), les données enregistrées par les pilotes avec <systemitem
class="filesystem">sysfs</systemitem> sont disponibles pour les processus en
espace utilisateur ainsi que pour udevd pour traitement (y compris des
modifications aux n&oelig;uds de périphériques).</para>

    </sect3>

    <sect3>
      <title>Création de n&oelig;uds de périphérique</title>

      <para>Les fichiers de périphérique sont créés par le noyau avec le système de
fichiers <systemitem class="filesystem">devtmpfs</systemitem>.  Tout pilote
souhaitant enregistrer un nœud de périphérique ira dans le <systemitem
class="filesystem">devtmpfs</systemitem> (par le cœur du pilote) pour le
faire. Quand une instance <systemitem
class="filesystem">devtmpfs</systemitem> est montée sur <filename
class="directory">/dev</filename>, le nœud de périphérique sera créé dès le
départ avec un nom, des droits et un propriétaire figés.</para>

      <para>Peu de temps après, le noyau enverra un uevent à <command>udevd</command>.
À partir des règles indiquées dans les fichiers contenus dans les
répertoires <filename class="directory">/etc/udev/rules.d</filename>,
<filename class="directory">/usr/lib/udev/rules.d</filename> et <filename
class="directory">/run/udev/rules.d</filename>, <command> udevd</command>
créera les liens symboliques supplémentaires vers le nœud de périphérique,
ou bien il modifiera ses droits, son propriétaire ou son groupe, ou l'entrée
dans la base de données interne d'<command>udevd</command> concernant cet
objet.</para>

      <para>Les règles de ces trois répertoires sont numérotées et les trois répertoires
sont fusionnés. Si <command>udevd</command> ne peut pas trouver de règles
pour le périphérique qu'il crée, il en donnera la propriété et les droits à
n'importe quel <systemitem class="filesystem">devtmpfs</systemitem> utilisé
au départ.</para> </sect3>
      
    <sect3 id="module-loading">
      <title>Chargement d'un module</title>

      <para>Il se peut que les pilotes des périphériques compilés en module aient aussi
des alias compilés. Les alias sont visibles dans la sortie du programme
<command>modinfo</command> et sont souvent liés aux identifiants de bus
spécifiques des périphériques pris en charge par un module. Par exemple, le
pilote <emphasis>snd-fm801</emphasis> prend en charge les périphériques PCI
ayant l'ID fabricant 0x1319 et l'ID de périphérique 0x0801 a aussi un alias
<quote>pci:v00001319d00000801sv*sd*bc04sc01i*</quote>.  Pour la plupart des
périphériques, le pilote du bus définit l'alias du pilote qui gérerait le
périphérique via <systemitem class="filesystem">sysfs</systemitem>.  Par
exemple, le fichier
<filename>/sys/bus/pci/devices/0000:00:0d.0/modalias</filename> pourrait
contenir la chaîne
<quote>pci:v00001319d00000801sv00001319sd00001319bc04sc01i00</quote>. Les
règles par défaut fournies par Udev feront que <command>udevd</command>
appellera <command>/sbin/modprobe</command> avec le contenu de la variable
d'environnement de l'uevent <envar>MODALIAS</envar> (qui devrait être la
même que le contenu du fichier <filename>modalias</filename> dans sysfs),
donc chargera tous les modules dont les alias correspondent à cette chaîne
après les expansions génériques.</para>

      <para>Dans cet exemple, cela signifie que, outre <emphasis>snd-fm801</emphasis>,
le pilote obsolète (et non désiré) <emphasis>forte</emphasis> sera chargé
s'il est disponible. Voir ci-dessous les moyens d'empêcher le chargement des
modules indésirables.</para>

      <para>Le noyau lui-même est aussi capable de charger des modules de protocole
réseau, de prise en charge pour des systèmes de fichiers et de prise en
charge native des langues sur demande.</para>

    </sect3>

    <sect3>
      <title>Gestion des périphériques dynamiques ou montables à chaud</title>

      <para>Quand vous connectez un périphérique, comme un lecteur MP3 USB, le noyau
reconnaît que le périphérique est maintenant connecté et génère un
uevent. Cet uevent est alors géré par <command>udevd</command> comme décrit
ci-dessus.</para>

    </sect3>

  </sect2>

  <sect2>
    <title>Problèmes avec le chargement des modules et la création des périphériques</title>

    <para>Il existe quelques problèmes connus pour la création automatique des
n&oelig;uds de périphériques.</para>

    <sect3>
      <title>Un module noyau n'est pas chargé automatiquement</title>

      <para>Udev ne chargera un module que s'il a un alias spécifique au bus et que le
pilote du bus envoie correctement les alias nécessaires vers <systemitem
class="filesystem">sysfs</systemitem>.  Sinon, il faut organiser le
chargement des modules par d'autres moyens.  Avec Linux-&linux-version;,
udev est connu pour charger les pilotes correctement écrits pour les
périphériques INPUT, IDE, PCI, USB, SCSI, SERIO et FireWire.</para>

      <para>Pour déterminer si le pilote du périphérique dont vous avez besoin prend en
charge udev, lancez <command>modinfo</command> avec le nom du module en
argument.  Puis, essayez de localiser le répertoire du périphérique sous
<filename class="directory">/sys/bus</filename> et vérifiez s'il y a un
fichier <filename>modalias</filename>.</para>

      <para>Si le fichier <filename>modalias</filename> existe dans <systemitem
class="filesystem">sysfs</systemitem>, alors le pilote prend en charge le
périphérique et peut lui parler directement, mais s'il n'a pas d'alias,
c'est un bogue dans le pilote. Chargez le pilote sans l'aide d'udev et
attendez que le problème soit corrigé plus tard.</para>

      <para>S'il n'y a pas de fichier <filename>modalias</filename> dans le bon
répertoire sous <filename class="directory">/sys/bus</filename>, cela
signifie que les développeurs du noyau n'ont pas encore ajouté de prise en
charge de modalias à ce type de bus. Avec Linux-&linux-version;, c'est le
cas pour les bus ISA. Attendez que ce problème soit réparé dans les versions
ultérieures du noyau.</para>

      <para>Udev n'a pas du tout pour but de charger des pilotes <quote>wrapper</quote>
(qui emballent un autre pilote) comme <emphasis>snd-pcm-oss</emphasis> et
des pilotes non matériels comme <emphasis>loop</emphasis>.</para>

    </sect3>

    <sect3>
      <title>Un module du noyau n'est pas chargé automatiquement et udev n'est pas prévu
pour le charger</title>

      <para>Si le module <quote>enveloppe</quote> n'améliore que la fonctionnalité
fournie par un autre module (comme <emphasis>snd-pcm-oss</emphasis> améliore
la fonctionnalité de <emphasis>snd-pcm</emphasis> en rendant les cartes son
disponibles pour les applications OSS), configurez
<command>modprobe</command> pour charger l'enveloppe après qu'udev a chargé
le module enveloppé. Pour cela, ajoutez une ligne <quote>softdep</quote>
dans tous les fichiers
<filename>/etc/modprobe.d/<replaceable>&lt;filename&gt;</replaceable>.conf</filename>.
Par exemple&nbsp;:</para>

<screen role="nodump"><literal>softdep snd-pcm post: snd-pcm-oss</literal></screen>

      <para>Remarquez que la commande <quote>softdep</quote> autorise aussi les
dépendances <literal>pre:</literal>, ou un mélange de
<literal>pre:</literal> et de <literal>post:</literal>. Voir la page de
manuel de <filename>modprobe.d(5)</filename> pour plus d'informations sur la
syntaxe et les possibilités de <quote>softdep</quote>.</para>

      <para revision="sysv">Si le module en question n'est pas un emballage et s'avère utile en tant que
tel, configurez le script de démarrage <command>modules</command> pour
charger ce module sur le système de démarrage. Pour cela, ajoutez le nom du
module au fichier <filename>/etc/sysconfig/modules</filename> sur une ligne
séparée.  Ceci fonctionne aussi pour les modules d'emballage, mais sans être
optimal.</para>

    </sect3>

    <sect3>
      <title>Udev charge un module indésirable</title>

      <para>Ne compilez pas le module, ou mettez-le en liste noire dans un fichier
<filename>/etc/modprobe.d/blacklist.conf</filename> comme nous l'avons fait
avec le module <emphasis>forte</emphasis> dans l'exemple ci-dessous&nbsp;:</para>

<screen role="nodump"><literal>blacklist forte</literal></screen>

      <para>Les modules en liste noire peuvent toujours être chargés manuellement avec
la commande explicite <command>modprobe</command>.</para>

    </sect3>

    <sect3>
      <title>Udev crée mal un périphérique, ou crée un mauvais lien symbolique</title>

      <para>Cela se produit habituellement si une règle correspond à un périphérique de
façon imprévue. Par exemple, une règle lacunaire peut correspondre à un
disque SCSI (comme désiré)  et au périphérique SCSI générique du même
fabricant (de façon incorrecte).  Trouvez la règle défectueuse et
affinez-la, à l'aide de la commande <command>udevadm info</command>.</para>

    </sect3>

    <sect3>
      <title>Une règle Udev fonctionne de manière non fiable</title>

      <para>Cela peut être une autre manifestation du problème précédent.  Sinon, et si
votre règle utilise les attributs de <systemitem
class="filesystem">sysfs</systemitem>, il se peut que ce soit un problème de
timing du noyau, sur le point d'être corrigé dans les noyaux ultérieurs.
Pour le moment, vous pouvez contourner en créant une règle qui attend
l'attribut <systemitem class="filesystem">sysfs</systemitem> utilisé et en
le mettant dans le fichier
<filename>/etc/udev/rules.d/10-wait_for_sysfs.rules</filename> (créez ce
fichier s'il n'existe pas). Merci d'informer la liste de développement de
LFS si vous faites ainsi et que cela vous aide.</para>

    </sect3>

    <sect3>
      <title>Udev ne crée pas un périphérique</title>

      <para>Les textes suivants supposent que le pilote est compilé statiquement dans le
noyau ou bien sont déjà chargés comme modules et que vous avez déjà vérifié
que udev ne crée pas un périphérique mal nommé.</para>

      <para>Udev n'a pas les informations pour créer un nœud si un pilote noyau
n'exporte pas ses informations vers <systemitem
class="filesystem">sysfs</systemitem>. C'est le plus souvent le cas des
pilotes tiers ne provenant pas du noyau. Créez un nœud de périphérique
statique dans <filename>/usr/lib/udev/devices</filename> avec les numéros
majeurs/mineurs appropriés (regardez le fichier
<filename>devices.txt</filename> dans la documentation du noyau du vendeur
du pilote tiers). Le nœud statique sera copié dans <filename
class="directory">/dev</filename> par <command>udev</command>.</para>

    </sect3>

    <sect3>
      <title>L'ordre de nommage des périphériques change de manière aléatoire après le
redémarrage</title>

      <para>Cela est dû au fait qu'udev, par nature, gère les uevents et charge les
modules en parallèle, donc dans un ordre imprévisible.  Cela ne sera jamais
<quote>corrigé</quote>. Vous ne devriez pas supposer que les noms des
périphériques du noyau sont stables. Créez plutôt vos propres règles qui
rendent les liens symboliques stables basés sur des attributs stables du
périphérique, comme une série de nombres ou la sortie de divers utilitaires
*_id installés par udev. Voir la <xref linkend="ch-config-symlinks"/> et la
<xref linkend="ch-config-network"/> pour des exemples.</para>

    </sect3>

  </sect2>

  <sect2>
    <title>Lecture utile</title>

    <para>Des documentations supplémentaires sont disponibles sur les sites
suivants&nbsp;:</para>

    <itemizedlist>

      <listitem>
        <para>A Userspace Implementation of <systemitem
class="filesystem">devfs</systemitem> <ulink
url="http://www.kroah.com/linux/talks/ols_2003_udev_paper/Reprint-Kroah-Hartman-OLS2003.pdf"/>
(NdT&nbsp;: Une implémentation en espace utilisateur de devfs)</para>
      </listitem>

      <listitem>
        <para>The <systemitem class="filesystem">sysfs</systemitem> Filesystem <ulink
url="http://www.kernel.org/pub/linux/kernel/people/mochel/doc/papers/ols-2005/mochel.pdf"/>
(NdT&nbsp;: Le système de fichiers <systemitem
class="filesystem">sysfs</systemitem>)</para>
      </listitem>


    <!--  No longer available
      <listitem>

        <para>Pointers to further reading
        <ulink url="http://www.kernel.org/pub/linux/utils/kernel/hotplug/udev.html"/>
        </para>
      </listitem>
-->
</itemizedlist>

  </sect2>

</sect1>
