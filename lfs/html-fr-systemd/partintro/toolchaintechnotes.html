<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8" />
    <title>
      Notes techniques sur la chaîne d'outils
    </title>
    <link rel="stylesheet" type="text/css" href="../stylesheets/lfs.css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.78.1" />
    <link rel="stylesheet" href="../stylesheets/lfs-print.css" type=
    "text/css" media="print" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  </head>
  <body class="lfs" id="lfs-r10.1-212-g6711c-systemd+">
    <div class="navheader">
      <h4>
        Linux From Scratch - Version r10.1-212-g6711c-systemd+
      </h4>
      <h3>
        Informations préliminaires importantes
      </h3>
      <ul>
        <li class="prev">
          <a accesskey="p" href="introduction.html" title=
          "Introduction">Précédent</a>
          <p>
            Introduction
          </p>
        </li>
        <li class="next">
          <a accesskey="n" href="generalinstructions.html" title=
          "Instructions générales de compilation">Suivant</a>
          <p>
            Instructions générales de compilation
          </p>
        </li>
        <li class="up">
          <a accesskey="u" href="partintro.html" title=
          "Informations préliminaires importantes">Niveau supérieur</a>
        </li>
        <li class="home">
          <a accesskey="h" href="../index.html" title=
          "Linux From Scratch - Version r10.1-212-g6711c-systemd+">Sommaire</a>
        </li>
      </ul>
    </div>
    <div class="sect1" lang="fr" xml:lang="fr">
      <h1 class="sect1">
        <a id="ch-tools-toolchaintechnotes" name=
        "ch-tools-toolchaintechnotes"></a>ii. Notes techniques sur la chaîne
        d'outils
      </h1>
      <p>
        Cette section explique certains détails rationnels et techniques
        derrière la méthode de construction. Il n'est pas essentiel de
        comprendre immédiatement tout ce qui se trouve dans cette section. La
        plupart des informations seront plus claires après avoir réalisé
        réellement une construction complète. Cette section peut servir de
        référence à tout moment lors du processus de construction.
      </p>
      <p>
        Le but global des chapitres <a class="xref" href=
        "../chapter05/chapter05.html" title=
        "Chapitre&nbsp;5.&nbsp;Compilation d'une chaîne d'outils croisée">Chapitre&nbsp;5</a>
        et <a class="xref" href="../chapter06/chapter06.html" title=
        "Chapitre&nbsp;6.&nbsp;Compilation croisée des outils temporaires">Chapitre&nbsp;6</a>
        est de fournir une zone temporaire qui contient un ensemble d'outils
        connus qui peuvent être isolés du système hôte. En utilisant
        <span class="command"><strong>chroot</strong></span>, les commandes
        dans le reste des chapitres se cantonneront à cet environnement, en
        assurant une construction du système LFS cible propre, sans soucis.
        Le processus de construction a été conçu pour minimiser les risques
        pour les nouveaux lecteurs et pour fournir une valeur éducative
        maximale en même temps.
      </p>
      <p>
        Le processus de construction se base sur de la <span class=
        "emphasis"><em>compilation croisée</em></span>. La compilation
        croisée s'utilise normalement pour construire un compilateur et sa
        chaîne de construction pour une machine différente de celle utilisée
        pour la construction. Cela n'est pas strictement requis pour LFS,
        comme la machine où le nouveau système est construit est la même que
        celle utilisée pour la construction. Mais la compilation croisée a le
        grand avantage que tout ce qui est compilé ne peut pas dépendre de
        l'environnement hôte.
      </p>
      <div class="sect2" lang="fr" xml:lang="fr">
        <h2 class="sect2">
          <a id="cross-compile" name="cross-compile"></a>À propos de la
          compilation croisée
        </h2>
        <p>
          La compilation croisée utilise certains concepts qui méritent une
          section à part. Bien que vous puissiez passer cette section lors de
          votre première lecture, nous vous recommandons fortement d'y
          revenir plus tard pour bien comprendre le processus de
          construction.
        </p>
        <p>
          Définissons d'abord certains termes utilisés dans ce
          contexte&nbsp;:
        </p>
        <div class="variablelist">
          <dl class="variablelist">
            <dt>
              <span class="term">build (construction)</span>
            </dt>
            <dd>
              <p>
                est la machine où nous construisons les programmes. Remarquez
                que cette machine sera appelée <span class=
                "quote">«&nbsp;<span class="quote">hôte</span>&nbsp;»</span>
                dans les autres sections.
              </p>
            </dd>
            <dt>
              <span class="term">host (hôte)</span>
            </dt>
            <dd>
              <p>
                est la machine ou le système où les programmes seront lancés.
                Remarquez que nous n'utilisons pas le terme <span class=
                "quote">«&nbsp;<span class="quote">hôte</span>&nbsp;»</span>
                de la même manière ici que dans les autres sections.
              </p>
            </dd>
            <dt>
              <span class="term">target (cible)</span>
            </dt>
            <dd>
              <p>
                est seulement utilisé pour les compilateurs. C'est la machine
                pour laquelle le compilateur produit du code. Elle peut être
                différente de la machine hôte ou de construction.
              </p>
            </dd>
          </dl>
        </div>
        <p>
          Par exemple, imaginons le scénario suivant (parfois appelé
          <span class="quote">«&nbsp;<span class="quote">Canadian
          Cross</span>&nbsp;»</span>)&nbsp;: on peut avoir un compilateur sur
          une machine lente, appelons-la A, et le compilateur ccA. On peut
          aussi avoir une machine rapide (B) sans compilateur, et on veut
          produire du code pour une autre machine lente (C). Pour construire
          un compilateur pour une machine C, on effectuerait trois
          étapes&nbsp;:
        </p>
        <div class="informaltable">
          <table border="1">
            <colgroup>
              <col align="center" />
              <col align="center" />
              <col align="center" />
              <col align="center" />
              <col align="left" />
            </colgroup>
            <thead>
              <tr>
                <th align="center">
                  Étape
                </th>
                <th align="center">
                  Construction
                </th>
                <th align="center">
                  Hôte
                </th>
                <th align="center">
                  Cible
                </th>
                <th align="left">
                  Action
                </th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="center">
                  1
                </td>
                <td align="center">
                  A
                </td>
                <td align="center">
                  A
                </td>
                <td align="center">
                  B
                </td>
                <td align="left">
                  construire un compilateur croisé cc1 avec ccA sur la
                  machine A
                </td>
              </tr>
              <tr>
                <td align="center">
                  2
                </td>
                <td align="center">
                  A
                </td>
                <td align="center">
                  B
                </td>
                <td align="center">
                  C
                </td>
                <td align="left">
                  construire un compilateur croisé cc2 avec cc1 sur la
                  machine A
                </td>
              </tr>
              <tr>
                <td align="center">
                  3
                </td>
                <td align="center">
                  B
                </td>
                <td align="center">
                  C
                </td>
                <td align="center">
                  C
                </td>
                <td align="left">
                  construire le compilateur ccC avec cc2 sur la machine B
                </td>
              </tr>
            </tbody>
          </table>
        </div>
        <p>
          Ensuite, tous les autres programmes requis par la machine C peuvent
          être compilés avec cc2 sur la machine rapide B. Remarquez qu'à
          moins que B ne puisse lancer les programmes produits pour C, il n'y
          a aucun moyen de tester les programmes construits avant de les
          lancer sur la machine C. Par exemple, pour tester ccC, on peut
          ajouter une quatrième étape&nbsp;:
        </p>
        <div class="informaltable">
          <table border="1">
            <colgroup>
              <col align="center" />
              <col align="center" />
              <col align="center" />
              <col align="center" />
              <col align="left" />
            </colgroup>
            <thead>
              <tr>
                <th align="center">
                  Étape
                </th>
                <th align="center">
                  Construction
                </th>
                <th align="center">
                  Hôte
                </th>
                <th align="center">
                  Cible
                </th>
                <th align="left">
                  Action
                </th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="center">
                  4
                </td>
                <td align="center">
                  C
                </td>
                <td align="center">
                  C
                </td>
                <td align="center">
                  C
                </td>
                <td align="left">
                  reconstruire et tester ccC avec lui-même sur la machine C
                </td>
              </tr>
            </tbody>
          </table>
        </div>
        <p>
          Dans l'exemple au dessus, seuls cc1 et cc2 sont des compilateurs
          croisés, c'est à dire qu'ils produisent du code pour une machine
          différente de celle sur laquelle ils tournent. Les autres
          compilateurs ccA et ccC produisent du code pour la machine sur
          laquelle ils tournent. Ces compilateurs sont appelés des
          compilateurs <span class="emphasis"><em>natifs</em></span>.
        </p>
      </div>
      <div class="sect2" lang="fr" xml:lang="fr">
        <h2 class="sect2">
          <a id="lfs-cross" name="lfs-cross"></a>Implémentation de la
          compilation croisée dans LFS
        </h2>
        <div class="admon note">
          <img alt="[Note]" src="../images/note.png" />
          <h3>
            Note
          </h3>
          <p>
            Presque tous les systèmes de construction utilisent des noms de
            la forme cpu-fabriquant-noyau-os, souvent appelé le triplet
            machine. Le lecteur attentif se demandera pourquoi on appelle un
            <span class="quote">«&nbsp;<span class=
            "quote">triplet</span>&nbsp;»</span> un nom à quatre composants.
            La raison est historique&nbsp;: initialement, on utilisait trois
            composants pour désigner une machine sans ambiguïté, mais avec
            les nouvelles machines et les nouveaux systèmes, cela s'avère
            insuffisant. Le mot <span class="quote">«&nbsp;<span class=
            "quote">triplet</span>&nbsp;»</span> est resté. Une façon simple
            de déterminer le nom du triplet machine est de lancer le script
            <span class="command"><strong>config.guess</strong></span> venant
            avec les sources d'un grand nombre de paquets. Déballez les
            sources de binutils, lancez le script <strong class=
            "userinput"><code>./config.guess</code></strong> et notez la
            sortie. Par exemple, pour un processeur Intel 32 bits moderne, la
            sortie sera du type <span class=
            "emphasis"><em>i686-pc-linux-gnu</em></span>. Sur un système 64
            bits cela sera <span class=
            "emphasis"><em>x86_64-pc-linux-gnu</em></span>.
          </p>
          <p>
            De même, faites attention au nom de l'éditeur de liens de la
            plateforme, souvent appelé le chargeur dynamique (à ne pas
            confondre avec l'éditeur de liens standard <span class=
            "command"><strong>ld</strong></span> faisant partie de Binutils).
            Le chargeur dynamique fourni par Glibc trouve et charge les
            bibliothèques partagées nécessaires à un programme pour
            s'exécuter, puis l'exécute. Le nom de l'éditeur dynamique pour
            une machine Intel 32 bits sera <code class=
            "filename">ld-linux.so.2</code> (<code class=
            "filename">ld-linux-x86-64.so.2</code> pour les systèmes 64
            bits). Une façon sûre de déterminer le nom de l'éditeur de liens
            dynamiques est d'inspecter un binaire au hasard du système hôte
            en exécutant&nbsp;: <strong class="userinput"><code>readelf -l
            &lt;nom du binaire&gt; | grep interpreter</code></strong> et de
            noter le résultat. La référence faisant autorité couvrant toutes
            les plateformes est dans le fichier <code class=
            "filename">shlib-versions</code> à la racine du répertoire des
            sources de Glibc.
          </p>
        </div>
        <p>
          Pour simuler une compilation croisée, le nom du triplet hôte est
          légèrement ajusté en changeant la partie «&nbsp;fabriquant&nbsp;»
          dans la variable <code class="envar">LFS_TGT</code>. Nous utilisons
          aussi l'option <em class=
          "parameter"><code>--with-sysroot</code></em> lors de la
          construction de l'éditeur des liens et du compilateur croisés pour
          leur dire où trouver les fichiers hôtes requis. Cela s'assure
          qu'aucun autre programme construit dans le <a class="xref" href=
          "../chapter06/chapter06.html" title=
          "Chapitre&nbsp;6.&nbsp;Compilation croisée des outils temporaires">Chapitre&nbsp;6</a>
          ne peut se lier aux bibliothèques sur la machine de construction.
          Seules deux étapes sont requises, et une autre pour les
          tests&nbsp;:
        </p>
        <div class="informaltable">
          <table border="1">
            <colgroup>
              <col align="center" />
              <col align="center" />
              <col align="center" />
              <col align="center" />
              <col align="left" />
            </colgroup>
            <thead>
              <tr>
                <th align="center">
                  Étape
                </th>
                <th align="center">
                  Construction
                </th>
                <th align="center">
                  Hôte
                </th>
                <th align="center">
                  Cible
                </th>
                <th align="left">
                  Action
                </th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="center">
                  1
                </td>
                <td align="center">
                  pc
                </td>
                <td align="center">
                  pc
                </td>
                <td align="center">
                  lfs
                </td>
                <td align="left">
                  construire un compilateur croisé cc1 avec cc-pc sur pc
                </td>
              </tr>
              <tr>
                <td align="center">
                  2
                </td>
                <td align="center">
                  pc
                </td>
                <td align="center">
                  lfs
                </td>
                <td align="center">
                  lfs
                </td>
                <td align="left">
                  construire un compilateur cc-lfs avec cc1 sur pc
                </td>
              </tr>
              <tr>
                <td align="center">
                  3
                </td>
                <td align="center">
                  lfs
                </td>
                <td align="center">
                  lfs
                </td>
                <td align="center">
                  lfs
                </td>
                <td align="left">
                  reconstruire et tester cc-lfs avec lui-même sur lfs
                </td>
              </tr>
            </tbody>
          </table>
        </div>
        <p>
          Dans le tableau plus haut, <span class="quote">«&nbsp;<span class=
          "quote">sur pc</span>&nbsp;»</span> signifie que les commandes sont
          lancées sur une machine qui utilise la distribution déjà installée.
          <span class="quote">«&nbsp;<span class="quote">Sur
          lfs</span>&nbsp;»</span> signifie que les commandes sont lancées
          dans un environnement chroot.
        </p>
        <p>
          n fait, il y a plus à savoir sur la compilation croisée&nbsp;: le
          langage C n'est pas seulement un compilateur, mais définie aussi
          une bibliothèque standard. Dans ce livre, on utilise la
          bibliothèque C de GNU, glibc. Cette bibliothèque doit être compilée
          pour la machine lfs, c'est-à-dire, avec le compilateur croisé cc1.
          Mais le compilateur lui-même utilise une bibliothèque interne
          implémentant des instructions complexes qui ne sont pas disponibles
          dans l'ensemble d'instructions de l'assembleur. Cette bibliothèque
          interne, libgcc, doit être liée à la bibliothèque glibc pour
          fonctionner correctement&nbsp;! En plus, la bibliothèque standard
          du C++ (libstdc++) a aussi besoin d'être liée à la glibc. La
          solution pour ce problème de poule et d'œuf est de d'abord
          construire une libgcc dégradée basée sur cc1, qui n'a pas de
          fonctionnalité avancée comme les threads et le traitement des
          exceptions, puis de construire glibc avec ce compilateur dégradé
          (glibc elle-même n'est pas dégradée), puis de construire libstdc++.
          Mais cette dernière n'aura pas les fonctionnalités que libgcc n'a
          pas non plus.
        </p>
        <p>
          Ce n'est pas la fin de l'histoire&nbsp;: la conclusion du
          paragraphe précédent est que cc1 est incapable de trouver une
          libstdc++ complètement fonctionnelle, mais c'est le seul
          compilateur disponible pour construire les bibliothèques C/C++ lors
          de la deuxième étape&nbsp;! Évidemment, le compilateur construit à
          l'étape 2, cc-lfs, serait capable de construire ces bibliothèques,
          mais (1) le système de construction de GCC ne sait pas qu'il est
          utilisable sur pc, et (2) l'utiliser sur pc risquerait de le lier à
          des bibliothèques de pc, comme cc-lfs est un compilateur natif.
          Donc nous devons compiler libstdc++ plus tard, dans le chroot.
        </p>
      </div>
      <div class="sect2" lang="fr" xml:lang="fr">
        <h2 class="sect2">
          <a id="other-details" name="other-details"></a>Autres détails sur
          la procédure
        </h2>
        <p>
          Le compilateur croisé sera installé dans un répertoire <code class=
          "filename">$LFS/tools</code> séparé, comme il ne fera pas partie du
          système final.
        </p>
        <p>
          Binutils est tout d'abord installé parce que les exécutions de
          Glibc et GCC par <span class=
          "command"><strong>configure</strong></span> réalisent quelques
          tests de fonctionnalités sur l'assembleur et l'éditeur de liens
          pour déterminer quelle fonctionnalité logicielle activer ou
          désactiver. Ceci est plus important que ce que vous pouvez
          imaginer. Un GCC ou une Glibc mal configuré peut aboutir à une
          chaîne d'outils subtilement cassée, et l'impact d'une telle cassure
          ne se verrait pas avant la fin de la construction de la
          distribution complète. Un échec dans la suite de tests surlignera
          habituellement cette erreur avant que trop de travail
          supplémentaire n'ait été réalisé.
        </p>
        <p>
          Binutils installe son assembleur et son éditeur de liens à deux
          endroits, <code class="filename">$LFS/tools/bin</code> et
          <code class="filename">$LFS/tools/$LFS_TGT/bin</code>. Les outils
          dans un emplacement sont liés en dur à l'autre. Un aspect important
          de l'éditeur de liens est son ordre de recherche des bibliothèques.
          Vous pouvez obtenir des informations détaillées à partir de
          <span class="command"><strong>ld</strong></span> en lui passant le
          paramètre <em class="parameter"><code>--verbose</code></em>. Par
          exemple, un <span class="command"><strong>ld --verbose | grep
          SEARCH</strong></span> illustrera les chemins de recherche réels et
          leur ordre. Il montre quels fichiers sont liés par <span class=
          "command"><strong>ld</strong></span> en compilant un programme de
          test et en passant le paramètre <em class=
          "parameter"><code>--verbose</code></em> à l'éditeur de liens. Par
          exemple, <span class="command"><strong>$LFS_TGT-gcc dummy.c
          -Wl,--verbose 2&gt;&amp;1 | grep succeeded</strong></span>
          affichera tous les fichiers ouverts avec succès lors de l'édition
          des liens.
        </p>
        <p>
          Le prochain paquet installé est GCC. Voici un exemple de ce qui
          peut être vu pendant l'exécution de son script <span class=
          "command"><strong>configure</strong></span>&nbsp;:
        </p>
        <pre class="screen"><code class=
        "computeroutput">checking what assembler to use... /mnt/lfs/tools/i686-lfs-linux-gnu/bin/as
checking what linker to use... /mnt/lfs/tools/i686-lfs-linux-gnu/bin/ld</code></pre>
        <p>
          C'est important pour les raisons mentionnées plus haut. Cela
          démontre aussi que le script configure de GCC ne cherche pas les
          répertoires du PATH pour trouver les outils à utiliser. Néanmoins,
          lors d'une opération normale de <span class=
          "command"><strong>gcc</strong></span>, les mêmes chemins de
          recherche ne sont pas forcément utilisés. Pour trouver quel éditeur
          de liens standard <span class="command"><strong>gcc</strong></span>
          utilisera, lancez&nbsp;: <span class="command"><strong>$LFS_TGT-gcc
          -print-prog-name=ld</strong></span>.
        </p>
        <p>
          Vous pouvez obtenir des informations détaillées à partir de
          <span class="command"><strong>gcc</strong></span> en lui
          fournissant l'option en ligne de commande <em class=
          "parameter"><code>-v</code></em> lors de la compilation d'un
          programme de test. Par exemple, <span class="command"><strong>gcc
          -v dummy.c</strong></span> affichera des informations détaillées
          sur les étapes du préprocesseur, de la compilation et de
          l'assemblage, avec les chemins de recherche inclus par <span class=
          "command"><strong>gcc</strong></span> et leur ordre.
        </p>
        <p>
          Nous installons ensuite les en-têtes de l'API de Linux nettoyées.
          Elles permettent à la bibliothèque standard (Glibc) d'interagir
          avec les fonctionnalités que le noyau Linux fournira.
        </p>
        <p>
          Le paquet installé ensuite est Glibc. Les choses les plus
          importantes à prendre en considération pour construire Glibc sont
          le compilateur, les outils binaires et les en-têtes du noyau. Le
          compilateur ne pose généralement pas de problème car Glibc utilise
          toujours le compilateur lié au paramètre <em class=
          "parameter"><code>--host</code></em> passé à son script configure,
          par exemple, dans notre cas, le compilateur sera <span class=
          "command"><strong>$LFS_TGT-gcc</strong></span>. Les outils binaires
          et les en-têtes du noyau peuvent être un peu plus compliqués. Ne
          prenez donc pas de risque et utilisez les options de configure
          disponibles pour assurer les bonnes sélections. Après l'exécution
          de <span class="command"><strong>configure</strong></span>,
          vérifiez le contenu du fichier <code class=
          "filename">config.make</code> dans le répertoire <code class=
          "filename">glibc-build</code> pour tous les détails importants.
          Notez l'utilisation de <em class=
          "parameter"><code>CC="$LFS_TGT-gcc"</code></em> (où <code class=
          "envar">$LFS_TGT</code> est étendue) pour contrôler les outils
          binaires utilisés, et l'utilisation des paramètres <em class=
          "parameter"><code>-nostdinc</code></em> et <em class=
          "parameter"><code>-isystem</code></em> pour contrôler le chemin de
          recherche des en-têtes du compilateur. Ces éléments soulignent un
          aspect important du paquet glibc —&nbsp;il est auto-suffisant en
          termes de machinerie de construction et ne repose généralement pas
          sur la chaîne d'outils par défaut.
        </p>
        <p>
          Comme nous venons de le dire, la bibliothèque standard C++ est
          ensuite compilée, suivi dans le <a class="xref" href=
          "../chapter06/chapter06.html" title=
          "Chapitre&nbsp;6.&nbsp;Compilation croisée des outils temporaires">Chapitre&nbsp;6</a>
          par tous les programmes qui ont besoin d'eux-mêmes pour être
          construits. L'étape initiale de tous ces paquets utilise la
          variable <code class="envar">DESTDIR</code> pour que les programmes
          soient installés dans le système de fichiers LFS.
        </p>
        <p>
          À la fin du <a class="xref" href="../chapter06/chapter06.html"
          title=
          "Chapitre&nbsp;6.&nbsp;Compilation croisée des outils temporaires">Chapitre&nbsp;6</a>
          le compilateur lfs natif est installé. binutils-pass2 est d'abord
          construit, avec la même installation <code class=
          "envar">DESTDIR</code> que les autres programmes, puis la seconde
          passe de GCC est construite, sans libstdc++ et les autres
          bibliothèques non importantes. À cause d'une logique bizarre dans
          le script de construction de GCC, <code class=
          "envar">CC_FOR_TARGET</code> devient <span class=
          "command"><strong>cc</strong></span> quand l'hôte est le même que
          la cible, mais est différent du système de construction. C'est
          pourquoi nous mettons explicitement <em class=
          "parameter"><code>CC_FOR_TARGET=$LFS_TGT-gcc</code></em> dans les
          options de configure.
        </p>
        <p>
          En entrant dans l'environnement chroot dans le <a class="xref"
          href="../chapter07/chapter07.html" title=
          "Chapitre&nbsp;7.&nbsp;Entrée dans le chroot et construction des outils temporaires supplémentaires">
          Chapitre&nbsp;7</a>, la première tache consiste à installer
          libstdc++. Ensuite, on effectue des installations temporaires de
          programmes requis pour le bon fonctionnement de la chaîne d'outils.
          À partir de là, la chaîne de construction de base est
          auto-suffisante et auto-hébergée. Dans le <a class="xref" href=
          "../chapter08/chapter08.html" title=
          "Chapitre&nbsp;8.&nbsp;Installer les logiciels du système de base">Chapitre&nbsp;8</a>,
          on construit, teste et installe les versions finales de tous les
          paquets requis pour un système complètement fonctionnel.
        </p>
      </div>
    </div>
    <div class="navfooter">
      <ul>
        <li class="prev">
          <a accesskey="p" href="introduction.html" title=
          "Introduction">Précédent</a>
          <p>
            Introduction
          </p>
        </li>
        <li class="next">
          <a accesskey="n" href="generalinstructions.html" title=
          "Instructions générales de compilation">Suivant</a>
          <p>
            Instructions générales de compilation
          </p>
        </li>
        <li class="up">
          <a accesskey="u" href="partintro.html" title=
          "Informations préliminaires importantes">Niveau supérieur</a>
        </li>
        <li class="home">
          <a accesskey="h" href="../index.html" title=
          "Linux From Scratch - Version r10.1-212-g6711c-systemd+">Sommaire</a>
        </li>
      </ul>
    </div>
  </body>
</html>
