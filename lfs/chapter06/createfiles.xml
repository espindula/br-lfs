<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
  "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../general.ent">
  %general-entities;
]>

<sect1 id="ch-system-createfiles">
  <?dbhtml filename="createfiles.html"?>

  <title>Créer les fichiers et les liens symboliques essentiels</title>

  <indexterm zone="ch-system-createfiles">
    <primary sortas="e-/etc/passwd">/etc/passwd</primary>
  </indexterm>

  <indexterm zone="ch-system-createfiles">
    <primary sortas="e-/etc/group">/etc/group</primary>
  </indexterm>

  <indexterm zone="ch-system-createfiles">
    <primary sortas="e-/var/run/utmp">/var/run/utmp</primary>
  </indexterm>

  <indexterm zone="ch-system-createfiles">
    <primary sortas="e-/var/log/btmp">/var/log/btmp</primary>
  </indexterm>

  <indexterm zone="ch-system-createfiles">
    <primary sortas="e-/var/log/lastlog">/var/log/lastlog</primary>
  </indexterm>

  <indexterm zone="ch-system-createfiles">
    <primary sortas="e-/var/log/wtmp">/var/log/wtmp</primary>
  </indexterm>

  <para>Certains programmes stockent en dur des chemins vers des programmes qui
  n'existent pas encore. Pour satisfaire ces programmes, créez un certain nombre
  de liens symboliques qui seront remplacés par les vrais fichiers tout au long
  de ce chapitre une fois que tous les logiciels seront installés&nbsp;:</para>

<screen><userinput>ln -sv /tools/bin/{bash,cat,echo,pwd,stty} /bin
ln -sv /tools/bin/perl /usr/bin
ln -sv /tools/lib/libgcc_s.so{,.1} /usr/lib
ln -sv /tools/lib/libstdc++.so{,.6} /usr/lib
sed 's/tools/usr/' /tools/lib/libstdc++.la > /usr/lib/libstdc++.la
ln -sv bash /bin/sh</userinput></screen>
 
  <variablelist>
    <title>Voici l'objectif de chaque lien&nbsp;:</title>

    <varlistentry>
      <term><parameter><filename>/bin/bash</filename></parameter></term>
      <listitem>
        <para>De nombreux scripts <command>bash</command> spécifient 
        <filename>/bin/bash</filename>.</para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><parameter><filename>/bin/cat</filename></parameter></term>
      <listitem>
        <para>Ce chemin est codé en dur dans le script configure de Glibc.</para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><parameter><filename>/bin/echo</filename></parameter></term>
      <listitem>
        <para>Ceci pour satisfaire un des tests de la suite de tests de Glibc,
        qui attend <filename>/bin/echo</filename>.</para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><parameter><filename>/bin/pwd</filename></parameter></term>
      <listitem>
        <para>Certains scripts <command>configure</command>, en particulier celui
        de Glibc, ont codé en dur ce chemin.</para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><parameter><filename>/bin/stty</filename></parameter></term>
      <listitem>
        <para>Ce chemin est codé en dur dans Expect, il est donc nécessaire pour la
        réussite des suites de tests de Binutils et de GCC.</para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><parameter><filename>/usr/bin/perl</filename></parameter></term>
      <listitem>
        <para>De nombreux scripts Perl codent en dur ce chemin vers le programme
        <command>perl</command>.</para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><parameter><filename>/usr/lib/libgcc_s.so{,.1}</filename></parameter></term>
      <listitem>
        <para>Glibc en a besoin pour que la bibliothèque pthreads fonctionne.</para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><parameter><filename>/usr/lib/libstdc++{,.6}</filename></parameter></term>
      <listitem>
        <para>Ceci est exigé par plusieurs tests de la suite de tests de Glibc
        et pour le support C++ de GMP.</para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><parameter><filename>/usr/lib/libstdc++.la</filename></parameter></term>
      <listitem>
        <para>Cela empêche une référence à <filename class="directory">/tools</filename>
         qui serait dans
        <filename>/usr/lib/libstdc++.la</filename> après l'installation de GCC.</para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><parameter><filename>/bin/sh</filename></parameter></term>
      <listitem>
        <para>Beaucoup de scripts shell codent en dur <filename>/bin/sh</filename>.</para>
      </listitem>
    </varlistentry>

  </variablelist>

  <para>Historiquement, Linux gère la liste des systèmes de fichiers montés dans
  le fichier <filename>/etc/mtab</filename>. Les noyaux modernes gèrent cette
  liste en interne via le système de fichiers <filename class="directory">/proc</filename>.
  Pour contenter les outils qui s'attendent à la présence de <filename>/etc/mtab</filename>, 
  créez le lien symbolique suivant&nbsp;:</para>

<screen><userinput>ln -sv /proc/self/mounts /etc/mtab</userinput></screen>
  <para>Afin que l'utilisateur <systemitem class="username">root</systemitem> 
  puisse s'identifier et que le nom <quote>root</quote> soit reconnu, 
  il doit y avoir des entrées cohérentes dans les fichiers
  <filename>/etc/passwd</filename> et <filename>/etc/group</filename>.</para>

  <para>Créez le fichier <filename>/etc/passwd</filename> en lançant
  la commande suivante&nbsp;:</para>

<screen><userinput>cat &gt; /etc/passwd &lt;&lt; "EOF"
<literal>root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/dev/null:/bin/false
daemon:x:6:6:Daemon User:/dev/null:/bin/false
messagebus:x:18:18:D-Bus Message Daemon User:/var/run/dbus:/bin/false
nobody:x:99:99:Unprivileged User:/dev/null:/bin/false</literal>
EOF</userinput></screen>

  <para>Le mot de passe actuel pour
  <systemitem class="username">root</systemitem> (le <quote>x</quote> utilisé
  est seulement un exemple) sera paramétré plus tard.</para>

  <para>Créez le fichier <filename>/etc/group</filename> en exécutant la
  commande suivante&nbsp;:</para>

<screen><userinput>cat &gt; /etc/group &lt;&lt; "EOF"
<literal>root:x:0:
bin:x:1:daemon
sys:x:2:
kmem:x:3:
tape:x:4:
tty:x:5:
daemon:x:6:
floppy:x:7:
disk:x:8:
lp:x:9:
dialout:x:10:
audio:x:11:
video:x:12:
utmp:x:13:
usb:x:14:
cdrom:x:15:
adm:x:16:
messagebus:x:18:
systemd-journal:x:23:
mail:x:34:
nogroup:x:99:
users:x:999:</literal>
EOF</userinput></screen>

  <para>Les groupes créés ne font partie d'aucun standard&mdash;ce sont 
  des groupes décidés en partie en fonction des besoins de la configuration de
  Udev dans ce chapitre, et en partie par la coutume utilisée par un certain
  nombre de distributions Linux existantes. En outre, certaines suites de tests
  s'appuient sur des groupes et des utilisateurs spécifiques. Le base linux standard (Linux
  Standard Base ou LSB, disponible sur
  <ulink url="http://www.linuxbase.org"/>) recommande seulement cela,
  ainsi que la présence d'un groupe
  <systemitem class="groupname">root</systemitem> (GID 0) et d'un groupe 
  <systemitem class="groupname">bin</systemitem> (GID 1).
  Tous les autres noms de groupe et GID peuvent être librement choisis par
  l'administrateur du système puisque les programmes bien écrits ne dépendent pas
  des numéros GID, mais utilisent plutôt le nom du groupe.</para>

  <para>Pour supprimer l'invite <quote>I have no name!</quote>, démarrez un
  nouveau shell. Comme nous avons installé une Glibc complète dans le
  <xref linkend="chapter-temporary-tools"/> et créé les fichiers
  <filename>/etc/passwd</filename> et <filename>/etc/group</filename>, la
  résolution du nom d'utilisateur et de groupe fonctionnera à présent&nbsp;:</para>

<screen role="nodump"><userinput>exec /tools/bin/bash --login +h</userinput></screen>

  <para>Remarquez l'utilisation du paramètre <parameter>+h</parameter>.
  Il dit à <command>bash</command> de ne pas utiliser son hachage de chemin
  interne. Sans ce paramètre, <command>bash</command> se rappelerait des
  chemins vers les binaires qu'il a exécutés. Pour s'assurer que les
  binaires nouvellement compilés seront utilisés dès qu'ils seront installés,
  le paramètre <parameter>+h</parameter> sera utilisée durant tout le
  chapitre.</para>

  <para>Les programmes <command>login</command>, <command>agetty</command>, et
  <command>init</command> (et d'autres) utilisent un nombre de journaux
  applicatifs pour enregistrer des informations comme qui s'est connecté sur
  le système et quand. Mais ces programmes n'écriront pas vers ces journaux
  s'ils n'existent pas. Initialisez les journaux et donnez-leur les bons
  droits&nbsp;:</para>

<screen><userinput>touch /var/log/{btmp,lastlog,faillog,wtmp}
chgrp -v utmp /var/log/lastlog
chmod -v 664  /var/log/lastlog
chmod -v 600  /var/log/btmp</userinput></screen>

  <para>Le fichier <filename>/var/log/wtmp</filename> enregistre toutes les
  connexions et les déconnexions. Le fichier <filename>/var/log/faillog</filename> enregistre
  les échecs des tentatives de connexion. Le fichier
  <filename>/var/log/btmp</filename> enregistre les tentatives de connexion
  échouées.</para>

  <note><para>Le fichier <filename>/run/utmp</filename> enregistre les
  utilisateurs qui sont actuellement connectés. Ce fichier est créé de manière 
  dynamique dans les scripts de démarrage.</para></note>

</sect1>
