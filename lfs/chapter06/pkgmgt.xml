<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
  "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../general.ent">
  %general-entities;
]>

<sect1 id="ch-system-pkgmgt">
  <?dbhtml filename="pkgmgt.html"?>

  <title>Gestion de paquets</title>

  <para>La gestion de paquets est un ajout souvent demandé au livre
  LFS. Un gestionnaire de paquets permet de conserver une trace des
  fichiers installés, simplifiant ainsi leur suppression ou leur mise à
  jour. Un gestionnaire de paquets gérera tant les fichiers binaires et de
  bibliothèque que l'installation des fichiers de configuration. Avant tout,
  NON&mdash;cette section ne parle pas d'un gestionnaire
   de paquets particulier, elle n'en recommande pas non plus. Elle fait
  un tour des techniques les plus populaires pour indiquer comment elles
  fonctionnent. Le parfait gestionnaire de paquets pourrait faire
  partie de ces techniques ou pourrait être une combinaison d'une ou
  plusieurs techniques. Cette section mentionne brièvement les problèmes
  pouvant survenir lors de la mise à jour des paquets.</para>

  <para>Parmi les raisons de l'absence d'un gestionnaire de paquets
  mentionné dans LFS ou BLFS&nbsp;:</para>

  <itemizedlist>
    <listitem>
      <para>S'occuper de la gestion de paquets est en dehors des buts de ces
      livres&mdash; visant à apprendre comment un système Linux est construit.</para>
    </listitem>

    <listitem>
      <para>Il existe de nombreuses solutions pour la gestion de paquets,
chacune ayant ses forces et ses faiblesses. En inclure une qui
satisfait tout le monde est difficile.</para>
    </listitem>
  </itemizedlist>

  <para>Des astuces ont été écrites sur le thème de la gestion de
  paquets. Visitez le <ulink url="&hints-index;">Projet des
  astuces</ulink> et voyez celui qui satisfait vos besoins.</para>

  <sect2>
    <title>Problèmes de mise à jour</title>

    <para>Un gestionnaire de paquets facilite la mise à jour des
nouvelles versions au moment de leur sortie. Généralement, les
instructions dans les livres LFS et BLFS peuvent être utilisées pour les
nouvelles versions. Voici quelques points à connaître pour une mise à
jour de paquets, spécifiquement sur un système en cours de
fonctionnement</para>

    <itemizedlist>
      <listitem>
        <para>Il est plus sûr, si Glibc doit être mis à jour vers une nouvelle
        version (par exemple, glibc-2.19 vers glibc-2.20), de reconstruire LFS.
        Bien que vous <emphasis>pourriez</emphasis>
        être capable de ne pas reconstruire tous les paquets dans leur ordre
        de dépendances, nous ne vous le recommandons pas.</para>
      </listitem>

      <listitem>
        <para>Si un paquet contenant une bibliothèque partagée est mise à jour et
        si le nom de cette dernière est modifié, alors les paquets liés
        dynamiquement à la bibliothèque devront être recompilés pour être liés
        à la nouvelle bibliothèque. (Remarquez qu'il n'y a aucune corrélation entre
        la version du paquet et le nom de la bibliothèque.) Par exemple,
        considérez un paquet foo-1.2.3 qui installe une bibliothèque
        partagée de nom
        <filename class='libraryfile'>libfoo.so.1</filename>.
        Disons que vous mettez à jour le
        paquet avec une nouvelle version foo-1.2.4 qui installe une
        bibliothèque partagée de nom
        <filename class='libraryfile'>libfoo.so.2</filename>. Dans ce cas, tous les
        paquets liés dynamiquement à
        <filename class='libraryfile'>libfoo.so.1</filename> doivent être recompilés
        pour être liés à
        <filename class='libraryfile'>libfoo.so.2</filename>. Remarquez que vous ne devez pas supprimer
             les anciennes bibliothèques jusqu'à ce que les paquets indépendants
             soient recompilés.</para>
      </listitem>
    </itemizedlist>

  </sect2>

  <sect2>
    <title>Techniques de gestion de paquets</title>

    <para>Ce qui suit est une liste de techniques habituelles de gestion de
     paquets. Avant de prendre une décision sur un gestionnaire de
      paquets, faites une recherche sur les différentes techniques et
      notamment leurs faiblesses.</para>

    <sect3>
      <title>Tout est dans ma tête&nbsp;!</title>

      <para>Oui, c'est une technique de gestion de paquets. Certains n'éprouvent
      pas le besoin d'un gestionnaire de paquets parce qu'ils connaissent
      très bien les paquets et connaissent les fichiers installés par chaque
      paquet. Certains utilisateurs n'en ont pas besoin parce qu'ils
      planifient la reconstruction entière de LFS lorsqu'un paquet est
      modifié.</para>

    </sect3>

    <sect3>
      <title>Installer dans des répertoires séparés</title>

      <para>C'est une gestion des paquets tellement simple qu'elle ne nécessite
      aucun paquet supplémentaire pour gérer les installations. Chaque
      paquet est installé dans un répertoire séparé. Par exemple, le
      paquet foo-1.1 est installé dans
      <filename class='directory'>/usr/pkg/foo-1.1</filename>
      et un lien symbolique est créé de
      <filename>/usr/pkg/foo</filename> vers
      <filename class='directory'>/usr/pkg/foo-1.1</filename>. Lors de l'installation de
      la nouvelle version foo-1.2, elle est installée dans
      <filename class='directory'>/usr/pkg/foo-1.2</filename>
      et l'ancien lien symbolique est remplacé par un lien symbolique vers la
      nouvelle version.</para>

      <para>Les variables d'environnement telles que <envar>PATH</envar>,
      <envar>LD_LIBRARY_PATH</envar>, <envar>MANPATH</envar>,
      <envar>INFOPATH</envar> et <envar>CPPFLAGS</envar>
      ont besoin d'être étendues pour inclure
      <filename>/usr/pkg/foo</filename>. Pour plus que quelques paquets, ce
      schéma devient ingérable.</para>

    </sect3>

    <sect3>
      <title>Gestion de paquet par lien symbolique</title>

      <para>C'est une variante de la technique précédente. Chaque paquet est
        installé de façon similaire au schéma précédent. Mais au lieu de réaliser
        le lien symbolique, chaque fichier dispose d'un lien symbolique vers
        son équivalent dans la hiérarchie
      <filename class='directory'>/usr</filename>. Ceci supprime le besoin d'étendre les variables
      d'environnement. Bien que les liens symboliques peuvent être créés par
      l'utilisateur, pour automatiser la création, certains gestionnaires de
      paquets ont été écrits avec cette approche. Parmi les plus populaires se
      trouvent Stow, Epkg, Graft et Depot.</para>

      <para>L'installation doit être faussée, de façon à ce que chaque paquet pense
        qu'il est installé dans
       <filename class="directory">/usr</filename> alors qu'en réalité il est installé dans la
       hiérarchie <filename class="directory">/usr/pkg</filename>.
       Installer de cette manière n'est généralement pas une
       tâche triviale. Par exemple, considérez que vous installez un paquet
       libfoo-1.1. Les instructions suivantes pourraient ne pas installer
       correctement le paquet&nbsp;:</para>

<screen role="nodump"><userinput>./configure --prefix=/usr/pkg/libfoo/1.1
make
make install</userinput></screen>

      <para>L'installation fonctionnera mais les paquets dépendants pourraient ne
      pas lier libfoo comme vous vous y attendriez. Si vous compilez un
      paquet qui se lie à
      <filename class='libraryfile'>/usr/pkg/libfoo/1.1/lib/libfoo.so.1</filename>
      au lieu de <filename class='libraryfile'>/usr/lib/libfoo.so.1</filename>
      comme vous le prévoyez. La bonne approche est d'utiliser la stratégie
      <envar>DESTDIR</envar> pour fausser l'installation du paquet. Cette approche
      fonctionne ainsi&nbsp;:</para>

<screen role="nodump"><userinput>./configure --prefix=/usr
make
make DESTDIR=/usr/pkg/libfoo/1.1 install</userinput></screen>

      <para>La plupart des paquets supportent cette approche mais elle pose
      problème à certains. Pour les paquets non compatibles, vous pouvez soit
      les installer manuellement soit trouver plus simple d'installer les
      paquets problématiques dans
      <filename class='directory'>/opt</filename>.</para>

    </sect3>

    <sect3>
      <title>Basé sur le temps</title>

      <para>Avec cette technique, un fichier est balisé avec l'heure avant
      l'installation du paquet. Après l'installation, une simple utilisation
      de la commande
      <command>find</command> avec les options appropriées peut générer une trace de
      tous les fichiers installés après que le fichier temps ne soit créé.
      install-log est un gestionnaire de paquets écrit avec cette approche.</para>

      <para>Bien que ce schéma a l'avantage d'être simple, il a deux inconvénients. Si
      à l'installation, les fichiers sont installés sans balise de temps autre
      que l'heure actuelle, ces fichiers ne seront pas suivis par le
      gestionnaire de paquets. De plus, ce schéma peut seulement être utilisé
      lorsqu'un seul paquet est installé à la fois. Les traces ne sont pas
      fiables si deux paquets sont installés dans deux consoles différentes.</para>

    </sect3>

    <sect3>
      <title>Tracer les scripts d'installation</title>

      <para>Avec cette approche, les commandes que les scripts d'installation
      accomplissent sont enregistrées. Il y a deux techniques que vous pouvez utiliser&nbsp;:</para>

      <para>Vous pouvez initialiser la variable d'environnement <envar>LD_PRELOAD</envar>
      pour qu'elle pointe vers une bibliothèque à précharger avant l'installation.
      Lors de l'utilisation de cette dernière, cette bibliothèque trace les
      paquets en cours d'installation en s'attachant eux-même aux différents exécutables comme <command>cp</command>,
      <command>install</command>, <command>mv</command> et trace les appels système qui modifient le système
      de fichiers. Pour que cette approche fonctionne, tous les exécutables ont
      besoin d'être liés dynamiquement sans bit suid ou sgid. Le préchargement
      de la bibliothèque pourrait causer quelques effets de bord involontaires
      lors de l'installation ; donc, réalisez quelques tests pour vous assurer
      que le gestionnaire de paquets ne casse rien et trace bien tous les
      fichiers appropriés.</para>

      <para>La seconde technique est d'utiliier <command>strace</command>,
      qui trace tous les appels du système faits pendant l'exécution des
      scripts d'installation.</para>
    </sect3>

    <sect3>
      <title>Créer des archives de paquets</title>

      <para>Dans ce schéma, l'installation d'un paquet est faussée dans un
      répertoire séparé comme décrit plus haut. Après l'installation, une
      archive du paquet est créée en utilisant les fichiers installés.
      L'archive est ensuite utilisée pour installer le paquet soit sur la
      machine locale soit même sur d'autres machines.</para>

      <para>Cette approche est utilisée par la plupart des gestionnaires de paquets
        trouvés dans les distributions commerciales. Les exemples de gestionnaires
        qui suivent cette approche sont RPM (qui est parfois requis par la
      <ulink url="http://refspecs.linuxfoundation.org/lsb.shtml">Spécification
      de base de Linux Standard</ulink>), pkg-utils, apt de Debian, et le
      système de portage de Gentoo. Une astuce décrivant comment adopter ce
      style de gestion de paquets pour les systèmes LFS se trouve à
      <ulink url="http://www.fr.linuxfromscratch.org/view/astuces/fakeroot.txt"/>.</para>

      <para>La création de fichiers de paquet qui incluent des informations de dépendance est complexe et va au-delà de
      l'objectif de LFS.</para>

      <para>Slackware utilise un système basé sur <command>tar</command> pour les archives de paquets. Ce système ne gère
      volontairement pas les dépendances de paquets car d'autres gestionnaires de paquets plus complexes le font. Pour des
      détails sur la gestion de paquets, voir <ulink url="http://www.slackbook.org/html/package-management.html"/>.</para>
    </sect3>

    <sect3>
      <title>Gestion basée sur les utilisateurs</title>

      <para>Ce schéma, unique à LFS, a été décrit par Matthias Benkmann et est
      disponible sur le <ulink url="&hints-index;">Projet des astuces</ulink>.
      Dans ce schéma, chaque paquet
      est installé en tant qu'utilisateur séparé dans les emplacements
      standards. Les fichiers appartenant à un paquet sont facilement
      identifiés grâce à l'identifiant de l'utilisateur. Les fonctionnalités et
      avantages de cette approche sont trop complexes pour les décrire dans
      cette section. Pour plus de détails, voir l'astuce sur
      <ulink url="http://www.fr.linuxfromscratch.org/view/astuces/gestionnaire-paquets-utilisateur.txt"/>.</para>

    </sect3>

  </sect2>

  <sect2>
    <title>Déployer LFS sur plusieurs systèmes</title>

    <para>Un des avantages du système LFS est qu'il n'y a pas de fichiers dépendant de la position des fichiers sur un
    système de disque. Cloner la construction d'un système LFS sur un autre ordinateur avec une architecture similaire au
    système de base est aussi facile que l'utilisation de <command>tar</command> sur la partition LFS qui contient le
    répertoire racine (environ 250Mo décompressés pour une construction LFS de base), en copiant ce fichier via un
    transfère par réseau ou par CD-ROM vers le nouveau système et en le décompressant. À partir de là, vous devrez modifier
    quelques fichiers de configuration. Les fichiers de configuration que vous pouvez devoir mettre à jour
    comprennent&nbsp;:
    <filename>/etc/hosts</filename>,
    <filename>/etc/fstab</filename>,
    <filename>/etc/passwd</filename>,
    <filename>/etc/group</filename>,
    <filename>/etc/shadow</filename>,
    <filename>/etc/ld.so.conf</filename>,
    <filename>/etc/sysconfig/rc.site</filename>,
    <filename>/etc/sysconfig/network</filename>, et
    <filename>/etc/sysconfig/ifconfig.eth0</filename>.
    </para>

    <para>Vous pouvez construire un noyau personnalisé pour le nouveau système, selon les différences du matériel du système
    avec la configuration du noyau initial.</para>

    <para>Enfin, vous devez rendre le nouveau système amorçable via <xref
    linkend="ch-bootable-grub"/>.</para>

  </sect2>

</sect1>
