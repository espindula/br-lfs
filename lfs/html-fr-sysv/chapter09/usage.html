<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8" />
    <title>
      9.6.&nbsp;Utiliser et configurer les scripts de démarrage de System V
    </title>
    <link rel="stylesheet" type="text/css" href="../stylesheets/lfs.css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.78.1" />
    <link rel="stylesheet" href="../stylesheets/lfs-print.css" type=
    "text/css" media="print" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  </head>
  <body class="lfs" id="lfs-r10.1-205-g49170+">
    <div class="navheader">
      <h4>
        Linux From Scratch - Version r10.1-205-g49170+
      </h4>
      <h3>
        Chapitre&nbsp;9.&nbsp;Configuration du système
      </h3>
      <ul>
        <li class="prev">
          <a accesskey="p" href="network.html" title=
          "Configuration générale du réseau">Précédent</a>
          <p>
            Configuration générale du réseau
          </p>
        </li>
        <li class="next">
          <a accesskey="n" href="profile.html" title=
          "Fichiers de démarrage du shell Bash">Suivant</a>
          <p>
            Fichiers de démarrage du shell Bash
          </p>
        </li>
        <li class="up">
          <a accesskey="u" href="chapter09.html" title=
          "Chapitre&nbsp;9.&nbsp;Configuration du système">Niveau
          supérieur</a>
        </li>
        <li class="home">
          <a accesskey="h" href="../index.html" title=
          "Linux From Scratch - Version r10.1-205-g49170+ ">Sommaire</a>
        </li>
      </ul>
    </div>
    <div class="sect1" lang="fr" xml:lang="fr">
      <h1 class="sect1">
        <a id="ch-config-usage" name="ch-config-usage"></a>9.6. Utiliser et
        configurer les scripts de démarrage de System V
      </h1>
      <div class="sect2" lang="fr" xml:lang="fr">
        <h2 class="sect2">
          9.6.1. Comment fonctionnent les scripts de démarrage de System
          V&nbsp;?
        </h2>
        <p>
          Linux utilise un service de démarrage spécial nommé SysVinit qui
          est basé sur un concept de <span class="emphasis"><em>niveaux
          d'exécution</em></span>. Il peut être très différent d'un système à
          un autre, du coup, il ne peut pas être supposé que parce que cela
          fonctionne sur une distribution Linux particulière, cela
          fonctionnera de la même façon dans LFS. LFS a sa propre façon de le
          faire mais il respecte généralement les standards établis.
        </p>
        <p>
          SysVinit (qui sera nommé par la suite <span class=
          "quote">«&nbsp;<span class="quote">init</span>&nbsp;»</span>)
          fonctionne en utilisant un schéma de niveaux d'exécution. Ils sont
          au nombre de sept (numérotés de 0 à 6). En fait, il en existe plus
          mais ils sont réservés à des cas spéciaux et ne sont généralement
          pas utilisés. Voir <code class="filename">init(8)</code> pour plus
          de détails. Chacun d'entre eux correspond à des actions que
          l'ordinateur est supposé effectuer lorsqu'il démarre. Le niveau
          d'exécution par défaut est 3. Voici les descriptions sur
          l'implémentation des différents niveaux d'exécution&nbsp;:
        </p>
        <div class="literallayout">
          <p>
            0:&nbsp;arrête&nbsp;l'ordinateur<br />
            1:&nbsp;mode&nbsp;mono-utilisateur<br />
            2:&nbsp;mode&nbsp;multi-utilisateur&nbsp;sans&nbsp;réseau<br />
            3:&nbsp;mode&nbsp;multi-utilisateur&nbsp;avec&nbsp;réseau<br />
            4:&nbsp;réservé&nbsp;pour&nbsp;la&nbsp;personnalisation,&nbsp;sinon&nbsp;identique&nbsp;à&nbsp;3<br />

            5:&nbsp;identique&nbsp;à&nbsp;4,&nbsp;il&nbsp;est&nbsp;habituellement&nbsp;utilisé&nbsp;pour&nbsp;la&nbsp;connexion&nbsp;GUI&nbsp;(comme&nbsp;<span class="command"><strong>xdm</strong></span>&nbsp;de&nbsp;X&nbsp;ou&nbsp;<span class="command"><strong>kdm</strong></span>&nbsp;de&nbsp;KDE)<br />

            6:&nbsp;redémarre&nbsp;l'ordinateur
          </p>
        </div>
      </div>
      <div class="configuration" lang="fr" xml:lang="fr">
        <h2 class="sect2">
          <a id="conf-sysvinit" name="conf-sysvinit"></a>9.6.2. Configuration
          de Sysvinit
        </h2>
        <p>
          Lors de l'initialisation du noyau, le premier programme qui se
          lance est soit spécifié sur la ligne de commande, soit, par défaut,
          <span class="command"><strong>init</strong></span>. Ce programme
          lit le fichier d'initialisation <code class=
          "filename">/etc/inittab</code>. Créez ce fichier avec&nbsp;:
        </p>
        <pre class="userinput"><kbd class=
        "command">cat &gt; /etc/inittab &lt;&lt; "EOF"
<code class="literal"># Début de /etc/inittab

id:3:initdefault:

si::sysinit:/etc/rc.d/init.d/rc S

l0:0:wait:/etc/rc.d/init.d/rc 0
l1:S1:wait:/etc/rc.d/init.d/rc 1
l2:2:wait:/etc/rc.d/init.d/rc 2
l3:3:wait:/etc/rc.d/init.d/rc 3
l4:4:wait:/etc/rc.d/init.d/rc 4
l5:5:wait:/etc/rc.d/init.d/rc 5
l6:6:wait:/etc/rc.d/init.d/rc 6

ca:12345:ctrlaltdel:/sbin/shutdown -t1 -a -r now

su:S016:once:/sbin/sulogin

1:2345:respawn:/sbin/agetty --noclear tty1 9600
2:2345:respawn:/sbin/agetty tty2 9600
3:2345:respawn:/sbin/agetty tty3 9600
4:2345:respawn:/sbin/agetty tty4 9600
5:2345:respawn:/sbin/agetty tty5 9600
6:2345:respawn:/sbin/agetty tty6 9600

# Fin de /etc/inittab</code>
EOF</kbd></pre>
        <p>
          Vous trouverez une explication de ce fichier d'initialisation dans
          la page de manuel de <span class=
          "emphasis"><em>inittab</em></span>. Pour LFS, la commande clé qui
          se lance est <span class="command"><strong>rc</strong></span>. Le
          fichier d'initialisation ci-dessus demandera à <span class=
          "command"><strong>rc</strong></span> de lancer tous les scripts
          commençant par un S qui sont dans le répertoire <code class=
          "filename">/etc/rc.d/rcS.d</code>, puis tous les scripts commençant
          par un S du répertoire <code class=
          "filename">/etc/rc.d/rc?.d</code> où le point d'interrogation est
          spécifié par la valeur initdefault.
        </p>
        <p>
          Par commodité, le script <span class=
          "command"><strong>rc</strong></span> lit une bibliothèque de
          fonctions dans <code class=
          "filename">/lib/lsb/init-functions</code>. Cette bibliothèque lit
          aussi un fichier de configuration facultatif, <code class=
          "filename">/etc/sysconfig/rc.site</code>. Tous les paramètres du
          fichier de configuration du système décrits dans les sections
          suivantes peuvent être mis dans ce fichier, ce qui permet de
          rassembler tous les paramètres systèmes dans un seul fichier.
        </p>
        <p>
          Pour faciliter le débogage, le script functions enregistre aussi
          toute la sortie dans <code class=
          "filename">/run/var/bootlog</code>. Le répertoire <code class=
          "filename">/run</code> étant un tmpfs, ce fichier n'est pas
          persistant entre les redémarrages, il est cependant envoyé dans le
          fichier plus permanent <code class=
          "filename">/var/log/boot.log</code> à la fin du processus de
          démarrage.
        </p>
        <div class="sect3">
          <h3 class="sect3">
            <a id="init-levels" name="init-levels"></a>9.6.2.1. Modifier les
            niveaux d'exécution
          </h3>
          <p>
            La commande utilisée pour modifier le niveau d'exécution est
            <span class="command"><strong>init <em class=
            "replaceable"><code>&lt;[niveau_exécution]&gt;</code></em></strong></span>,
            où <em class=
            "replaceable"><code>&lt;[niveau_exécution]&gt;</code></em> est le
            niveau d'exécution cible. Par exemple, pour redémarrer
            l'ordinateur, un utilisateur pourrait lancer la commande
            <span class="command"><strong>init 6</strong></span> qui est un
            alias de la commande <span class=
            "command"><strong>reboot</strong></span>. De même, <span class=
            "command"><strong>init 0</strong></span> est un alias pour la
            commande <span class="command"><strong>halt</strong></span>.
          </p>
          <p>
            Il existe un certain nombre de répertoires sous <code class=
            "filename">/etc/rc.d</code> qui ressemble à <code class=
            "filename">rc?.d</code> (où ? est le numéro du niveau
            d'exécution) et <code class="filename">rcsysinit.d</code>, tous
            contenant un certain nombre de liens symboliques. Certains
            commencent par un <span class="emphasis"><em>K</em></span>, les
            autres par un <span class="emphasis"><em>S</em></span>, et tous
            ont deux nombres après la lettre initiale. Le K signifie l'arrêt
            (kill) d'un service et le S son lancement (start). Les nombres
            déterminent l'ordre dans lequel les scripts sont exécutés, de 00
            à 99 —&nbsp;plus ce nombre est petit, plus tôt le script
            correspondant sera exécuté. Quand <span class=
            "command"><strong>init</strong></span> bascule sur un autre
            niveau d'exécution, les services appropriés sont soit lancés soit
            tués, suivant le niveau d'exécution choisi.
          </p>
          <p>
            Les vrais scripts sont dans <code class=
            "filename">/etc/rc.d/init.d</code>. Ils font le vrai boulot et
            les liens symboliques pointent tous vers eux. Les liens K et les
            liens S pointent vers le même script dans <code class=
            "filename">/etc/rc.d/init.d</code>. Ceci est dû au fait que les
            scripts peuvent être appelés avec différents paramètres comme
            <em class="parameter"><code>start</code></em>, <em class=
            "parameter"><code>stop</code></em>, <em class=
            "parameter"><code>restart</code></em>, <em class=
            "parameter"><code>reload</code></em> et <em class=
            "parameter"><code>status</code></em>. Quand un lien K est
            rencontré, le script approprié est lancé avec l'argument
            <em class="parameter"><code>stop</code></em>. Quand un lien S est
            rencontré, le script approprié est lancé avec l'argument
            <em class="parameter"><code>start</code></em>.
          </p>
          <p>
            Il y a une exception à cette explication. Les liens qui
            commencent par un <span class="emphasis"><em>S</em></span> dans
            les dossiers <code class="filename">rc0.d</code> et <code class=
            "filename">rc6.d</code> ne vont rien faire pour être démarrés.
            Ils seront appelés avec le paramètre <em class=
            "parameter"><code>stop</code></em> pour arrêter quelque chose. La
            logique sous-jacente est que quand un utilisateur est en train de
            redémarrer ou arrêter le système, rien ne nécessite d'être
            démarré. Le système a seulement besoin d'être arrêté.
          </p>
          <p>
            Voici les descriptions de ce que font les arguments des
            scripts&nbsp;:
          </p>
          <div class="variablelist">
            <dl class="variablelist">
              <dt>
                <span class="term"><em class=
                "parameter"><code>start</code></em></span>
              </dt>
              <dd>
                <p>
                  Le service est lancé.
                </p>
              </dd>
              <dt>
                <span class="term"><em class=
                "parameter"><code>stop</code></em></span>
              </dt>
              <dd>
                <p>
                  Le service est stoppé.
                </p>
              </dd>
              <dt>
                <span class="term"><em class=
                "parameter"><code>restart</code></em></span>
              </dt>
              <dd>
                <p>
                  Le service est stoppé puis relancé.
                </p>
              </dd>
              <dt>
                <span class="term"><em class=
                "parameter"><code>reload</code></em></span>
              </dt>
              <dd>
                <p>
                  La configuration du service est mise à jour. Ceci est
                  utilisé après modification du fichier de configuration d'un
                  service, quand le service n'a pas besoin d'être redémarré.
                </p>
              </dd>
              <dt>
                <span class="term"><em class=
                "parameter"><code>status</code></em></span>
              </dt>
              <dd>
                <p>
                  Indique si le service est en cours d'exécution ainsi que
                  les PID associés.
                </p>
              </dd>
            </dl>
          </div>
          <p>
            Vous êtes libre de modifier la façon dont le processus de
            démarrage fonctionne (après tout, c'est votre système LFS). Les
            fichiers donnés ici sont un exemple d'une façon de faire.
          </p>
        </div>
      </div>
      <div class="sect2" lang="fr" xml:lang="fr">
        <h2 class="sect2">
          9.6.3. Les scripts de démarrage Udev
        </h2>
        <p>
          Le script de démarrage <code class=
          "filename">/etc/rc.d/init.d/udev</code> lance <span class=
          "command"><strong>udevd</strong></span>, récupère les périphériques
          "branchés à froid" créés d'ores et déjà par le noyau et attend des
          règles pour se terminer. Le script supprime aussi du gestionnaire
          d'uevent le réglage par défaut <code class=
          "filename">/sbin/hotplug</code> . On fait cela car le noyau n'a
          plus besoin de faire appel à un binaire externe. Par contre,
          <span class="command"><strong>udevd</strong></span> va écouter sur
          un socket netlink les uevents engendrés par le noyau.
        </p>
        <p>
          Le script de démarrage <span class=
          "command"><strong>/etc/rc.d/init.d/udev_retry</strong></span> se
          charge de récupérer les événements des sous-systèmes dont les
          règles s'appuient sur des systèmes de fichiers non montés jusqu'à
          ce que le script <span class=
          "command"><strong>mountfs</strong></span>soit lancé (en
          particulier, <code class="filename">/usr</code> et <code class=
          "filename">/var</code> peuvent avoir cet effet). Ce script
          s'exécute après le script <span class=
          "command"><strong>mountfs</strong></span>, donc ces règles (si
          elles sont de nouveau récupérées) devraient s'appliquer la deuxième
          fois. Il se configure à partir du fichier <code class=
          "filename">/etc/sysconfig/udev_retry</code>&nbsp;; donc tout mot
          autre que des commentaires dans ce fichier est vu comme un nom de
          sous-système à rattraper lorsqu'il lance le nouvel essai. Pour
          trouver le sous-système d'un périphérique, utilisez <span class=
          "command"><strong>udevadm info --attribute-walk
          &lt;périphérique&gt;</strong></span> où &lt;périphérique&gt; est un
          chemin absolu dans /dev ou /sys comme /dev/sr0 ou /sys/class/rtc.
        </p>
        <p>
          Pour plus d'informations sur le chargement des modules du noyau et
          udev, consultez <a class="xref" href="udev.html#module-loading"
          title="9.3.2.3.&nbsp;Chargement d'un module">Section&nbsp;9.3.2.3,
          «&nbsp;Chargement d'un module&nbsp;»</a>.
        </p>
      </div>
      <div class="sect2" lang="fr" xml:lang="fr">
        <h2 class="sect2">
          <a id="ch-config-clock" name="ch-config-clock"></a>9.6.4.
          Configurer l'horloge du système
        </h2>
        <p>
          Le script <span class="command"><strong>setclock</strong></span>
          lit l'heure à partir de l'horloge matérielle, appelée aussi horloge
          BIOS ou <span class="foreignphrase"><em class=
          "foreignphrase">Complementary Metal Oxide Semiconductor</em></span>
          (CMOS). Si l'horloge matérielle est réglée sur UTC, ce script
          convertira l'heure de l'horloge matérielle en heure locale en
          utilisant le fichier <code class="filename">/etc/localtime</code>
          (qui indique au programme <span class=
          "command"><strong>hwclock</strong></span> le fuseau horaire de
          l'utilisateur). Il n'y a aucun moyen de détecter si l'horloge
          matérielle est réglée sur UTC, donc vous devez le configurer
          manuellement.
        </p>
        <p>
          Le script <span class="command"><strong>setclock</strong></span> se
          lance via <span class="application">udev</span> quand le noyau
          détecte le matériel au démarrage. Vous pouvez aussi le lancer à la
          main avec le paramètre stop pour stocker l'heure du système dans
          l'horloge CMOS.
        </p>
        <p>
          Si vous ne vous rappelez pas si l'horloge matérielle est réglée sur
          UTC, assurez-vous-en en lançant la commande <strong class=
          "userinput"><code>hwclock --localtime --show</code></strong>. Cela
          affichera l'heure actuelle selon l'horloge matérielle. Si elle
          correspond à ce qu'indique votre montre, l'horloge matérielle est
          en heure locale. Si la sortie de <span class=
          "command"><strong>hwclock</strong></span> n'est pas l'heure locale,
          il y a des chances qu'il s'agisse de l'heure UTC. Vérifiez-le en
          ajoutant ou enlevant le bon nombre d'heures du fuseau horaire de
          l'heure affichée avec <span class=
          "command"><strong>hwclock</strong></span>. Par exemple, si vous
          êtes dans le fuseau MST, connu aussi sous le nom GMT -0700, ajoutez
          sept heures à l'heure locale.
        </p>
        <p>
          Changez la valeur de la variable <code class="envar">UTC</code>
          ci-dessous en <em class="parameter"><code>0</code></em> (zéro) si
          l'horloge matérielle <span class="emphasis"><em>n'est
          pas</em></span> réglée sur l'heure UTC.
        </p>
        <p>
          Créez un nouveau fichier <code class=
          "filename">/etc/sysconfig/clock</code> en lançant ce qui
          suit&nbsp;:
        </p>
        <pre class="userinput"><kbd class=
        "command">cat &gt; /etc/sysconfig/clock &lt;&lt; "EOF"
<code class="literal"># Début de /etc/sysconfig/clock

UTC=1

# Mettez ici les options que vous pourriez devoir donner à hwclock,
# comme le type de l'horloge matérielle de la machine pour les Alphas.
CLOCKPARAMS=

# Fin de /etc/sysconfig/clock</code>
EOF</kbd></pre>
        <p>
          Une bonne astuce expliquant la gestion de l'heure sur LFS est
          disponible sur <a class="ulink" href=
          "http://www.fr.linuxfromscratch.org/view/astuces/heure.txt">http://www.fr.linuxfromscratch.org/view/astuces/heure.txt</a>.
          Elle traite de sujets tels que les fuseaux horaires, UTC et la
          variable d'environnement <code class="envar">TZ</code>.
        </p>
        <div class="admon note">
          <img alt="[Note]" src="../images/note.png" />
          <h3>
            Note
          </h3>
          <p>
            Vous pouvez aussi régler les paramètres CLOCKPARAMS et UTC dans
            le fichier <code class="filename">/etc/sysconfig/rc.site</code>.
          </p>
        </div>
      </div>
      <div class="sect2" lang="fr" xml:lang="fr">
        <h2 class="sect2">
          <a id="ch-config-console" name="ch-config-console"></a>9.6.5.
          Configurer la Console Linux
        </h2>
        <p>
          Cette section discute de la configuration du script de démarrage
          <span class="command"><strong>console</strong></span>, qui
          initialise la disposition du clavier, la police de la console et le
          niveau de journalisation du noyau. Si vous n'utilisez pas les
          caractères non-ASCII (par exemple le symbole du copyright, de la
          livre sterling et de l'euro) et que le clavier est américain, la
          plupart de cette section peut être sautée. Sans ce fichier de
          configuration, (ou des options équivalentes dans <code class=
          "filename">rc.site</code>), le script de démarrage <span class=
          "command"><strong>console</strong></span> ne fera rien.
        </p>
        <p>
          Le script <span class="command"><strong>console</strong></span> lit
          les informations de configuration du fichier <code class=
          "filename">/etc/sysconfig/console</code>. Il décide de la
          disposition de clavier et de la police de la console à utiliser.
          Différents guides pratiques spécifiques aux langues peuvent aussi
          être d'une grande aide (voir <a class="ulink" href=
          "http://www.tldp.org/HOWTO/HOWTO-INDEX/other-lang.html">http://www.tldp.org/HOWTO/HOWTO-INDEX/other-lang.html</a>).
          Si vous avez toujours des doutes, jetez un œil dans les répertoires
          <code class="filename">/usr/share/keymaps</code> et <code class=
          "filename">/usr/share/consolefonts</code> pour des dispositions de
          clavier valides et des polices d'écran. Lisez les pages de manuel
          <code class="filename">loadkeys(1)</code> et <code class=
          "filename">setfont(8)</code> pour déterminer les bons arguments
          pour ces programmes.
        </p>
        <p>
          Le fichier <code class="filename">/etc/sysconfig/console</code>
          devrait contenir des lignes de la forme&nbsp;: VARIABLE="valeur".
          Les variables suivantes sont reconnues&nbsp;:
        </p>
        <div class="variablelist">
          <dl class="variablelist">
            <dt>
              <span class="term">LOGLEVEL</span>
            </dt>
            <dd>
              <p>
                Cette variable spécifie le niveau de traçage pour les
                messages du noyau envoyés à la console, selon le paramétrage
                de <span class="command"><strong>dmesg -n</strong></span>.
                Les niveaux valides vont de «&nbsp;1&nbsp;» (aucun message) à
                «&nbsp;8&nbsp;». Le niveau par défaut est «&nbsp;7&nbsp;».
              </p>
            </dd>
            <dt>
              <span class="term">KEYMAP</span>
            </dt>
            <dd>
              <p>
                Cette variable spécifie les arguments du programme
                <span class="command"><strong>loadkeys</strong></span>, en
                général, le nom de l'arrangement du clavier à charger, comme
                <span class="quote">«&nbsp;<span class=
                "quote">it</span>&nbsp;»</span>. Si cette variable n'est pas
                initialisée, le script de démarrage ne lancera pas le
                programme <span class=
                "command"><strong>loadkeys</strong></span> et l'arrangement
                par défaut du noyau sera utilisé. Remarquez qu'un petit
                nombre d'arrangements ont plusieurs versions avec le même nom
                (cz avec ses variantes dans qwerty/ et qwertz/, es dans olpc/
                et qwerty/, et trf dans fgGlod/ et qwerty/). Dans ce cas, le
                répertoire parent doit être spécifié (par exemple qwerty/es)
                pour s'assurer que l'arrangement adéquat est chargé.
              </p>
            </dd>
            <dt>
              <span class="term">KEYMAP_CORRECTIONS</span>
            </dt>
            <dd>
              <p>
                Cette variable (rarement utilisée) spécifie les arguments du
                second appel au programme <span class=
                "command"><strong>loadkeys</strong></span>. C'est utile si la
                disposition du clavier stocké n'est pas totalement
                satisfaisant et que vous devez faire un petit ajustement. Par
                exemple, pour inclure le signe Euro dans une disposition de
                clavier qui ne l'a normalement pas, réglez cette variable à
                <span class="quote">«&nbsp;<span class=
                "quote">euro2</span>&nbsp;»</span>.
              </p>
            </dd>
            <dt>
              <span class="term">FONT</span>
            </dt>
            <dd>
              <p>
                Cette variable spécifie les arguments du programme
                <span class="command"><strong>setfont</strong></span>. En
                principe, ceci inclut le nom de la police, <span class=
                "quote">«&nbsp;<span class="quote">-m</span>&nbsp;»</span> et
                le nom de la disposition de clavier de l'application à
                charger. Par exemple, pour charger la police <span class=
                "quote">«&nbsp;<span class=
                "quote">lat1-16</span>&nbsp;»</span> avec la disposition de
                clavier de l'application <span class=
                "quote">«&nbsp;<span class=
                "quote">8859-1</span>&nbsp;»</span>, (comme il convient aux
                États-Unis), réglez cette variable à <span class=
                "quote">«&nbsp;<span class="quote">lat1-16 -m
                8859-1</span>&nbsp;»</span>. En mode UTF-8, le noyau utilise
                la disposition de clavier de l'application pour la conversion
                de codes de touche 8-bits composés dans la disposition de
                clavier en UTF-8, et ainsi vous devriez initialiser
                l'argument du paramètre "-m" à l'encodage des codes de touche
                composés dans la disposition de clavier.
              </p>
            </dd>
            <dt>
              <span class="term">UNICODE</span>
            </dt>
            <dd>
              <p>
                Réglez cette variable à <span class=
                "quote">«&nbsp;<span class="quote">1</span>&nbsp;»</span>,
                <span class="quote">«&nbsp;<span class=
                "quote">yes</span>&nbsp;»</span> ou <span class=
                "quote">«&nbsp;<span class="quote">true</span>&nbsp;»</span>
                afin de mettre la console en mode UTF-8. Ceci est utile pour
                les locales basées sur UTF-8 et nuisible sinon.
              </p>
            </dd>
            <dt>
              <span class="term">LEGACY_CHARSET</span>
            </dt>
            <dd>
              <p>
                Pour beaucoup de types de clavier, il n'y a pas de
                disposition de clavier pour le stock Unicode dans le paquet
                Kbd. Le script de démarrage <span class=
                "command"><strong>console</strong></span> convertira une
                disposition de clavier disponible en UTF-8 au vol si cette
                variable est réglée à l'encodage de la disposition du clavier
                non UTF-8 disponible.
              </p>
            </dd>
          </dl>
        </div>
        <p>
          Quelques exemples&nbsp;:
        </p>
        <div class="itemizedlist">
          <ul>
            <li class="listitem">
              <p>
                Pour une initialisation non Unicode, en général seules les
                variables KEYMAP et FONT sont nécessaires. Par exemple, pour
                l'initialisation en polonais, on utiliserait&nbsp;:
              </p>
              <pre class="userinput"><kbd class=
              "command">cat &gt; /etc/sysconfig/console &lt;&lt; "EOF"
<code class="literal"># Début de /etc/sysconfig/console

KEYMAP="pl2"
FONT="lat2a-16 -m 8859-2"

# Fin de /etc/sysconfig/console</code>
EOF</kbd></pre>
            </li>
            <li class="listitem">
              <p>
                Comme mentionné ci-dessus, il est parfois nécessaire
                d'ajuster légèrement une disposition de clavier stockée.
                L'exemple suivant ajoute le symbole Euro a la disposition
                allemande du clavier&nbsp;:
              </p>
              <pre class="userinput"><kbd class=
              "command">cat &gt; /etc/sysconfig/console &lt;&lt; "EOF"
<code class="literal"># Begin /etc/sysconfig/console

KEYMAP="de-latin1"
KEYMAP_CORRECTIONS="euro2"
FONT="lat0-16 -m 8859-15"
UNICODE="1"

# End /etc/sysconfig/console</code>
EOF</kbd></pre>
            </li>
            <li class="listitem">
              <p>
                Ce qui suit est un exemple avec l'Unicode activé pour le
                bulgare, où une disposition du clavier UTF-8 stockée
                existe&nbsp;:
              </p>
              <pre class="userinput">
<kbd class="command">cat &gt; /etc/sysconfig/console &lt;&lt; "EOF"
<code class="literal"># Début de /etc/sysconfig/console

UNICODE="1"
KEYMAP="bg_bds-utf8"
FONT="LatArCyrHeb-16"

# Fin de /etc/sysconfig/console</code>
EOF</kbd></pre>
            </li>
            <li class="listitem">
              <p>
                Du fait de l'utilisation d'une police 512 glyphes
                LatArCyrHeb-16 dans l'exemple précédent, les couleurs
                brillantes ne sont plus disponibles sur la console Linux à
                moins d'utiliser un framebuffer. Si vous voulez avoir les
                couleurs brillantes sans framebuffer et que vous pouvez vivre
                sans caractère n'appartenant pas à votre langue, il est
                encore possible d'utiliser une police 256 glyphes spécifique
                à votre langue, comme illustré ci-dessous&nbsp;:
              </p>
              <pre class="userinput"><kbd class=
              "command">cat &gt; /etc/sysconfig/console &lt;&lt; "EOF"
<code class="literal"># Début de /etc/sysconfig/console

UNICODE="1"
KEYMAP="bg_bds-utf8"
FONT="cyr-sun16"

# Fin de /etc/sysconfig/console</code>
EOF</kbd></pre>
            </li>
            <li class="listitem">
              <p>
                L'exemple suivant illustre l'auto-conversion de la
                disposition de clavier d'ISO-8859-15 vers UTF-8 et
                l'activation des touches mortes en mode Unicode&nbsp;:
              </p>
              <pre class="userinput"><kbd class=
              "command">cat &gt; /etc/sysconfig/console &lt;&lt; "EOF"
<code class="literal"># Début de /etc/sysconfig/console

UNICODE="1"
KEYMAP="de-latin1"
KEYMAP_CORRECTIONS="euro2"
LEGACY_CHARSET="iso-8859-15"
FONT="LatArCyrHeb-16 -m 8859-15"

# Fin de /etc/sysconfig/console</code>
EOF</kbd></pre>
            </li>
            <li class="listitem">
              <p>
                Certaines dispositions de codage ont des touches mortes
                (c-à-d que les touches ne produisent pas un caractère en
                elles-mêmes, mais mettent un accent sur le caractère produit
                par la touche suivante) ou définissent des règles de
                comportement (comme&nbsp;: <span class=
                "quote">«&nbsp;<span class="quote">Appuyez sur Ctrl+. A E
                pour obtenir Æ</span>&nbsp;»</span> dans la disposition du
                clavier par défaut). Linux-5.13.12 n'interprète correctement
                les touches mortes et les règles de composition que quand les
                caractères sources qui seront composés ensemble sont
                multi-octet. Ce défaut n'affecte pas les dispositions de
                clavier pour les langues européennes, car les accents sont
                ajoutés à des caractères ASCII non accentués, ou deux
                caractères ASCII sont composés ensemble. Néanmoins en mode
                UTF-8, c'est un problème, comme pour la langue grecque, où on
                a parfois besoin de mettre un accent sur la lettre
                <span class="quote">«&nbsp;<span class=
                "quote">alpha</span>&nbsp;»</span>. La solution consiste soit
                à éviter d'utiliser UTF-8, soit à installer le système de
                fenêtrage X qui n'a pas cette limitation dans sa gestion de
                l'entrée.
              </p>
            </li>
            <li class="listitem">
              <p>
                Pour le chinois, le Japonais, le Coréen et certaines autres
                langues, la console Linux ne peut pas être configurée pour
                afficher les caractères nécessaires. Les utilisateurs qui ont
                besoin de telles langues devraient installer le système de
                fenêtrage X, dont les polices couvrent la plage de caractères
                nécessaire et qui a la bonne méthode d'entrée (par exemple
                SCIM prend en charge une large variété de langues).
              </p>
            </li>
          </ul>
        </div>
        <div class="admon note">
          <img alt="[Note]" src="../images/note.png" />
          <h3>
            Note
          </h3>
          <p>
            Le fichier <code class="filename">/etc/sysconfig/console</code>
            ne contrôle que la localisation de la console texte de Linux.
            Cela n'a rien à voir avec le bon paramétrage du type de clavier
            et des polices du terminal dans le système de fenêtrage X, avec
            les sessions ssh ou une console série. Dans de telles situations,
            les limitations mentionnées dans les deux derniers points de la
            liste ci-dessus ne s'appliquent pas.
          </p>
        </div>
      </div>
      <div class="sect2" lang="fr" xml:lang="fr">
        <h2 class="sect2">
          <a id="ch-config-createfiles" name=
          "ch-config-createfiles"></a>9.6.6. Créer des fichiers au démarrage
        </h2>
        <p>
          Parfois, on veut créer des fichiers lors du démarrage. Par exemple,
          le répertoire <code class="filename">/tmp/.ICE-unix</code> est
          souvent requis. Vous pouvez le faire en créant une entrée dans le
          script de configuration <code class=
          "filename">/etc/sysconfig/createfiles</code>. Le format de ce
          fichier est indiqué dans les commentaires du fichier de
          configuration par défaut.
        </p>
      </div>
      <div class="sect2" lang="fr" xml:lang="fr">
        <h2 class="sect2">
          <a id="ch-config-sysklogd" name="ch-config-sysklogd"></a>9.6.7.
          Configurer le script sysklogd
        </h2>
        <p>
          Le script <code class="filename">sysklogd</code> invoque le
          programme <span class="command"><strong>syslogd</strong></span>
          faisant partie de l'initialisation par System V. L'option
          <em class="parameter"><code>-m 0</code></em> désactive la marque
          périodique que <span class=
          "command"><strong>syslogd</strong></span> écrit par défaut dans les
          fichiers journaux toutes les 20 minutes. Si vous voulez activer cet
          horodatage, éditez <code class=
          "filename">/etc/sysconfig/rc.site</code> et définissez la variable
          SYSKLOGD_PARMS à la valeur désirée. Par exemple, pour supprimer
          tous les paramètres, réglez la variable à la valeur null&nbsp;:
        </p>
        <pre class="screen">SYSKLOGD_PARMS=</pre>
        <p>
          Voir <strong class="userinput"><code>man syslogd</code></strong>
          pour plus d'options.
        </p>
      </div>
      <div class="sect2" lang="fr" xml:lang="fr">
        <h2 class="sect2">
          <a id="ch-config-site" name="ch-config-site"></a>9.6.8. Le fichier
          rc.site
        </h2>
        <p>
          Le fichier facultatif <code class=
          "filename">/etc/sysconfig/rc.site</code> contient les paramètres
          réglés automatiquement pour chaque script de démarrage de System V.
          Il peut aussi contrôler les valeurs des fichiers <code class=
          "filename">hostname</code>, <code class="filename">console</code>
          et <code class="filename">clock</code> du répertoire <code class=
          "filename">/etc/sysconfig/</code>. Si les variables associées se
          trouvent à la fois dans ces fichiers distincts et dans <code class=
          "filename">rc.site</code>, les valeurs des fichiers spécifiques ont
          la préséance.
        </p>
        <p>
          <code class="filename">rc.site</code> contient aussi des paramètres
          pour personnaliser d'autres aspects du processus de démarrage. Le
          réglage de la variable IPROMPT permettra un lancement sélectif des
          scripts de démarrage. D'autres options sont décrites dans les
          commentaires du fichier. La version par défaut du fichier est
          ci-dessous&nbsp;:
        </p>
        <pre class="auto">
# rc.site
# Optional parameters for boot scripts.

# Distro Information
# These values, if specified here, override the defaults
#DISTRO="Linux From Scratch" # The distro name
#DISTRO_CONTACT="lfs-dev@linuxfromscratch.org" # Bug report address
#DISTRO_MINI="LFS" # Short name used in filenames for distro config

# Define custom colors used in messages printed to the screen

# Please consult `man console_codes` for more information
# under the "ECMA-48 Set Graphics Rendition" section
#
# Warning: when switching from a 8bit to a 9bit font,
# the linux console will reinterpret the bold (1;) to
# the top 256 glyphs of the 9bit font.  This does
# not affect framebuffer consoles

# These values, if specified here, override the defaults
#BRACKET="\\033[1;34m" # Blue
#FAILURE="\\033[1;31m" # Red
#INFO="\\033[1;36m"    # Cyan
#NORMAL="\\033[0;39m"  # Grey
#SUCCESS="\\033[1;32m" # Green
#WARNING="\\033[1;33m" # Yellow

# Use a colored prefix
# These values, if specified here, override the defaults
#BMPREFIX="      "
#SUCCESS_PREFIX="${SUCCESS}  *  ${NORMAL} "
#FAILURE_PREFIX="${FAILURE}*****${NORMAL} "
#WARNING_PREFIX="${WARNING} *** ${NORMAL} "

# Manually seet the right edge of message output (characters)
# Useful when resetting console font during boot to override
# automatic screen width detection
#COLUMNS=120

# Interactive startup
#IPROMPT="yes" # Whether to display the interactive boot prompt
#itime="3"    # The amount of time (in seconds) to display the prompt

# The total length of the distro welcome string, without escape codes
#wlen=$(echo "Welcome to ${DISTRO}" | wc -c )
#welcome_message="Welcome to ${INFO}${DISTRO}${NORMAL}"

# The total length of the interactive string, without escape codes
#ilen=$(echo "Press 'I' to enter interactive startup" | wc -c )
#i_message="Press '${FAILURE}I${NORMAL}' to enter interactive startup"

# Set scripts to skip the file system check on reboot
#FASTBOOT=yes

# Skip reading from the console
#HEADLESS=yes

# Write out fsck progress if yes
#VERBOSE_FSCK=no

# Speed up boot without waiting for settle in udev
#OMIT_UDEV_SETTLE=y

# Speed up boot without waiting for settle in udev_retry
#OMIT_UDEV_RETRY_SETTLE=yes

# Skip cleaning /tmp if yes
#SKIPTMPCLEAN=no

# For setclock
#UTC=1
#CLOCKPARAMS=

# For consolelog (Note that the default, 7=debug, is noisy)
#LOGLEVEL=7

# For network
#HOSTNAME=mylfs

# Delay between TERM and KILL signals at shutdown
#KILLDELAY=3

# Optional sysklogd parameters
#SYSKLOGD_PARMS="-m 0"

# Console parameters
#UNICODE=1
#KEYMAP="de-latin1"
#KEYMAP_CORRECTIONS="euro2"
#FONT="lat0-16 -m 8859-15"
#LEGACY_CHARSET=

</pre>
        <div class="sect3">
          <h3 class="sect3">
            9.6.8.1. Personnaliser les scripts de démarrage et d'extinction
          </h3>
          <p>
            Les scripts de démarrage LFS démarrent et arrêtent un système
            d'une façon très efficace, mais vous pouvez faire quelques
            bidouillages dans le fichier rc.site pour améliorer encore
            davantage la vitesse et ajuster les messages selon vos
            préférences. Pour cela, ajustez les paramètres du fichier
            <code class="filename">/etc/sysconfig/rc.site</code> ci-dessus.
          </p>
          <div class="itemizedlist">
            <ul>
              <li class="listitem">
                <p>
                  Pendant le script de démarrage <code class=
                  "filename">udev</code>, un appel à <span class=
                  "command"><strong>udev settle</strong></span> demande du
                  temps pour s'achever. Ce temps peut être ou pas nécessaire
                  pour des périphériques présents dans votre système. Si vous
                  n'avez que des partitions simples et une seule carte
                  ethernet, le processus de démarrage n'aura probablement pas
                  besoin d'attendre cette commande. Pour la sauter,
                  définissez la variable OMIT_UDEV_SETTLE=y.
                </p>
              </li>
              <li class="listitem">
                <p>
                  Le script de démarrage <code class=
                  "filename">udev_retry</code> lance aussi par défaut
                  <span class="command"><strong>udev settle</strong></span>.
                  Cette commande n'est nécessaire par défaut que si le
                  répertoire <code class="filename">/var</code> est monté
                  séparément. Ceci car la vérification a besoin du fichier
                  <code class="filename">/var/lib/hwclock/adjtime</code>.
                  D'autres personnalisations peuvent nécessiter d'attendre
                  qu'udev se termine mais dans beaucoup d'installations, ce
                  n'est pas nécessaire. Sautez la commande en définissant la
                  variable OMIT_UDEV_RETRY_SETTLE=y.
                </p>
              </li>
              <li class="listitem">
                <p>
                  Par défaut, les vérifications des systèmes de fichiers sont
                  sans message. Cela peut être vu comme un délai pendant le
                  processus de démarrage. Pour activer la sortie de
                  <span class="command"><strong>fsck</strong></span>,
                  définissez la variable VERBOSE_FSCK=y.
                </p>
              </li>
              <li class="listitem">
                <p>
                  Lors du redémarrage, il se peut que vous vouliez sauter la
                  vérification du système de fichiers, <span class=
                  "command"><strong>fsck</strong></span>, complètement. Pour
                  cela, soit créez le fichier <code class=
                  "filename">/fastboot</code>, soit redémarrez le système
                  avec la commande <span class=
                  "command"><strong>/sbin/shutdown -f -r now</strong></span>.
                  Inversement, vous pouvez forcer la vérification de tous les
                  systèmes de fichiers en créant <code class=
                  "filename">/forcefsck</code> ou en lançant <span class=
                  "command"><strong>shutdown</strong></span> avec le
                  paramètre <em class="parameter"><code>-F</code></em> plutôt
                  que <em class="parameter"><code>-f</code></em>.
                </p>
                <p>
                  La définition de la variable FASTBOOT=y désactivera
                  <span class="command"><strong>fsck</strong></span> lors du
                  processus de démarrage jusqu'à ce qu'il soit supprimé. Ce
                  n'est pas recommandé de façon permanente.
                </p>
              </li>
              <li class="listitem">
                <p>
                  En principe, tous les fichiers du répertoire <code class=
                  "filename">/tmp</code> sont effacés au moment du démarrage.
                  Selon le nombre de fichiers ou de répertoires présents,
                  cela peut provoquer un délai important dans le processus de
                  démarrage. Pour sauter la suppression de ces fichiers,
                  définissez la variable SKIPTMPCLEAN=y.
                </p>
              </li>
              <li class="listitem">
                <p>
                  Lors de l'extinction, le programme <span class=
                  "command"><strong>init</strong></span> envoie un signal
                  TERM à chaque programme qu'il a démarré (comme agetty), il
                  attend un moment de définition (par défaut, 3 secondes), et
                  il envoie à chaque processus un signal KILL puis attend de
                  nouveau. Ce processus se répète dans le script <span class=
                  "command"><strong>sendsignals</strong></span> pour tous les
                  processus non terminés par leurs propres scripts. Le délai
                  de <span class="command"><strong>init</strong></span> peut
                  être défini en passant un paramètre. Par exemple, pour
                  supprimer le délai dans <span class=
                  "command"><strong>init</strong></span>, passez le paramètre
                  -t0 lors de l'extinction ou du redémarrage (comme
                  <span class="command"><strong>/sbin/shutdown -t0 -r
                  now</strong></span>). Le délai du script <span class=
                  "command"><strong>sendsignals</strong></span> peut être
                  sauté en définissant le paramètre KILLDELAY=0.
                </p>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
    <div class="navfooter">
      <ul>
        <li class="prev">
          <a accesskey="p" href="network.html" title=
          "Configuration générale du réseau">Précédent</a>
          <p>
            Configuration générale du réseau
          </p>
        </li>
        <li class="next">
          <a accesskey="n" href="profile.html" title=
          "Fichiers de démarrage du shell Bash">Suivant</a>
          <p>
            Fichiers de démarrage du shell Bash
          </p>
        </li>
        <li class="up">
          <a accesskey="u" href="chapter09.html" title=
          "Chapitre&nbsp;9.&nbsp;Configuration du système">Niveau
          supérieur</a>
        </li>
        <li class="home">
          <a accesskey="h" href="../index.html" title=
          "Linux From Scratch - Version r10.1-205-g49170+ ">Sommaire</a>
        </li>
      </ul>
    </div>
  </body>
</html>
