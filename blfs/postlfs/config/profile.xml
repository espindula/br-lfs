<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../../general.ent">
  %general-entities;
]>
<sect1 id="postlfs-config-profile" xreflabel="Les fichiers de démarrage du shell Bash">
  <?dbhtml filename="profile.html"?>
  <sect1info>
    <othername>$LastChangedBy&nbsp;: randy $</othername>
    <date>$Date&nbsp;: 2012-12-19 20:57:20 +0100 (Wed, 19 Dec 2012) $</date>
  </sect1info>
  <title>Les fichiers de démarrage du shell Bash</title>
  <para>Le programme de shell <filename>/bin/bash</filename> (auquel on se
  référera ci-après sous le nom de « shell » utilise un ensemble de fichiers de
  démarrage pour aider à la création d'un environnement. Chaque fichier a une
  utilisation spécifique et il peut concerner différemment la connexion et les
  environnements interactifs. Les fichiers du répertoire
 <filename class="directory">/etc</filename> fournissent en général les
 paramètres globaux. Si un fichier équivalent existe dans votre répertoire
 home, il peut remplacer les paramètres globaUx.</para>
  <para>Un shell de connexion interactif démarre après une connexion réussie,
  en utilisant <filename>/bin/login</filename>, en lisant le fichier
  <filename>/etc/passwd</filename>. Cet appel du shell lit normalement
  <filename>/etc/profile</filename> et son équivalent privé
  <filename>~/.bash_profile</filename> au démarrage.</para>
  <para>Un shell de non connexion interactif démarre normalement en ligne de
  commande en utilisant un programme de shell (comme
  <prompt>[prompt]$</prompt><command>/bin/bash</command>) ou par la commande
  <command>/bin/su</command>. Un shell de non-connexion interactif démarre 
  également avec un programme de terminal tel que <command>xterm</command> ou
  <command>konsole</command> depuis un environnement graphique. Ce type d'appel
  de shell copie normalement l'environnement parent puis lit le fichier
  <filename>~/.bashrc</filename> de l'utilisateur pour des instructions de
  configuration de démarrage supplémentaires.</para>
  <para>Un shell non interactif est présent en général lorsqu'un script shell 
  s'exécute. Il n'est pas interactif car il exécute un script et n'attend
  pas d'entrée de l'utilisateur entre les commandes. Pour ces appels de shell,
  seul l'environnement hérité du shell parent est utilisé.</para>
  <para>Le fichier <filename>~/.bash_logout</filename> n'est pas utilisé pour
  un appel du shell. Il est lu et exécuté lorsqu'un utilisateur quitte un shell
  de connexion interactif.</para>
  <para>De nombreuses distributions utilisent <filename>/etc/bashrc</filename> pour
  l'initialisation pour tout le système de shells de non connexion. Ce fichier 
  est en général appelé depuis le fichier <filename>~/.bashrc</filename> de
  l'utilisateur et il n'est pas construit directement dans
  <command>bash</command> lui-même. On suit cette convention dans cette section.</para>
  <para>Pour plus d'informations, voir <command>info bash</command> --
  <emphasis role="strong">Nodes: Bash Startup Files et Interactive
  Shells</emphasis>.</para>
  <note>
    <para>La plupart des instructions ci-dessous sont utilisées pour créer des 
    fichiers qui se trouvent dans la structure de répertoires
    <filename class='directory'>/etc</filename>, ce qui implique que vous exécutiez
    les commandes en tant qu'utilisateur 
    <systemitem class='username'>root</systemitem>. Si vous optez plutôt pour la 
    création des fichiers dans le répertoire home de l'utilisateur, vous devriez
    lancer les commandes en tant qu'utilisateur non privilégié.</para>
  </note>
  <sect2 id="etc-profile-profile">
    <title>/etc/profile</title>
    <indexterm zone="postlfs-config-profile etc-profile-profile">
      <primary sortas="e-etc-profile">/etc/profile</primary>
    </indexterm>
    <para>Voici un <filename>/etc/profile</filename> de base. Ce fichier
    démarre en paramétrant des fonctions d'aide et quelques paramètres de base.
    Il spécifie des paramètres d'historique de <command>bash</command> et, 
    pour des raisons de sécurité, il désactive la conservation d'un fichier 
    d'historique permanent pour l'utilisateur <systemitem class="username">root</systemitem>.
    Il paramètre aussi un invite utilisateur par défaut. Il appelle ensuite de
    petits scripts à finalité unique dans le répertoire
    <filename class='directory'>/etc/profile.d</filename> pour fournir la
    plupart de l'initialisation.</para>
    <para>Pour plus d'informations sur les séquences d'échappement que vous pouvez
    utiliser pour votre invite (à savoir la variable d'environnement 
    <envar>PS1</envar>) voir <command>info
    bash</command> -- <emphasis role="strong">Node: Printing a
    Prompt</emphasis>.</para>
<screen role="root">
<?dbfo keep-together="auto"?><userinput>cat &gt; /etc/profile &lt;&lt; "EOF"
<literal># Begin /etc/profile
# Written for Beyond Linux From Scratch
# by James Robertson &lt;jameswrobertson@earthlink.net&gt;
# modifications by Dagmar d'Surreal &lt;rivyqntzne@pbzpnfg.arg&gt;
# System wide environment variables and startup programs.
# System wide aliases and functions should go in /etc/bashrc.  Personal
# environment variables and startup programs should go into
# ~/.bash_profile.  Personal aliases and functions should go into
# ~/.bashrc.
# Functions to help us manage paths.  Second argument is the name of the
# path variable to be modified (default: PATH)
pathremove () {
        local IFS=':'
        local NEWPATH
        local DIR
        local PATHVARIABLE=${2:-PATH}
        for DIR in ${!PATHVARIABLE} ; do
                if [ "$DIR" != "$1" ] ; then
                  NEWPATH=${NEWPATH:+$NEWPATH:}$DIR
                fi
        done
        export $PATHVARIABLE="$NEWPATH"
}
pathprepend () {
        pathremove $1 $2
        local PATHVARIABLE=${2:-PATH}
        export $PATHVARIABLE="$1${!PATHVARIABLE:+:${!PATHVARIABLE}}"
}
pathappend () {
        pathremove $1 $2
        local PATHVARIABLE=${2:-PATH}
        export $PATHVARIABLE="${!PATHVARIABLE:+${!PATHVARIABLE}:}$1"
}
# Set the initial path
export PATH=/bin:/usr/bin
if [ $EUID -eq 0 ] ; then
        pathappend /sbin:/usr/sbin
        unset HISTFILE
fi
# Setup some environment variables.
export HISTSIZE=1000
export HISTIGNORE="&amp;:[bf]g:exit"
# Setup a red prompt for root and a green one for users.
NORMAL="\[\e[0m\]"
RED="\[\e[1;31m\]"
GREEN="\[\e[1;32m\]"
if [[ $EUID == 0 ]] ; then
  PS1="$RED\u [ $NORMAL\w$RED ]# $NORMAL"
else
  PS1="$GREEN\u [ $NORMAL\w$GREEN ]\$ $NORMAL"
fi
for script in /etc/profile.d/*.sh ; do
        if [ -r $script ] ; then
                . $script
        fi
done
# Now to clean up
unset pathremove pathprepend pathappend
# End /etc/profile</literal>
EOF</userinput>
</screen>
    <sect3 id="etc-profile.d">
      <title>Le répertoire /etc/profile.d</title>
      <indexterm zone="postlfs-config-profile etc-profile.d">
        <primary sortas="e-etc-profile.d">/etc/profile.d</primary>
      </indexterm>
      <para>Maintenant créez le répertoire <filename class='directory'>/etc/profile.d</filename>,
      où sont mis les scripts d'initialisation individuels&nbsp;:</para>
<screen role="root">
<userinput>install --directory --mode=0755 --owner=root --group=root /etc/profile.d</userinput>
</screen>
    </sect3>
    <sect3 id="etc-profile.d-dircolors.sh">
      <title>/etc/profile.d/dircolors.sh</title>
      <indexterm zone="postlfs-config-profile etc-profile.d-dircolors.sh">
        <primary sortas="e-etc-profile.d-dircolors.sh">/etc/profile.d/dircolors.sh</primary>
      </indexterm>
      <para>Ce script utilise les fichiers <filename>~/.dircolors</filename> et
      <filename>/etc/dircolors</filename> pour contrôler les couleurs des noms
      de fichiers dans la liste du contenu d'un répertoire. Ils contrôlent la
      sortie en couleurs d'éléments tels que <command>ls
      --color</command>.  L'explication de la façon d'initialiser ces fichiers
      se trouvent à la fin de cette section.</para>
<screen role="root">
<userinput>cat &gt; /etc/profile.d/dircolors.sh &lt;&lt; "EOF"
<literal># Setup for /bin/ls to support color, the alias is in /etc/bashrc.
if [ -f "/etc/dircolors" ] ; then
        eval $(dircolors -b /etc/dircolors)
        if [ -f "$HOME/.dircolors" ] ; then
                eval $(dircolors -b $HOME/.dircolors)
        fi
fi
alias ls='ls --color=auto'</literal>
EOF</userinput>
</screen>
    </sect3>
    <sect3 id="extrapaths.sh">
      <title>/etc/profile.d/extrapaths.sh</title>
      <indexterm zone="postlfs-config-profile extrapaths.sh">
        <primary sortas="e-etc-profile.d-extrapaths.sh">/etc/profile.d/extrapaths.sh</primary>
      </indexterm>
      <para>Ce script ajoute plusieurs chemins utiles aux variables d'environnement
      <envar>PATH</envar> et <envar>PKG_CONFIG_PATH</envar>. Si vous le voulez,
      vous pouvez décommenter la dernière section pour mettre un point à la fin
      de votre chemin. Ceci permettra aux exécutables du répertoire de travail
      actuel de s'exécuter sans spécifier de ./, mais soyez averti que ceci
      est en général considéré comme un risque de sécurité.</para>
<screen role="root">
<userinput>cat &gt; /etc/profile.d/extrapaths.sh &lt;&lt; "EOF"
<literal>if [ -d /usr/local/lib/pkgconfig ] ; then
        pathappend /usr/local/lib/pkgconfig PKG_CONFIG_PATH
fi
if [ -d /usr/local/bin ]; then
        pathprepend /usr/local/bin
fi
if [ -d /usr/local/sbin -a $EUID -eq 0 ]; then
        pathprepend /usr/local/sbin
fi
if [ -d ~/bin ]; then
        pathprepend ~/bin
fi
#if [ $EUID -gt 99 ]; then
#        pathappend .
#fi</literal>
EOF</userinput>
</screen>
    </sect3>
    <sect3 id="readline.sh">
      <title>/etc/profile.d/readline.sh</title>
      <indexterm zone="postlfs-config-profile readline.sh">
        <primary sortas="e-etc-profile.d-readline.sh">/etc/profile.d/readline.sh</primary>
      </indexterm>
      <para>Ce script règle le  fichier de configuration <filename>inputrc</filename>
      par défaut. Si l'utilisateur n'a pas de paramètres individuels, il
      utilise le fichier global.</para>
<screen role="root">
<userinput>cat &gt; /etc/profile.d/readline.sh &lt;&lt; "EOF"
<literal># Setup the INPUTRC environment variable.
if [ -z "$INPUTRC" -a ! -f "$HOME/.inputrc" ] ; then
        INPUTRC=/etc/inputrc
fi
export INPUTRC</literal>
EOF</userinput>
</screen>
    </sect3>
    <sect3 id="umask.sh">
      <title>/etc/profile.d/umask.sh</title>
      <indexterm zone="postlfs-config-profile umask.sh">
        <primary sortas="e-etc-profile.d-umask.sh">/etc/profile.d/umask.sh</primary>
      </indexterm>
      <para>Le paramétrage de la valeur <command>umask</command> est important 
      pour la sécurité. Ici, les droits d'écriture par défaut du groupe sont
      désactivés pour les utilisateurs systèmes et quand le nom d'utilisateur et
      le nom du groupe ne sont pas les mêmes.</para>
<screen role="root">
<userinput>cat &gt; /etc/profile.d/umask.sh &lt;&lt; "EOF"
<literal># By default, the umask should be set.
if [ "$(id -gn)" = "$(id -un)" -a $EUID -gt 99 ] ; then
  umask 002
else
  umask 022
fi</literal>
EOF</userinput>
</screen>
    </sect3>
    <sect3 id="i18n.sh">
      <title>/etc/profile.d/i18n.sh</title>
    <indexterm zone="postlfs-config-profile i18n.sh">
      <primary sortas="e-etc-profile.d-i18n.sh">/etc/profile.d/i18n.sh</primary>
    </indexterm>
      <para>Ce script règle une variable d'environnement nécessaire au support
      des langues natives. Vous pouvez trouver un point complet sur la
      détermination de cette variable sur la page <ulink
      url="&lfs-root;/chapter07/profile.html">Fichiers de démarrage du shell 
      bash de LFS</ulink> page.</para>
<screen role="root">
<userinput>cat &gt; /etc/profile.d/i18n.sh &lt;&lt; "EOF"
<literal># Set up i18n variables
export LANG=<replaceable>&lt;ll&gt;</replaceable>_<replaceable>&lt;CC&gt;</replaceable>.<replaceable>&lt;charmap&gt;</replaceable><replaceable>&lt;@modifiers&gt;</replaceable></literal>
EOF</userinput>
</screen>
    </sect3>
    <sect3>
      <title>Autres valeurs d'Initialisation</title>
      <para>On peut facilement ajouter d'autres réglages à
      <filename>profile</filename> en ajoutant des scripts supplémentaires au
      répertoire <filename class='directory'>/etc/profile.d</filename>.</para>
    </sect3>
  </sect2>
  <sect2 id="etc-bashrc-profile">
    <title>/etc/bashrc</title>
    <indexterm zone="postlfs-config-profile etc-bashrc-profile">
      <primary sortas="e-etc-bashrc">/etc/bashrc</primary>
    </indexterm>
    <para>Voici un <filename>/etc/bashrc</filename> de base. Les commentaires
    dans ce fichier devraient vous expliquer tout ce dont vous avez besoin.</para>
<screen role="root">
<userinput>cat &gt; /etc/bashrc &lt;&lt; "EOF"
<literal># Begin /etc/bashrc
# Written for Beyond Linux From Scratch
# by James Robertson &lt;jameswrobertson@earthlink.net&gt;
# updated by Bruce Dubbs &lt;bdubbs@&lfs-domainname;&gt;
# System wide aliases and functions.
# System wide environment variables and startup programs should go into
# /etc/profile.  Personal environment variables and startup programs
# should go into ~/.bash_profile.  Personal aliases and functions should
# go into ~/.bashrc
# Provides a colored /bin/ls command.  Used in conjunction with code in
# /etc/profile.
alias ls='ls --color=auto'
# Provides prompt for non-login shells, specifically shells started
# in the X environment. [Review the LFS archive thread titled
# PS1 Environment Variable for a great case study behind this script
# addendum.]
NORMAL="\[\e[0m\]"
RED="\[\e[1;31m\]"
GREEN="\[\e[1;32m\]"
if [[ $EUID == 0 ]] ; then
  PS1="$RED\u [ $NORMAL\w$RED ]# $NORMAL"
else
  PS1="$GREEN\u [ $NORMAL\w$GREEN ]\$ $NORMAL"
fi
# End /etc/bashrc</literal>
EOF</userinput>
</screen>
  </sect2>
  <sect2 id="bash_profile-profile">
    <title>~/.bash_profile</title>
    <indexterm zone="postlfs-config-profile bash_profile-profile">
      <primary sortas="e-AA.bash_profile">~/.bash_profile</primary>
    </indexterm>
    <para>Voici un <filename>~/.bash_profile</filename> de base. Si vous voulez
    que chaque nouvel utilisateur ait automatiquement ce fichier, renvoyez
    seulement la sortie de la commande vers <filename>/etc/skel/.bash_profile</filename> 
    et vérifiez les droits après l'exécution de la commande. Vous pouvez alors
    copier <filename>/etc/skel/.bash_profile</filename> dans les répertoires
    home des utilisateurs existant, y compris celui de <systemitem class="username">root</systemitem>,
    et réglez comme il faut le propriétaire et le groupe d'appartenance.</para>
<screen>
<userinput>cat &gt; ~/.bash_profile &lt;&lt; "EOF"
<literal># Begin ~/.bash_profile
# Written for Beyond Linux From Scratch
# by James Robertson &lt;jameswrobertson@earthlink.net&gt;
# updated by Bruce Dubbs &lt;bdubbs@&lfs-domainname;&gt;
# Personal environment variables and startup programs.
# Personal aliases and functions should go in ~/.bashrc.  System wide
# environment variables and startup programs are in /etc/profile.
# System wide aliases and functions are in /etc/bashrc.
append () {
  # First remove the directory
  local IFS=':'
  local NEWPATH
  for DIR in $PATH; do
     if [ "$DIR" != "$1" ]; then
       NEWPATH=${NEWPATH:+$NEWPATH:}$DIR
     fi
  done
  # Then append the directory
  export PATH=$NEWPATH:$1
}
if [ -f "$HOME/.bashrc" ] ; then
  source $HOME/.bashrc
fi
if [ -d "$HOME/bin" ] ; then
  append $HOME/bin
fi
unset append
# End ~/.bash_profile</literal>
EOF</userinput>
</screen>
  </sect2>
  <sect2 id="bashrc-profile">
    <title>~/.bashrc</title>
    <indexterm zone="postlfs-config-profile bashrc-profile">
      <primary sortas="e-AA.bashrc">~/.bashrc</primary>
    </indexterm>
    <para>Voici un <filename>~/.bashrc</filename> de base.  Les commentaires et
    les instructions d'utilisation de <filename class="directory">/etc/skel</filename> 
    pour <filename>.bash_profile</filename> ci-dessus s'appliquent aussi ici. 
    Seuls les noms de fichiers cibles sont différents.</para>
<screen>
<userinput>cat &gt; ~/.bashrc &lt;&lt; "EOF"
<literal># Begin ~/.bashrc
# Written for Beyond Linux From Scratch
# by James Robertson &lt;jameswrobertson@earthlink.net&gt;
# Personal aliases and functions.
# Personal environment variables and startup programs should go in
# ~/.bash_profile.  System wide environment variables and startup
# programs are in /etc/profile.  System wide aliases and functions are
# in /etc/bashrc.
if [ -f "/etc/bashrc" ] ; then
  source /etc/bashrc
fi
# End ~/.bashrc</literal>
EOF</userinput>
</screen>
  </sect2>
  <sect2 id="bash_logout-profile">
    <title>~/.bash_logout</title>
    <indexterm zone="postlfs-config-profile bash_logout-profile">
      <primary sortas="e-AA.bash_logout">~/.bash_logout</primary>
    </indexterm>
    <para>C'est un <filename>~/.bash_logout</filename> vide qui peut être
    utilisé comme modèle. Vous remarquerez que le <filename>~/.bash_logout</filename>
    de base n'inclut pas de commande <userinput>clear</userinput>. Ceci car
    le vidage se gère dans le fichier <filename>/etc/issue</filename>.</para>
<screen>
<userinput>cat &gt; ~/.bash_logout &lt;&lt; "EOF"
<literal># Begin ~/.bash_logout
# Written for Beyond Linux From Scratch
# by James Robertson &lt;jameswrobertson@earthlink.net&gt;
# Personal items to perform on logout.
# End ~/.bash_logout</literal>
EOF</userinput>
</screen>
  </sect2>
  <sect2 id="etc-dircolors-profile">
    <title>/etc/dircolors</title>
    <indexterm zone="postlfs-config-profile etc-dircolors-profile">
      <primary sortas="e-etc-dircolors">/etc/dircolors</primary>
    </indexterm>
    <indexterm zone="postlfs-config-profile etc-dircolors-profile">
      <primary sortas="e-AA.dircolors">~/.dircolors</primary>
    </indexterm>
    <para>Si vous utilisez la possibilité <filename>dircolors</filename>,
    lancez la commande suivante. Les étapes de paramétrage de
    <filename class="directory">/etc/skel</filename> indiquées ci-dessus peuvent
    être utilisées ici pour avoir un fichier <filename>~/.dircolors</filename> 
    lors du réglage d'un nouvel utilisateur. Comme tout à l'heure, envoyez
    simplement le nom du fichier sorti vers la commande suivante et assurez-vous
    que les droits, le propriétaire et le groupe conviennent aux fichiers créés
    et/ou soient copiés.</para>
<screen role="root">
<userinput>dircolors -p > /etc/dircolors</userinput>
</screen>
    <para>Si vous souhaitez personnaliser les couleurs utilisées pour différents
    types de fichiers, vous devez éditer le fichier <filename>/etc/dircolors</filename>.
    Les instructions pour régler les couleurs sont comprises dans le fichier.</para>
    <para>Enfin, Ian Macdonald a écrit un ensemble excellent de modèles et
    de bidouillages pour améliorer votre environnement de shell. Vous pouvez
    le lire en ligne sur
    <ulink url="http://www.caliban.org/bash/index.shtml"/>.</para>
  </sect2>
</sect1>
