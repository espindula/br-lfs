<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../../general.ent">
  %general-entities;
]>

<sect1 id="postlfs-config-profile" xreflabel="Les fichiers de démarrage du shell Bash">
  <?dbhtml filename="profile.html"?>

  <sect1info>
    <othername>$LastChangedBy&nbsp;: randy $</othername>
    <date>$Date&nbsp;: 2012-12-19 20:57:20 +0100 (Wed, 19 Dec 2012) $</date>
  </sect1info>

  <title>Les fichiers de démarrage du shell Bash</title>

  <para>Le programme de shell <filename>/bin/bash</filename> (auquel on se
  référera ci-après sous le nom de « shell » utilise un ensemble de fichiers de
  démarrage pour aider à la création d'un environnement. Chaque fichier a une
  utilisation spécifique et il peut concerner différemment la connexion et les
  environnements interactifs. Les fichiers du répertoire
 <filename class="directory">/etc</filename> fournissent en général les
 paramètres globaux. Si un fichier équivalent existe dans votre répertoire
 home, il peut remplacer les paramètres globaUx.</para>

  <para>Un shell de connexion interactif démarre après une connexion réussie,
  en utilisant <filename>/bin/login</filename>, en lisant le fichier
  <filename>/etc/passwd</filename>. Cet appel du shell lit normalement
  <filename>/etc/profile</filename> et son équivalent privé
  <filename>~/.bash_profile</filename> au démarrage.</para>

  <para>Un shell de non connexion interactif démarre normalement en ligne de
  commande en utilisant un programme de shell (comme
  <prompt>[prompt]$</prompt><command>/bin/bash</command>) ou par la commande
  <command>/bin/su</command>. Un shell de non-connexion interactif démarre 
  également avec un programme de terminal tel que <command>xterm</command> ou
  <command>konsole</command> depuis un environnement graphique. Ce type d'appel
  de shell copie normalement l'environnement parent puis lit le fichier
  <filename>~/.bashrc</filename> de l'utilisateur pour des instructions de
  configuration de démarrage supplémentaires.</para>

  <para>Un shell non interactif est présent en général lorsqu'un script shell 
  s'exécute. Il n'est pas interactif car il exécute un script et n'attend
  pas d'entrée de l'utilisateur entre les commandes. Pour ces appels de shell,
  seul l'environnement hérité du shell parent est utilisé.</para>

  <para>Le fichier <filename>~/.bash_logout</filename> n'est pas utilisé pour
  un appel du shell. Il est lu et exécuté lorsqu'un utilisateur quitte un shell
  de connexion interactif.</para>

  <para>De nombreuses distributions utilisent <filename>/etc/bashrc</filename> pour
  l'initialisation pour tout le système de shells de non connexion. Ce fichier 
  est en général appelé depuis le fichier <filename>~/.bashrc</filename> de
  l'utilisateur et il n'est pas construit directement dans
  <command>bash</command> lui-même. On suit cette convention dans cette section.</para>

  <para>Pour plus d'informations, voir <command>info bash</command> --
  <emphasis role="strong">Nodes: Bash Startup Files et Interactive
  Shells</emphasis>.</para>

  <note>
    <para>La plupart des instructions ci-dessous sont utilisées pour créer des 
    fichiers qui se trouvent dans la structure de répertoires
    <filename class='directory'>/etc</filename>, ce qui implique que vous exécutiez
    les commandes en tant qu'utilisateur 
    <systemitem class='username'>root</systemitem>. Si vous optez plutôt pour la 
    création des fichiers dans le répertoire home de l'utilisateur, vous devriez
    lancer les commandes en tant qu'utilisateur non privilégié.</para>
  </note>

  <sect2 id="etc-profile-profile">
    <title>/etc/profile</title>

    <indexterm zone="postlfs-config-profile etc-profile-profile">
      <primary sortas="e-etc-profile">/etc/profile</primary>
    </indexterm>

    <para>Voici un <filename>/etc/profile</filename> de base. Ce fichier
    démarre en paramétrant des fonctions d'aide et quelques paramètres de base.
    Il spécifie des paramètres d'historique de <command>bash</command> et, 
    pour des raisons de sécurité, il désactive la conservation d'un fichier 
    d'historique permanent pour l'utilisateur <systemitem class="username">root</systemitem>.
    Il paramètre aussi un invite utilisateur par défaut. Il appelle ensuite de
    petits scripts à finalité unique dans le répertoire
    <filename class='directory'>/etc/profile.d</filename> pour fournir la
    plupart de l'initialisation.</para>

    <para>Pour plus d'informations sur les séquences d'échappement que vous pouvez
    utiliser pour votre invite (à savoir la variable d'environnement 
    <envar>PS1</envar>) voir <command>info
    bash</command> -- <emphasis role="strong">Node: Printing a
    Prompt</emphasis>.</para>

<screen role="root"><?dbfo keep-together="auto"?><userinput>cat &gt; /etc/profile &lt;&lt; "EOF"
<literal># Début de /etc/profile
# Écrit pour Beyond Linux From Scratch
# par James Robertson &lt;jameswrobertson@earthlink.net&gt;
# modifications par Dagmar d'Surreal &lt;rivyqntzne@pbzpnfg.arg&gt;

# Variables d'environnement globales et programmes au démarrage

# Les aliases et les fonctions du système devraient être dans /etc/bashrc. 
# Les variables d'environnement personnelles et les programmes de démarrage 
# devraient être dans ~/.bash_profile. Les aliases et les fonctions personnelles
# devraient aller dans ~/.bashrc.

# Fonctions pour nous aider à gérer les chemins. Le deuxième argument est le nom
# de la variable de chemin à modifier (par défaut&nbsp;: PATH)
pathremove () {
        local IFS=':'
        local NEWPATH
        local DIR
        local PATHVARIABLE=${2:-PATH}
        for DIR in ${!PATHVARIABLE} ; do
                if [ "$DIR" != "$1" ] ; then
                  NEWPATH=${NEWPATH:+$NEWPATH:}$DIR
                fi
        done
        export $PATHVARIABLE="$NEWPATH"
}

pathprepend () {
        pathremove $1 $2
        local PATHVARIABLE=${2:-PATH}
        export $PATHVARIABLE="$1${!PATHVARIABLE:+:${!PATHVARIABLE}}"
}

pathappend () {
        pathremove $1 $2
        local PATHVARIABLE=${2:-PATH}
        export $PATHVARIABLE="${!PATHVARIABLE:+${!PATHVARIABLE}:}$1"
}


# Réglage du path (chemin) initial
export PATH=/bin:/usr/bin

if [ $EUID -eq 0 ] ; then
        pathappend /sbin:/usr/sbin
        unset HISTFILE
fi

# Initialisation des variables d'environnement.
export HISTSIZE=1000
export HISTIGNORE="&amp;:[bf]g:exit"

# Paramétrage d'un invite rouge pour root et d'un vert pour les utilisateurs.
NORMAL="\[\e[0m\]"
RED="\[\e[1;31m\]"
GREEN="\[\e[1;32m\]"
if [[ $EUID == 0 ]] ; then
  PS1="$RED\u [ $NORMAL\w$RED ]# $NORMAL"
else
  PS1="$GREEN\u [ $NORMAL\w$GREEN ]\$ $NORMAL"
fi

for script in /etc/profile.d/*.sh ; do
        if [ -r $script ] ; then
                . $script
        fi
done

# Pour nettoyer maintenant
unset pathremove pathprepend pathappend

# Fin de /etc/profile</literal>
EOF</userinput></screen>

    <sect3 id="etc-profile.d">
      <title>Le répertoire /etc/profile.d</title>

      <indexterm zone="postlfs-config-profile etc-profile.d">
        <primary sortas="e-etc-profile.d">/etc/profile.d</primary>
      </indexterm>

      <para>Maintenant créez le répertoire <filename class='directory'>/etc/profile.d</filename>,
      où sont mis les scripts d'initialisation individuels&nbsp;:</para>

<screen role="root"><userinput>install --directory --mode=0755 --owner=root --group=root /etc/profile.d</userinput></screen>

    </sect3>

    <sect3 id="etc-profile.d-dircolors.sh">
      <title>/etc/profile.d/dircolors.sh</title>

      <indexterm zone="postlfs-config-profile etc-profile.d-dircolors.sh">
        <primary sortas="e-etc-profile.d-dircolors.sh">/etc/profile.d/dircolors.sh</primary>
      </indexterm>

      <para>Ce script utilise les fichiers <filename>~/.dircolors</filename> et
      <filename>/etc/dircolors</filename> pour contrôler les couleurs des noms
      de fichiers dans la liste du contenu d'un répertoire. Ils contrôlent la
      sortie en couleurs d'éléments tels que <command>ls
      --color</command>.  L'explication de la façon d'initialiser ces fichiers
      se trouvent à la fin de cette section.</para>

<screen role="root"><userinput>cat &gt; /etc/profile.d/dircolors.sh &lt;&lt; "EOF"
<literal># Réglage pour que /bin/ls supporte les couleurs, l'alias est dans 
# /etc/bashrc.
if [ -f "/etc/dircolors" ] ; then
        eval $(dircolors -b /etc/dircolors)

        if [ -f "$HOME/.dircolors" ] ; then
                eval $(dircolors -b $HOME/.dircolors)
        fi
fi
alias ls='ls --color=auto'</literal>
EOF</userinput></screen>

    </sect3>

    <sect3 id="extrapaths.sh">
      <title>/etc/profile.d/extrapaths.sh</title>

      <indexterm zone="postlfs-config-profile extrapaths.sh">
        <primary sortas="e-etc-profile.d-extrapaths.sh">/etc/profile.d/extrapaths.sh</primary>
      </indexterm>

      <para>Ce script ajoute plusieurs chemins utiles aux variables d'environnement
      <envar>PATH</envar> et <envar>PKG_CONFIG_PATH</envar>. Si vous le voulez,
      vous pouvez décommenter la dernière section pour mettre un point à la fin
      de votre chemin. Ceci permettra aux exécutables du répertoire de travail
      actuel de s'exécuter sans spécifier de ./, mais soyez averti que ceci
      est en général considéré comme un risque de sécurité.</para>

<screen role="root"><userinput>cat &gt; /etc/profile.d/extrapaths.sh &lt;&lt; "EOF"
<literal>if [ -d /usr/local/lib/pkgconfig ] ; then
        pathappend /usr/local/lib/pkgconfig PKG_CONFIG_PATH
fi
if [ -d /usr/local/bin ]; then
        pathprepend /usr/local/bin
fi
if [ -d /usr/local/sbin -a $EUID -eq 0 ]; then
        pathprepend /usr/local/sbin
fi

if [ -d ~/bin ]; then
        pathprepend ~/bin
fi
#if [ $EUID -gt 99 ]; then
#        pathappend .
#fi</literal>
EOF</userinput></screen>

    </sect3>

    <sect3 id="readline.sh">
      <title>/etc/profile.d/readline.sh</title>

      <indexterm zone="postlfs-config-profile readline.sh">
        <primary sortas="e-etc-profile.d-readline.sh">/etc/profile.d/readline.sh</primary>
      </indexterm>

      <para>Ce script règle le  fichier de configuration <filename>inputrc</filename>
      par défaut. Si l'utilisateur n'a pas de paramètres individuels, il
      utilise le fichier global.</para>

<screen role="root"><userinput>cat &gt; /etc/profile.d/readline.sh &lt;&lt; "EOF"
<literal># Paramétrage de la variable d'environnement INPUTRC.
if [ -z "$INPUTRC" -a ! -f "$HOME/.inputrc" ] ; then
        INPUTRC=/etc/inputrc
fi
export INPUTRC</literal>
EOF</userinput></screen>

    </sect3>

    <sect3 id="umask.sh">
      <title>/etc/profile.d/umask.sh</title>

      <indexterm zone="postlfs-config-profile umask.sh">
        <primary sortas="e-etc-profile.d-umask.sh">/etc/profile.d/umask.sh</primary>
      </indexterm>

      <para>Le paramétrage de la valeur <command>umask</command> est important 
      pour la sécurité. Ici, les droits d'écriture par défaut du groupe sont
      désactivés pour les utilisateurs systèmes et quand le nom d'utilisateur et
      le nom du groupe ne sont pas les mêmes.</para>

<screen role="root"><userinput>cat &gt; /etc/profile.d/umask.sh &lt;&lt; "EOF"
<literal># Par défaut, umask doit être paramétré.
if [ "$(id -gn)" = "$(id -un)" -a $EUID -gt 99 ] ; then
  umask 002
else
  umask 022
fi</literal>
EOF</userinput></screen>

    </sect3>

<!--
     <sect3 id="X.sh">
      <title>/etc/profile.d/X.sh</title>

      <indexterm zone="postlfs-config-profile X.sh">
        <primary sortas="e-etc-profile.d-X.sh">/etc/profile.d/X.sh</primary>
      </indexterm>

      <para>Si <application>X</application> est installé, les variables
      <envar>PATH</envar> et <envar>PKG_CONFIG_PATH</envar> sont également mises
      à jour.</para>

<screen role="root"><userinput>cat &gt; /etc/profile.d/X.sh &lt;&lt; "EOF"
<literal>if [ -x /usr/X11R6/bin/X ]; then
        pathappend /usr/X11R6/bin
fi
if [ -d /usr/X11R6/lib/pkgconfig ] ; then
        pathappend /usr/X11R6/lib/pkgconfig PKG_CONFIG_PATH
fi</literal>
EOF</userinput></screen>

    </sect3>
    -->
    <sect3 id="i18n.sh">
      <title>/etc/profile.d/i18n.sh</title>

    <indexterm zone="postlfs-config-profile i18n.sh">
      <primary sortas="e-etc-profile.d-i18n.sh">/etc/profile.d/i18n.sh</primary>
    </indexterm>

      <para>Ce script règle une variable d'environnement nécessaire au support
      des langues natives. Vous pouvez trouver un point complet sur la
      détermination de cette variable sur la page <ulink
      url="&lfs-root;/chapter07/profile.html">Fichiers de démarrage du shell 
      bash de LFS</ulink> page.</para>

<screen role="root"><userinput>cat &gt; /etc/profile.d/i18n.sh &lt;&lt; "EOF"
<literal># Réglages des variables i18n
export LANG=<replaceable>&lt;ll&gt;</replaceable>_<replaceable>&lt;CC&gt;</replaceable>.<replaceable>&lt;charmap&gt;</replaceable><replaceable>&lt;@modifiers&gt;</replaceable></literal>
EOF</userinput></screen>

    </sect3>

    <sect3>
      <title>Autres valeurs d'Initialisation</title>

      <para>On peut facilement ajouter d'autres réglages à
      <filename>profile</filename> en ajoutant des scripts supplémentaires au
      répertoire <filename class='directory'>/etc/profile.d</filename>.</para>

    </sect3>

  </sect2>

  <sect2 id="etc-bashrc-profile">
    <title>/etc/bashrc</title>

    <indexterm zone="postlfs-config-profile etc-bashrc-profile">
      <primary sortas="e-etc-bashrc">/etc/bashrc</primary>
    </indexterm>

    <para>Voici un <filename>/etc/bashrc</filename> de base. Les commentaires
    dans ce fichier devraient vous expliquer tout ce dont vous avez besoin.</para>

<screen role="root"><userinput>cat &gt; /etc/bashrc &lt;&lt; "EOF"
<literal># Début de /etc/bashrc
# Écrit pour Beyond Linux From Scratch
# par James Robertson &lt;jameswrobertson@earthlink.net&gt;
# mis à jour par Bruce Dubbs &lt;bdubbs@&lfs-domainname;&gt;

# Aliases et fonctions pour tout le système.

# Les aliases et les fonctions du système devraient être dans /etc/bashrc. 
# Les variables d'environnement personnelles et les programmes de démarrage 
# devraient être dans ~/.bash_profile. Les aliases et les fonctions personnelles
# devraient aller dans ~/.bashrc.

# Fournit une commande /bin/ls en couleurs. Utilisé avec le code dans
# /etc/profile.

alias ls='ls --color=auto'

# Invite pour les shells de non connexion, en particulier les shells
# démarrés dans l'environnement X. [Consultez le fil des archives de LFS 
# intitulé PS1 Environment Variable pour un superbe cas d'école derrière la
# modification de ce script.]

NORMAL="\[\e[0m\]"
RED="\[\e[1;31m\]"
GREEN="\[\e[1;32m\]"
if [[ $EUID == 0 ]] ; then
  PS1="$RED\u [ $NORMAL\w$RED ]# $NORMAL"
else
  PS1="$GREEN\u [ $NORMAL\w$GREEN ]\$ $NORMAL"
fi

# Fin de /etc/bashrc</literal>
EOF</userinput></screen>

  </sect2>

  <sect2 id="bash_profile-profile">
    <title>~/.bash_profile</title>

    <indexterm zone="postlfs-config-profile bash_profile-profile">
      <primary sortas="e-AA.bash_profile">~/.bash_profile</primary>
    </indexterm>

    <para>Voici un <filename>~/.bash_profile</filename> de base. Si vous voulez
    que chaque nouvel utilisateur ait automatiquement ce fichier, renvoyez
    seulement la sortie de la commande vers <filename>/etc/skel/.bash_profile</filename> 
    et vérifiez les droits après l'exécution de la commande. Vous pouvez alors
    copier <filename>/etc/skel/.bash_profile</filename> dans les répertoires
    home des utilisateurs existant, y compris celui de <systemitem class="username">root</systemitem>,
    et réglez comme il faut le propriétaire et le groupe d'appartenance.</para>

<screen><userinput>cat &gt; ~/.bash_profile &lt;&lt; "EOF"
<literal># Début de ~/.bash_profile
# Écrit pour Beyond Linux From Scratch
# par James Robertson &lt;jameswrobertson@earthlink.net&gt;
# mise à jour par Bruce Dubbs &lt;bdubbs@&lfs-domainname;&gt;

# Les variables d'environnement personnel et les programmes de démarrage.

# Les aliases et les fonctions personnelles devraient aller dans ~/.bashrc.  
# Les variables d'environnement et les programmes de démarrage pour tout le 
# système devraient aller dans /etc/profile. Les aliases et les fonctions de tout
# le système sont dans /etc/bashrc.

append () {
  # Supprimer d'abord le répertoire
  local IFS=':'
  local NEWPATH
  for DIR in $PATH; do
     if [ "$DIR" != "$1" ]; then
       NEWPATH=${NEWPATH:+$NEWPATH:}$DIR
     fi
  done

  # Puis créer le répertoire
  export PATH=$NEWPATH:$1
}

if [ -f "$HOME/.bashrc" ] ; then
  source $HOME/.bashrc
fi

if [ -d "$HOME/bin" ] ; then
  append $HOME/bin
fi

unset append

# Fin de ~/.bash_profile</literal>
EOF</userinput></screen>

  </sect2>

  <sect2 id="bashrc-profile">
    <title>~/.bashrc</title>

    <indexterm zone="postlfs-config-profile bashrc-profile">
      <primary sortas="e-AA.bashrc">~/.bashrc</primary>
    </indexterm>

    <para>Voici un <filename>~/.bashrc</filename> de base.  Les commentaires et
    les instructions d'utilisation de <filename class="directory">/etc/skel</filename> 
    pour <filename>.bash_profile</filename> ci-dessus s'appliquent aussi ici. 
    Seuls les noms de fichiers cibles sont différents.</para>

<screen><userinput>cat &gt; ~/.bashrc &lt;&lt; "EOF"
<literal># Début de ~/.bashrc
# Écrit pour Beyond Linux From Scratch
# par James Robertson &lt;jameswrobertson@earthlink.net&gt;


# Fonctions et aliases personnels.

# Les variables d'environnement et les programmes de démarrage personnels 
# devraient aller dans ~/.bash_profile.  Les variables d'environnement et les 
# programmes de démarrage pour tout le système devraient aller dans /etc/profile.
# Les aliases et les fonctions de tout le système sont dans /etc/bashrc.

if [ -f "/etc/bashrc" ] ; then
  source /etc/bashrc
fi

# Fin de ~/.bashrc</literal>
EOF</userinput></screen>

  </sect2>


  <sect2 id="bash_logout-profile">
    <title>~/.bash_logout</title>

    <indexterm zone="postlfs-config-profile bash_logout-profile">
      <primary sortas="e-AA.bash_logout">~/.bash_logout</primary>
    </indexterm>

    <para>C'est un <filename>~/.bash_logout</filename> vide qui peut être
    utilisé comme modèle. Vous remarquerez que le <filename>~/.bash_logout</filename>
    de base n'inclut pas de commande <userinput>clear</userinput>. Ceci car
    le vidage se gère dans le fichier <filename>/etc/issue</filename>.</para>

<screen><userinput>cat &gt; ~/.bash_logout &lt;&lt; "EOF"
<literal># Début de ~/.bash_logout
# Écrit pour Beyond Linux From Scratch
# par James Robertson &lt;jameswrobertson@earthlink.net&gt;

# Éléments personnels à traiter lors de la déconnexion.

# Fin de ~/.bash_logout</literal>
EOF</userinput></screen>

  </sect2>


  <sect2 id="etc-dircolors-profile">
    <title>/etc/dircolors</title>

    <indexterm zone="postlfs-config-profile etc-dircolors-profile">
      <primary sortas="e-etc-dircolors">/etc/dircolors</primary>
    </indexterm>

    <indexterm zone="postlfs-config-profile etc-dircolors-profile">
      <primary sortas="e-AA.dircolors">~/.dircolors</primary>
    </indexterm>

    <para>Si vous utilisez la possibilité <filename>dircolors</filename>,
    lancez la commande suivante. Les étapes de paramétrage de
    <filename class="directory">/etc/skel</filename> indiquées ci-dessus peuvent
    être utilisées ici pour avoir un fichier <filename>~/.dircolors</filename> 
    lors du réglage d'un nouvel utilisateur. Comme tout à l'heure, envoyez
    simplement le nom du fichier sorti vers la commande suivante et assurez-vous
    que les droits, le propriétaire et le groupe conviennent aux fichiers créés
    et/ou soient copiés.</para>

<screen role="root"><userinput>dircolors -p > /etc/dircolors</userinput></screen>

    <para>Si vous souhaitez personnaliser les couleurs utilisées pour différents
    types de fichiers, vous devez éditer le fichier <filename>/etc/dircolors</filename>.
    Les instructions pour régler les couleurs sont comprises dans le fichier.</para>

    <para>Enfin, Ian Macdonald a écrit un ensemble excellent de modèles et
    de bidouillages pour améliorer votre environnement de shell. Vous pouvez
    le lire en ligne sur
    <ulink url="http://www.caliban.org/bash/index.shtml"/>.</para>

  </sect2>

</sect1>
