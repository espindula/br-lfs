<?xml version="1.0" encoding="ISO-8859-1"?>
<sect1 id="postlfs-config-profile" xreflabel="Les fichiers de démarrage Bash">
<?dbhtml filename="profile.html"?>
<title>Les fichiers de démarrage du shell Bash</title>

<para>Le programme shell <filename>/bin/bash</filename> (que l'on nommera
simplement "le shell" à partir de maintenant) utilise une collection de fichiers
de démarrage pour aider à la création d'un environnement de travail. Chaque
fichier a une utilisation spécifique et peut affecter différemment la connexion
et les environnements interactifs. Les fichiers dans le répertoire
<filename class="directory">/etc</filename> apportent habituellement une configuration globale.
Si un fichier équivalent existe dans votre répertoire personnel, il pourrait
écraser les paramètrages globaux.</para>

<para>Un shell interactif de connexion est lancé après une connexion réussie en
utilisant <filename>/bin/login</filename> et en lisant le fichier
<filename>/etc/passwd</filename>. Cet appel lit habituellement
<filename>/etc/profile</filename> et son équivalent personnel
<filename>~/.bash_profile</filename> au lancement.</para>

<para>Un shell interactif sans connexion est habituellement lancé à la ligne de
commande (c'est-à-dire  <prompt>[invite]$</prompt><command>/bin/bash</command>)
ou par la commande <command>/bin/su</command>. Un shell interactif sans
connexion est aussi lancé avec un programme de type terminal comme
<command>xterm</command> ou <command>konsole</command> à l'intérieur d'un
environnement graphique. Ce type d'appel de shell copie normalement
l'environnement parent puis lit le fichier <filename>~/.bashrc</filename> de
l'utilisateur pour les instructions de configuration supplémentaires.</para>

<para>Un shell non interactif est généralement présent lorsqu'un script shell
est lancé. Il est non interactif car il exécute un script et n'attend pas une
saisie de l'utilisateur entre les commandes. Pour ces appels de shell, seul
l'environnement hérité du shell parent est utilisé.</para>

<para>Le fichier <filename>~/.bash_logout</filename> n'est pas utilisé pour un
appel du shell. Il est lu et exécuté à la sortie du shell par un
utilisateur.</para>

<para>Aux fichiers standards, nous pouvons aussi
ajouter <filename>/etc/bashrc</filename>, appelé à partir du
<filename>~/.bashrc</filename> de l'utilisateur pour l'initialisation système
des shells sans connexion.</para>

<para>Pour plus d'informations, voir <command>info bash</command> --
<emphasis role="strong">Noeud: Bash Startup Files and Interactive
Shells</emphasis>.</para>

<sect2>
<title><filename>/etc/profile</filename></title>

<para>Voici un <filename>/etc/profile</filename> de base. Ce fichier commence
par l'initialisation de quelques fontions d'aide et autres paramètres basiques.
Il spécifie quelques paramètres d'historique pour <filename>bash</filename>
et, pour des raisons de sécurité, désactive la conservation du fichier
d'historique permanent de l'utilisateur root. Il initialise aussi une invite
par défaut. Il appelle ensuite des petits scripts à but unique dans le
répertoire <filename class='directory'>/etc/profile.d</filename> fournissant
d'autres initialisations.</para>

<para>Pour plus d'informations sur les séquences d'échappement que vous
pouvez utiliser avec votre invite (c'est-à-dire la variable d'environnement
n<envar>PS1</envar>), voir <command>info
bash</command> -- <emphasis role="strong">N&oelig;ud&nbsp;: afficher une
invite.</emphasis></para>

<screen><userinput><command>cat &gt; /etc/profile &lt;&lt; "EOF"</command>
# Début de /etc/profile
# Écrit pour Beyond Linux From Scratch
# par James Robertson &lt;jameswrobertson@earthlink.net&gt;
# modifications par Dagmar d'Surreal &lt;rivyqntzne@pbzpnfg.arg&gt;

# Variables d'environnement globales et programmes de démarrage

# Les alias systèmes et les fonctions doivent aller dans /etc/bashrc. Les
# variables d'environnements et les programmes de lancement personnels doivent
# aller dans ~/.bash_profile. Les alias et fonctions personnels doivent aller
# dans ~/.bashrc.

# Fonction d'aide à la gestion des chemins.
pathremove () {
        local IFS=':'
        local NEWPATH
        local DIR
        local PATHVARIABLE=${2:-PATH}
        for DIR in ${!PATHVARIABLE} ; do
                if [ "$DIR" != "$1" ] ; then
                  NEWPATH=${NEWPATH:+$NEWPATH:}$DIR
                fi
        done
        export $PATHVARIABLE="$NEWPATH"
}
 
pathprepend () {
        pathremove $1 $2
        local PATHVARIABLE=${2:-PATH}
        export $PATHVARIABLE="$1${!PATHVARIABLE:+:${!PATHVARIABLE}}"
}
 
pathappend () {
        pathremove $1 $2
        local PATHVARIABLE=${2:-PATH}
        export $PATHVARIABLE="${!PATHVARIABLE:+${!PATHVARIABLE}:}$1"
}
 
if [ $EUID -eq 0 ] ; then
        unset HISTFILE
fi
 
# Configuration de quelques variables d'environnement.
export HISTSIZE=1000
export HISTIGNORE="&amp;:[bf]g:exit"
#export PS1="[\u@\h \w]\\$ "
export PS1='\u@\h:\w\$ '
 
for script in /etc/profile.d/*.sh ; do
        if [ -x $script ] ; then
                . $script
        fi
done
 
# Now to clean up after ourselves
unset pathremove pathprepend pathappend 

# Fin /etc/profile
<command>EOF</command></userinput></screen>

<para>Maintenant, créez le répertoire <filename
class='directory'>/etc/profile.d</filename>.</para>

<screen><userinput><command>install --directory --mode=0755 --owner=root --group=root /etc/profile.d</command></userinput></screen>

<sect3>
<title><filename>/etc/profile.d/dircolors.sh</filename></title>

<para>Ce script utilise les fichiers <filename>~/.dircolors</filename> et
<filename>/etc/dircolors</filename> pour contrôler les couleurs des noms de
fichiers dans une liste du répertoire. Ils contrôlent la sortie colorisée de
choses comme <command>ls --color</command>. L'explication sur l'initialisation
de ces fichiers se trouve à la fin de cette section.</para>


<screen><userinput><command>cat &gt; /etc/profile.d/dircolors.sh &lt;&lt; "EOF"</command>
#  Configuration pour le support de la couleur dans /bin/ls, l'alias est
#+ dans /etc/bashrc.
if [ -f "/etc/dircolors" ] ; then
        eval $(dircolors -b /etc/dircolors)
 
        if [ -f "$HOME/.dircolors" ] ; then
                eval $(dircolors -b $HOME/.dircolors)
        fi
fi
alias ls='ls --color=auto'
<command>EOF</command></userinput></screen>
</sect3>


<sect3>
<title><filename>/etc/profile.d/extrapaths.sh</filename></title>

<para>Ce script ajoute quelques chemins utiles aux variables d'environnement
<envar>PATH</envar> et <envar>PKG_CONFIG_PATH</envar>. Si vous voulez, vous
pouvez décommenter la dernière section pour placer un point à la fin de votre
chemin. Ceci permettra l'exécution d'applications du répertoire courant sans
avoir à spécifier un ./. Néanmoins, vous êtes prévenu que ceci est généralement
considéré comme un problème de sécurité.</para>
 
<screen><userinput><command>cat &gt; /etc/profile.d/extrapaths.sh &lt;&lt; "EOF"</command>
if [ -d /usr/local/lib/pkgconfig ] ; then
        pathappend /usr/local/lib/pkgconfig PKG_CONFIG_PATH
fi
if [ -d /usr/local/bin ]; then
        pathprepend /usr/local/bin
fi
if [ -d /usr/local/sbin -a $EUID -eq 0 ]; then
        pathprepend /usr/local/sbin
fi
for directory in $(find /opt/*/lib/pkgconfig -type d); do
        pathappend $directory PKG_CONFIG_PATH
done
for directory in $(find /opt/*/bin -type d); do
        pathappend $directory
done
if [ -d ~/bin ]; then
        pathprepend ~/bin
fi
#if [ $EUID -gt 99 ]; then
#        pathappend .
#fi
<command>EOF</command></userinput></screen>
</sect3>

<sect3>
<title><filename>/etc/profile.d/readline.sh</filename></title>

<para>Ce script initialise le fichier de configuration par défaut
<filename>inputrc</filename>. Si l'utilisateur n'a pas de configurations
individuelles, il utilise le fichier global.</para>

<screen><userinput><command>cat &gt; /etc/profile.d/readline.sh &lt;&lt; "EOF"</command>
# Configuration de la variable d'environnement.
if [ -z "$INPUTRC" -a ! -f "$HOME/.inputrc" ] ; then
        INPUTRC=/etc/inputrc
fi
export INPUTRC
<command>EOF</command></userinput></screen>
</sect3>

<sect3>
<title><filename>/etc/profile.d/tinker-term.sh</filename></title>

<para>Quelques applications ont besoin d'un paramètrage spécifique de
<envar>TERM</envar> pour supporter la couleur.</para>

<screen><userinput><command>cat &gt; /etc/profile.d/tinker-term.sh &lt;&lt; "EOF"</command>
# Ceci va améliorer la valeur de TERM pour convaincre certaines applications que
# nous pouvons vraiment afficher de la couleur dans leur fenêtre.
 
if [ -n "$COLORTERM" ]; then
  export TERM=xterm-color
fi
 
if [ "$TERM" = "xterm" ]; then
  export TERM=xterm-color
fi
<command>EOF</command></userinput></screen>
</sect3>

<sect3>
<title><filename>/etc/profile.d/umask.sh</filename></title>
 
<para>Initialiser la valeur d'<command>umask</command> est important pour la
sécurité. Ici, nous désactivons les droits d'écriture du groupe sur les
utilisateurs système et lorsque nom d'utilisateur et nom de groupe ne sont pas
identiques.</para>

<screen><userinput><command>cat &gt; /etc/profile.d/umask.sh &lt;&lt; "EOF"</command>
# Par défaut, nous voulons qu'umask soit initialisée.
if [ "$(id -gn)" = "$(id -un)" -a $EUID -gt 99 ] ; then
  umask 002
else
  umask 022
fi
<command>EOF</command></userinput></screen>
</sect3>

<sect3>
<title><filename>/etc/profile.d/X.sh</filename></title>

<para>Si <application>X</application> est installé, nous allons aussi mettre à
jour les variables <envar>PATH</envar> et <envar>PKG_CONFIG_PATH</envar>.</para>

<screen><userinput><command>cat &gt; /etc/profile.d/X.sh &lt;&lt; "EOF"</command>
if [ -x /usr/X11R6/bin/X ]; then
        pathappend /usr/X11R6/bin
fi
if [ -d /usr/X11R6/lib/pkgconfig ] ; then
        pathappend /usr/X11R6/lib/pkgconfig PKG_CONFIG_PATH
fi
<command>EOF</command></userinput></screen>
</sect3>

<sect3>
<title><filename>/etc/profile.d/xterm-titlebars.sh</filename></title>
 
<para>Ce script affiche un exemple d'une autre façon d'initialiser l'invite.
La variable d'environnement normale, <envar>PS1</envar>, est remplacée par
<envar>PROMPT_COMMAND</envar>. Si ell est initialisée, la valeur de
<envar>PROMPT_COMMAND</envar> est exécutée comme une commande avant chaque
invote primaire. </para>
 
<screen><userinput><command>cat &gt; /etc/profile.d/xterm-titlebars.sh &lt;&lt; "EOF"</command>
# The substring match ensures this will work for "xterm" and "xterm-xfree86".
if [ "${TERM:0:5}" = "xterm" ]; then
  PROMPT_COMMAND='echo -ne "\033]0;${USER}@${HOSTNAME} : ${PWD}\007"'
  export PROMPT_COMMAND
fi
<command>EOF</command></userinput></screen>

<para>D'autres initialisations peuvent facilement être ajoutées au
<filename>profile</filename> en ajoutant des scripts supplémentaires vers le
répertoire <filename class='directory'>/etc/profile.d</filename>.</para>
</sect3>
</sect2>

<sect2>
<title><filename>/etc/bashrc</filename></title>
<para>Ceci est une base pour <filename>/etc/bashrc</filename>. Les commentaires
inclus dans le fichier devraient tout expliquer.</para>

<screen><userinput><command>cat &gt; /etc/bashrc &lt;&lt; "EOF"</command>
# Début de /etc/bashrc 
# Écrit pour Beyond Linux From Scratch 
# par James Robertson &lt;jameswrobertson@earthlink.net&gt;

# Alias et fonctions système.

# Les variables d'environnement système et les programmes de lancement
# devraient aller sous /etc/profile. Les variables d'environnement personnel
# et les programmes de lancement devraient aller dans ~/.bash_profile. Les
# alias personnels et les fonctions devraient aller dans ~/.bashrc

# Fournit une commmande /bin/ls colorée. Utilisé avec du code provenant de
# /etc/profile.

alias ls='ls --color=auto'

# Fournit une invite pour les shells sans connexion, spécialement les shells
# lancés dans l'environnement <application>X</application>. [Revoir les
# archives LFS, dont celle titrée
# PS1 Environment Variable for a great case study behind this script addendum.]

#export PS1="[\u@\h \w]\\$ "
export PS1='\u@\h:\w\$ '

# Fin de /etc/bashrc
<command>EOF</command></userinput></screen>
</sect2>


<sect2>
<title><filename>~/.bash_profile</filename></title>

<para>Voici la base de <filename>~/.bash_profile</filename>. Si vous voulez que
chaque nouvel utilisateur ait ce fichier automatiquement, modifiez
simplement la sortie de la commande par
<filename>/etc/skel/.bash_profile</filename> et vérifiez les droits après le
lancement de la commande. Vous pouvez ensuite copier
<filename>/etc/skel/.bash_profile</filename> dans les répertoires personnels
des utilisateurs déjà existants, ceci incluant root, et configurer les
utilisateur et groupe de façon appropriée.</para>

<screen><userinput><command>cat &gt; ~/.bash_profile &lt;&lt; "EOF"</command>
# Début de ~/.bash_profile
# Écrit pour Beyond Linux From Scratch
# par James Robertson &lt;jameswrobertson@earthlink.net&gt;
# mis à jour par Bruce Dubbs &lt;bdubbs@linuxfromscratch.org&gt;

# Variables d'environnement personnelles et programmes de lancement.

# Les alias personnels et les fonctions devraient aller dans ~/.bashrc.
# Les variables d'environnement système et les programmes de lancement sont
# dans /etc/profile.
# Les alias et les fonctions système sont dans /etc/bashrc.

append () {
  # Tout d'abord, supprimez le répertoire
  local IFS=':'
  local NEWPATH
  for DIR in $PATH; do
     if [ "$DIR" != "$1" ]; then
       NEWPATH = ${NEWPATH:+$NEWPATH:}$DIR
     fi     
  done
  
  # Puis, ajoutez le répertoire
  export PATH=$NEWPATH:$1
}

if [ -f "$HOME/.bashrc" ] ; then
	source $HOME/.bashrc
fi

if [ -d "$HOME/bin" ] ; then
  append $HOME/bin	
fi

unset append

# Fin de ~/.bash_profile
<command>EOF</command></userinput></screen>
</sect2>
 
<sect2>
<title><filename>~/.bashrc</filename></title>

<para>Voici la base d'un <filename>~/.bashrc</filename>. Les commentaires et
instructions pour utiliser <filename class="directory">/etc/skel</filename> de
<filename>.bash_profile</filename> s'appliquent ici aussi. Seuls les noms de
fichiers cibles sont différents.</para>

<screen><userinput><command>cat &gt; ~/.bashrc &lt;&lt; "EOF"</command>
# Début de ~/.bashrc
# Écrit pour Beyond Linux From Scratch
# par James Robertson &lt;jameswrobertson@earthlink.net&gt;

# Alias personnels et fonctions.

# Les alias personnels et les fonctions devraient aller dans ~/.bashrc.
# Les variables d'environnement système et les programmes de lancement sont
# dans /etc/profile.
# Les alias et les fonctions système sont dans /etc/bashrc.

if [ -f "/etc/bashrc" ] ; then
	source /etc/bashrc
fi

# Fin de ~/.bashrc
<command>EOF</command></userinput></screen>
</sect2>
 
 
<sect2>
<title><filename>~/.bash_logout</filename></title>

<para>C'est un <filename>~/.bash_logout</filename> vide qui peut être utilisé
comme modèle. Vous noterez que la base <filename>~/.bash_logout</filename>
n'inclut pas de commande <userinput>clear</userinput>. En effet, celui-ci est
géré par le fichier <filename>/etc/issue</filename>.</para>

<screen><userinput><command>cat &gt; ~/.bash_logout &lt;&lt; "EOF"</command>
# Début de ~/.bash_logout
# Écrit pour Beyond Linux From Scratch
# par James Robertson &lt;jameswrobertson@earthlink.net&gt;

# Éléments personnels pour lancer une déconnexion.

# Fin de ~/.bash_logout
<command>EOF</command></userinput></screen>
</sect2>
 
 
<sect2>
<title><filename>/etc/dircolors</filename></title>

<para>Si vous voulez utiliser la fonctionnalité <filename>dircolors</filename>,
alors lancez la commande suivante. Les étapes de configuration de
<filename class="directory">/etc/skel</filename> peuvent aussi être utilisées
ici pour fournir un fichier <filename>.dircolors</filename> quand un nouvel
utilisateur est créé. Comme auparavant, modifiez simplement le nom du fichier
en sortie sur la ligne de commande et assurez-vous que les droits,
propriétaire et groupe sont corrects sur les fichiers créés et/ou copiés.
</para>

<screen><userinput><command>dircolors -p > /etc/dircolors</command></userinput></screen>

<para>Si vous souhaitez personnaliser les couleurs utilisées par différents
types de fichiers, vous pouvez éditer le fichier
<filename>/etc/dircolors</filename>. Les instructions de configuration des
couleurs sont intégrées au fichier.</para>


<para>Enfin, Ian Macdonald a écrit une excellente collection d'astuces et de
conseils pour améliorer votre environnement shell. Vous pouvez le lire en ligne
sur <ulink
url="http://www.caliban.org/bash/index.shtml">http://www.caliban.org/bash/index.
shtml</ulink>.</para>
</sect2>
</sect1>
