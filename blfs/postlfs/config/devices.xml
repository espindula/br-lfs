<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../../general.ent">
  %general-entities;
]>
<sect1 id="postlfs-devices" xreflabel="About Devices">
  <?dbhtml filename="devices.html"?>
  <sect1info>
    <othername>$LastChangedBy : bdubbs $</othername>
    <date>$Date : 2012-03-13 19:19:34 +0100 (Tue, 13 Mar 2012) $</date>
  </sect1info>
  <title>À propos des périphériques</title>
  <indexterm zone="postlfs-devices">
    <primary sortas="e-etc-udev-rules">/etc/udev/rules.d</primary>
  </indexterm>
  <para>Bien que la plupart des périphériques dont ont besoin les paquets de BLFS
  ont été correctement paramétrés par <application>udev</application> en utilisant
  les règles par défaut installées par LFS dans <filename class="directory">/etc/udev/rules.d</filename>, 
  il y a des cas où il faut modifier ou ajouter des règles.</para>
  <para condition="html" role="usernotes">Notes utilisateur&nbsp;:
  <ulink url="&blfs-wiki;/aboutdevices"/></para>
  <sect2>
    <title>Cartes sons multiples</title>
    <para>S'il y a plusieurs cartes sons sur un système, la carte son « default »
    (par défaut) devient aléatoire. La méthode pour établir un ordre dans les 
    cartes sons dépend du fait que les pilotes soient en modules ou pas. Si les
    pilotes de la carte son sont compilés dans le noyau, leur contrôle s'effectue
    via des paramètres de la ligne de commande du noyau. dans 
    <filename>/boot/grub/grub.cfg</filename>.
    Par exemple, si un système contient une carte FM801 et une carte PCI
    SoundBlaster, ce qui suit peut être envoyé sur la ligne de commande&nbsp;:</para>
<screen>
<literal>snd-fm801.index=0 snd-ens1371.index=1</literal>
</screen>
    <para>Si les pilotes de la carte son sont construits en modules, on peut
    établir l'ordre dans le fichier <filename>/etc/modprobe.conf</filename> 
    avec&nbsp;:</para>
<screen>
<literal>options snd-fm801 index=0
options snd-ens1371 index=1</literal>
</screen>
  </sect2>
  <sect2 id="usb-device-issues">
    <title>Problèmes sur les périphériques USB</title>
    <para>Les périphériques USB ont habituellement deux types de noeuds de périphériques
      associés avec eux.</para>
    <para>Le premier type est créé par le driver du périphérique spécifique
      (usb_storage/sd_mod ou usblp) dans le noyau. Par exemple, un périphérique de stockage
      USB peut être /dev/sdb, et une imprimpante USB peut être /dev/usb/lp0. Ces noeuds
      de périphériques existe seulement quand le driver du périphérique spécifique est chargé.</para>
    <para>Le second type de noeud de périphériques (/dev/bus/usb/BBB/DDD, ou BBB est
    le numéro du bus et DDD est le numéro du périphérique) est créé chaque fois que le
    périphérique n'a pas de driver dans le noyau. En utilisant ces noeuds de périphérique
    USB "direct", une application peut échanger arbitrairement des paquets USB avec le
    périphérique, c'est à dire, court-circuiter le possible driver du noyau existant.</para>
    <para>Accéder aux noeuds périphérique USB directement est nécessaire quand un
      programme de l'espace utilisateur est considéré comme un driver de périphérique.
      Sinon, pour le programme qui ouvre avec succès le périphérique les permissions
      sont initialisées correctement. Par défaut, pour des considérations de sécurité,
      tous les périphériques USB direct sont propriétés de l'utilisateur root et du groupe usb,
      et ont la permission 0664 (l'accès en lecture est nécessaire, e.g., pour que lsusb
      puisse travailler et pour les programmes d'accès aux concentrateurs USB). Des paquets
      (comme SANE et libgphoto2) contenant un driver de périphérique USR dans l'espace
      utilisateur utilisent aussi les règles udev pour changer les permissions des
      périphériques USB contrôlés. Ce qui fait que, les règles installées par SANE changent
      les permissions pour les scanners reconnus, mais pas pour les imprimantes.
    Si le mainteneur du paquet oublie d'écrire une règle pour votre périphérique,
    signaler le bug à BLFS (si le paquet est ici) et upstream, et vous aurez besoin
    d'écrire votre propre règle.</para>
    <para>Il y a une situation ou un contrôle d'accès fin avec des règles udev prégénérées
      ne marche pas. Nommément, les émulateurs de PC  comme KVM, QEMU et VirtualBox
      utilisent des noeuds de périphérique USB direct pour les périphériques USB arbitrairement
      présent dans le système d'exploitation invité (note>&nbsp;: des correctifs sont nécessaires
      pour que cela fonctionne dans les point de montage obsolete /proc/bus/usb décris précédemment).
      Naturellement, les mainteneurs de ces paquets ne peuvent pas connaître quels
      périphériques USB seront connectés sur le système d'exploitation invité. Vous pouvez
    bien écrire des règles udev séparés pour tous les périphériques USB nécessaire vous même, ou
    utiliser les règles par défaut du groupe "usb", les membres de celui-ci peuvent
    envoyé des commandes arbitraires pour tous périphériques USB. </para>
    <para>Avant Linux-2.6.15, l'accès direct aux périphériques USB n'était pas géré avec
      les noeuds de périphériques /dev/bus/usb/BBB/DDD, mais avec des pseudo-fichiers
      /proc/bus/usb/BBB/DDD. Quelques applications (e.g., VMware Workstation)
      semblent utiliser seulement cette technique obsolète et ne peuvent pas utiliser
      les nouveaux noeuds de périphériques. Pour qu'elles puissent fonctionner, utiliser
      le groupe "usb", mais rappelez vous que les membres ont un accès complet à tous les
      périphériques USB.  Pour créer l'entrée fstab pour le fichier système obsolète usbfs:</para>
<screen>
<literal>usbfs  /proc/bus/usb  usbfs  devgid=14,devmode=0660  0  0</literal>
</screen>
    <note><para>Ajouter les utilisateurs dans le groupe "usb" est par nature insécurisé,
      car cela court-circuite les restrictions d'accès imposés par les drivers spécifiques
      des noeuds de périphérique USB. Par nature, ils peuvent lire des données sensibles
      des disques USB sans être dans le group "disque". Evitez d'ajouter des utilisateurs
      dans ce groupe si vous le pouvez.</para></note>
  </sect2>
  <sect2>
    <title>Attributs de périphériques d'Udev</title>
    <para>Le peaufinement des attributs de périphériques tels que le nom du groupe
    et les droits est possible en créant des règles <application>udev</application> 
    supplémentaires, correspondant à quelque chose de ce genre. On peut trouver
    le fabricant et le produit en cherchant les entrées du répertoire
    <filename class='directory'>/sys/devices</filename>
    ou en utilisant <command>udevinfo</command> après avoir attaché le 
    périphérique. Voir la documentation dans le répertoire d'<application>udev</application>  
    actuel <filename class='directory'>/usr/share/doc</filename> pour des
    détails.</para>
<screen>
<literal>SUBSYSTEM=="usb_device", SYSFS{idVendor}=="05d8", SYSFS{idProduct}=="4002", \
  GROUP:="scanner", MODE:="0660"</literal>
</screen>
    <note><para>On n'utilise la ligne ci-dessus qu'à des fins descriptives.
    Les règles d'analyse d'<application>udev</application> sont mises
    en place lors de l'installation de <xref linkend='sane'/>.</para></note>
  </sect2>
  <sect2>
    <title>Périphériques pour les serveurs</title>
    <para>Dans certains cas, il est utile de désactiver 
    <application>udev</application> complètement et de créer des périphériques 
    statiques. Les serveurs sont un exemple de cette situation. Est-ce qu'un
    serveur a besoin de la possibilité de gérer des périphériques dynamiques&nbsp;?
    Seul l'administrateur système peut répondre à cette question, mais dans de
    nombreux cas, la réponse est non.</para>
    <para>Si vous ne désirez pas de périphériques dynamiques, vous devez créer 
    des périphériques statiques sur le système. Dans la configuration par défaut,
    le script de démarrage <filename>/etc/rc.d/rcS.d/S10udev</filename>
    monte une partition <systemitem class="filesystem">tmpfs</systemitem> 
    dans le répertoire <filename class="directory">/dev</filename>. Ce problème
    peut être résolu en montant temporairement la partition racine&nbsp;:</para>
    <warning><para>Si vous ne suivez pas rigoureusement les instructions ci-dessous,
    votre système pourrait ne plus pouvoir démarrer.</para></warning>
<screen>
<userinput>mount --bind / /mnt
cp -a /dev/* /mnt/dev
rm /etc/rc.d/rcS.d/{S10udev,S50udev_retry}
umount /mnt</userinput>
</screen>
    <para>Dès lors, le système utilisera des périphériques statiques lors du
    prochain redémarrage. Créez les périphériques supplémentaires désirés en 
    utilisant <command>mknod</command>.</para>
    <para>Si vous voulez restaurer les périphériques dynamiques, recréez les
    liens symboliques
    <filename>/etc/rc.d/rcS.d/{S10udev,S50udev_retry}</filename> et
    redémarrez de nouveau. Il n'est pas nécessaire de supprimer les périphériques
    statiques (console et null sont toujours nécessaires) car ils sont recouverts
    par la partition <systemitem class="filesystem">tmpfs</systemitem>.
    L'utilisation du disque par des périphériques est négligeable (environ
    20&ndash;30 octets par entrée.)</para>
  </sect2>
</sect1>
