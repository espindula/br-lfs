<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../../general.ent">
  %general-entities;
]>

<sect1 id="compressdoc" xreflabel="Compressing man et info pages">
  <?dbhtml filename="compressdoc.html"?>

  <sect1info>
    <othername>$LastChangedBy: dnicholson $</othername>
    <date>$Date: 2008-04-22 01:27:43 +0200 (mar. 22 avril 2008) $</date>
  </sect1info>

  <title>Compresser des pages de man et d'info</title>

  <indexterm zone="compressdoc">
    <primary sortas="b-compressdoc">compressdoc</primary>
  </indexterm>

  <para>Les lecteurs de man et d'info peuvent gérer de façon transparente des
  fichiers compressés avec <command>gzip</command> ou <command>bzip2</command>,
  une fonctionnalité que vous pouvez utiliser pour libérer de l'espace disque
  en laissant disponible la documentation. Les choses ne sont cependant pas si
  simples&nbsp;; les répertoires de man ont tendance à contenir des liens&mdash;durs et symboliques&mdash;qui
  remettent en cause les idées simples telles que l'appel de <command>gzip</command> 
  sur eux de manière récursive. Une meilleure manière de faire est d'utiliser le
  script ci-dessous. Si vous préférez télécharger le fichier au lieu de le
  créer en tapant ou en faisant un copier-coller, vous pouvez le trouver sur
  <ulink url="&files-anduin;/compressdoc"/> (vous devriez installer le fichier
  dans le répertoire <filename class="directory">/usr/sbin</filename>).</para>

<screen role="root"><?dbfo keep-together="auto"?><userinput>cat &gt; /usr/sbin/compressdoc &lt;&lt; "EOF"
<literal>#!/bin/bash
# VERSION: 20080421.1623
#
# Compresse (avec bzip2 ou gzip) toutes les pages de  man d'une hiérarchie et
# met à jour les liens symboliques  - Par Marc Heerdink &lt;marc @ koelkast.net&gt;
#
# Modifié pour pouvoir éventuellement gzipper ou bzip2er des fichiers et pour
# gérer correctement tous les liens symboliques par Mark Hymers &lt;markh @ &lfs-domainname;&gt;
#
# Modifié le 30092003 par Yann E. Morin &lt;yann.morin.1998 @ anciens.enib.fr&gt;
# pour accepter la compression/décompression, pour gérer correctement les liens
# en dur, pour permettre de transformer les liens durs en liens mous, de spécifier
# le niveau de compression, de parser le man.conf pour toutes les occurrences de
# MANPATH, pour permettre une sauvegarde, pour permettre de prendre la version 
# la plus récente d'une page.
#
# Modifié le 30032004 par Tushar Teredesai pour remplacer par $0 par le nom du
# script.
#   (Remarque&nbsp;: On suppose que le script se trouve dans le PATH de
# l'utilisateur)
#
# Modifié le 12012005 par Randy McMurchy pour raccourcir la longueur des lignes
# et corriger des fautes de grammaire.
#
# Modifié le 28012006 par Alexander E. Patrakov pour une compatibilité avec
# Man-DB.
#
# Modifié le 11032006 par Archaic pour utiliser l'outil manpath de Man-DB qui
# remplace man --path de Man.
#
# Modifié le 21042008 par Dan Nicholson pour exécuter correctement le bon
# compressdoc lors d'un fonctionnement de façon récursive. Cela signifie que
# le même compressdoc sera utilisé si on donne un chemin complet ou s'il a été 
# résolu à partir de PATH.
#
# Modifié le 21042008 par Dan Nicholson pour être plus robuste face aux
# répertoires qui n'existent pas ou qui n'ont pas assez de droits.
#
# Modifié le 21042008 par Lars Bamberger pour choisir (en quelque sorte)
# automatiquement une méthode de compression basée sur la taille de la page de 
# man. Deux corrections de bogues ont été ajoutées par Dan Nicholson.
#
# Modifié le 21042008 par Dan Nicholson pour supprimer des avertissements de 
# manpath vu qu'ils apparaissent quand $MANPATH est paramétré. Suppression du
# TODO l'utilisation de la variable $MANPATH puisque manpath(1) gère déjà
# cela. 
#
# TODO&nbsp;: (à faire)
#     - choisir une méthode de compression par défaut basée sur l'outil
#       disponible&nbsp;: gzip or bzip2;
#     - offrir une option pour restaurer une sauvegarde précédente ;
#     - ajout d'autres moteurs de compression (compress, zip, etc?). Nécessaire ?

# Assez marrant, cette fonction affiche de l'aide.
function help ()
{
  if [ -n "$1" ]; then
    echo "Option inconnue&nbsp;: $1"
  fi
  ( echo "Utilisation&nbsp;: $MY_NAME &lt;comp_method&gt; [options] [reps]" &amp;&amp; \
  cat &lt;&lt; EOT
Où comp_method est un de ceux-ci&nbsp;:
  --gzip, --gz, -g
  --bzip2, --bz2, -b
                Compresse en utilisant gzip ou bzip2.
  --automatic
                Compresse en utilisant soit gzip ou bzip2, selon la taille du
                fichier à compresser. Les fichiers plus grands que 5
                Kio sont bzippées, les fichiers plus grands que 1 Kio asont
                gzippés et les fichiers plus petits qu'1 Kio ne sont pas.
                compressés.

  --decompress, -d
                Décompresse les pages de man.

  --backup      Spécifier qu'une sauvegarde .tar sera créé pour tous les
  répertoires.
                Si une sauvegarde existe déjà, elle est sauvegardée comme
                un .tar.old avant de faire les nouvelles sauvegardes. Si une
                sauvegarde .tar.old existe, elle est supprimée avant de 
                créer une sauvegarde. En mode sauvegarde, aucune autre action 
                n'est effectuée.

Et où options sont&nbsp;:
  -1 to -9, --fast, --best
                Le niveau de compression, comme accepté par gzip et bzip2.
                Lorsqu'elle n'est pas sécifiée, utilise le niveau de compression
                de la méthode donnée (-6 pour gzip, et -9 pour bzip2).
                Pas utilisée quand en modes sauvegarde ou décompression.

  --force, -F   Oblige la (re-)compression, même si celle précédente était
                la même méthode. Utile quand on change le ratio d compression.
                Par défaut, une page ne sera pas recompressée si
                elle se termine par le même suffixe que celui ajouté par la
                méthode (.bz2 pour bzip2, .gz pour gzip).

  --soft, -S    Change les liens en dur en liens mous. Utilié avec _caution_ car
                le premier fichier rencontré sera utilisé en tant que
                référence. Non utilisé en mode sauvegarde.

  --hard, -H    Transforme des liens mous en liens durs. Pas utilisé en
                mode sauvegarde.

  --conf=dir, --conf dir
                Spécifie l'emplacement de man_db.conf. Par défaut, sur /etc.

  --verbose, -v Mode verbeux, affiche le nom du répertoire traité. Doublez le
                drapeau le rend encore plus verbeux, et affichera le nom du
                fichier traité.

  --fake, -f    Trompe le script. Affiche les paramètres actuels que compressdoc 
                utilisera.

  dirs          Une liste de chemins _absolus_ vers les pages de man séparés par
                des espaces. Si et seulement si vous laissez vide, utilise
                manpath pour parser ${MAN_CONF}/man_db.conf pour toutes les 
                occurrences valides de MANDATORY_MANPATH.

Remarque sur la compression&nbsp;:
  Il y a eu une discussion sur blfs-support concernant les ratios de compression
  des pages de man par gzip et bzip2, prenant en compte le système de fichiers 
  hôte, l'architecture, etc... En particulier, on en a conclu que gzip était
  beaucoup plus efficace pour les 'petits' fichiers, et bzip2 sur les 'gros'
  fichiers, la notion de petit et de gros dépendant beaucoup du contenu des 
  fichiers.

  Voir le message d'origine de Mickael A. Peters, intitulé
  "Bootable Utility CD" (outil CD amorçable), datant du 09042003.1816(+0200), et
  les messages consécutifs&nbsp;:
  http://&lfs-domainname;/pipermail/blfs-support/2003-April/038817.html

  Sur mon système (x86, ext3), les pages de man faisaient 35564Kio avant compression.
  gzip -9 les a compressé jusqu'à 20372Kio (57.28%), bzip2 -9 les a passés à
  19812Kio (55.71%). Soit un gain d'espace de 1.57%. YMMV.

  On n'a pas tenu compte de de la vitesse de décompression. Mais cela a-t-il un
  sens ? Vous gagnez en rapidité d'accès avec des pages de man cooppessées,
  ou vous gagnez de la place et un peu de temps.
  Bon, mon P4-2.5GHz ne me notifie même pas de ça...&nbsp;:-)

EOT
) | less
}

# Cette fonction vérifie que la page de man est unique entre bzip2'd,
# gzip'd et des versions décompressées.
#  $1 le répertoire dans lequel le fichier réside
#  $2 le nom du fichier de la page de man
# Retourne 0 (true, vrai)) si le fichier 
# est la dernière version et s'il doit être traitéet 1 (false, faux) si le
# fichier n'est pas la dernière version (et a donc été effacé).
function check_unique ()
{
  # NB. Quand il y a des liens en dur vers ce fichier, ils _ne_ sont _pas_
  # effacés. En fait, s'il y a des liens en dur, ils sont tous de la même
  # date/h1ore, étant ainsi prêt pour un effacement futur.

  # Construire la liste de toutes les pages de man ayant le même nom
  DIR=$1
  BASENAME=`basename "${2}" .bz2`
  BASENAME=`basename "${BASENAME}" .gz`
  GZ_FILE="$BASENAME".gz
  BZ_FILE="$BASENAME".bz2

  # Cherche et garde la plus récente
  LATEST=`(cd "$DIR"; ls -1rt "${BASENAME}" "${GZ_FILE}" "${BZ_FILE}" \
         2&gt;/dev/null | tail -n 1)`
  for i in "${BASENAME}" "${GZ_FILE}" "${BZ_FILE}"; do
    [ "$LATEST" != "$i" ] &amp;&amp; rm -f "$DIR"/"$i"
  done

  # Si le fichier spécifié était la dernière version, retourner 0
  [ "$LATEST" = "$2" ] &amp;&amp; return 0
  # Si le fichier spécifié n'était pas la dernière version, retourner 1
  return 1
}

# Nom du script
MY_NAME=`basename $0`

# D'accord, parser la ligne de commande pour y trouver les arguments et
# initialiser dans un état intelligent, c'est-à-dire&nbsp;: ne pas changer l'état des
# liens, parser /etc/man_db.conf, être le plus discret, chercher man_db.conf 
# dans /etc et ne pas forcer une (re)-compression.
COMP_METHOD=
COMP_SUF=
COMP_LVL=
FORCE_OPT=
LN_OPT=
MAN_DIR=
VERBOSE_LVL=0
BACKUP=no
FAKE=no
MAN_CONF=/etc
while [ -n "$1" ]; do
  case $1 in
    --gzip|--gz|-g)
      COMP_SUF=.gz
      COMP_METHOD=$1
      shift
      ;;
    --bzip2|--bz2|-b)
      COMP_SUF=.bz2
      COMP_METHOD=$1
      shift
      ;;
    --automatic)
      COMP_SUF=TBD
      COMP_METHOD=$1
      shift
      ;;
    --decompress|-d)
      COMP_SUF=
      COMP_LVL=
      COMP_METHOD=$1
      shift
      ;;
    -[1-9]|--fast|--best)
      COMP_LVL=$1
      shift
      ;;
    --force|-F)
      FORCE_OPT=-F
      shift
      ;;
    --soft|-S)
      LN_OPT=-S
      shift
      ;;
    --hard|-H)
      LN_OPT=-H
      shift
      ;;
    --conf=*)
      MAN_CONF=`echo $1 | cut -d '=' -f2-`
      shift
      ;;
    --conf)
      MAN_CONF="$2"
      shift 2
      ;;
    --verbose|-v)
      let VERBOSE_LVL++
      shift
      ;;
    --backup)
      BACKUP=yes
      shift
      ;;
    --fake|-f)
      FAKE=yes
      shift
      ;;
    --help|-h)
      help
      exit 0
      ;;
    /*)
      MAN_DIR="${MAN_DIR} ${1}"
      shift
      ;;
    -*)
      help $1
      exit 1
      ;;
    *)
      echo "\"$1\" n'est pas le nom d'un chemin absolu"
      exit 1
      ;;
  esac
done

# Redirections
case $VERBOSE_LVL in
  0)
     # O, être discret
     DEST_FD0=/dev/null
     DEST_FD1=/dev/null
     VERBOSE_OPT=
     ;;
  1)
     # 1, être un peu verbeux
     DEST_FD0=/dev/stdout
     DEST_FD1=/dev/null
     VERBOSE_OPT=-v
     ;;
  *)
     # 2 et supérieur, être très verbeux
     DEST_FD0=/dev/stdout
     DEST_FD1=/dev/stdout
     VERBOSE_OPT="-v -v"
     ;;
esac

# Remarque&nbsp;: sur ma machine, 'man --path' donne /usr/share/man deux fois, une
# fois avec un '/', rampant, une fois sans.
if [ -z "$MAN_DIR" ]; then
  MAN_DIR=`manpath -q -C "$MAN_CONF"/man_db.conf \
            | sed 's/:/\\n/g' \
            | while read foo; do dirname "$foo"/.; done \
            | sort -u \
            | while read bar; do echo -n "$bar "; done`
fi

# Si pas de MANDATORY_MANPATH dans ${MAN_CONF}/man_db.conf, s'arrêter
if [ -z "$MAN_DIR" ]; then
  echo "Aucun répertoire spécifié et aucun répertoire trouvé avec \`manpath'"
  exit 1
fi

# Vérifier que les réperqoires spécifiés existent effectivement et sont lisibles

for DIR in $MAN_DIR; do
  if [ ! -d "$DIR" -o ! -r "$DIR" ]; then
    echo "Le répertoire '$DIR' n'existe pas ou n'est pas lisible"
    exit 1
  fi
done

# Tromperie ?
if [ "$FAKE" != "no" ]; then
  echo "Paramètres actuels utilisés&nbsp;:"
  echo -n "Compression.......: "
  case $COMP_METHOD in
    --bzip2|--bz2|-b) echo -n "bzip2";;
    --gzip|--gz|-g) echo -n "gzip";;
    --automatic) echo -n "compressing";;
    --decompress|-d) echo -n "decompressing";;
    *) echo -n "unknown";;
  esac
  echo " ($COMP_METHOD)"
  echo "Niveau de compression.&nbsp;: $COMP_LVL"
  echo "Suffixe de compression&nbsp;: $COMP_SUF"
  echo -n "Forcer la compression.: "
  [ "foo$FORCE_OPT" = "foo-F" ] &amp;&amp; echo "yes" || echo "no"
  echo "man_db.conf est....: ${MAN_CONF}/man_db.conf"
  echo -n "Liens en dur........: "
  [ "foo$LN_OPT" = "foo-S" ] &amp;&amp;
  echo "convertir en liens mous" || echo "leave as is"
  echo -n "Liens mous........: "
  [ "foo$LN_OPT" = "foo-H" ] &amp;&amp;
  echo "convertir en liens durs" || echo "leave as is"
  echo "Sauvegarde............: $BACKUP"
  echo "Tromperie (oui !).....: $FAKE"
  echo "Répertoires.......: $MAN_DIR"
  echo "Niveau de verbosité...: $VERBOSE_LVL"
  exit 0
fi

# Si aucune méthode n'a été spécifiée, afficher l'aide
if [ -z "${COMP_METHOD}" -a "${BACKUP}" = "no" ]; then
  help
  exit 1
fi

# En mode sauvegarde, faire seulement la sauvegarde
if [ "$BACKUP" = "yes" ]; then
  for DIR in $MAN_DIR; do
    cd "${DIR}/.."
    if [ ! -w "`pwd`" ]; then
      echo "On ne peut pas écrire dans le répertoire '`pwd`'"
      exit 1
    fi
    DIR_NAME=`basename "${DIR}"`
    echo "Sauvegarde de $DIR..." &gt; $DEST_FD0
    [ -f "${DIR_NAME}.tar.old" ] &amp;&amp; rm -f "${DIR_NAME}.tar.old"
    [ -f "${DIR_NAME}.tar" ] &amp;&amp;
    mv "${DIR_NAME}.tar" "${DIR_NAME}.tar.old"
    tar -cvf "${DIR_NAME}.tar" "${DIR_NAME}" &gt; $DEST_FD1
  done
  exit 0
fi

# Je sais que MAN_DIR n'a que des yoms de chemins absolus
# J'ai besoin de tenir compte des man localisés, donc je procède récursivement
for DIR in $MAN_DIR; do
  MEM_DIR=`pwd`
  if [ ! -w "$DIR" ]; then
    echo "On ne peut écrire dans le répertoire '$DIR'"
    exit 1
  fi
  cd "$DIR"
  for FILE in *; do
    # Corrige le cas où le répertoire est vide
    if [ "foo$FILE" = "foo*" ]; then continue; fi

    # Corrige le cas où les liens en dur voient leur plan de compression changer
    # (de non compressé en compressé, ou de bz2 en gz, ou de gz en bz2)
    # Corrige aussi le cas où plusieurs versions de la page sont présentes,
    # qu'elles soient ou non compressées
    if [ ! -L "$FILE" -a ! -e "$FILE" ]; then continue; fi

    # Ne compresse pas ces fichiers
    if [ "$FILE" = "whatis" ]; then continue; fi

    if [ -d "$FILE" ]; then
      # Nous procédons de façon récursive dans ce répertoire
      echo "-&gt; Entrant dans ${DIR}/${FILE}..." &gt; $DEST_FD0
      # J'ai besoin de passer --conf, car je précise le répertoire sur lequel
      # travailler. Mais je dois quitter en cas d'erreur. 
      # Nous devons faire en sens inverse avec le répertoire d'origine pour que
      # $0 soit résolu correctement.
      (cd "$MEM_DIR" &amp;&amp; eval "$0" ${COMP_METHOD} ${COMP_LVL} ${LN_OPT} \
        ${VERBOSE_OPT} ${FORCE_OPT} "${DIR}/${FILE}") || exit $?
      echo "&lt;- Quittant ${DIR}/${FILE}." &gt; $DEST_FD1

    else # !dir
      if ! check_unique "$DIR" "$FILE"; then continue; fi

      # Avec la compression automatique, afficher la taille du fichier 
      # décompressé (déférencement des liens symboliques), et choisir une
      # méthode de compression adaptée.
      if [ "$COMP_METHOD" = "--automatic" ]; then
        declare -i SIZE
        case "$FILE" in
          *.bz2)
            SIZE=$(bzcat "$FILE" | wc -c) ;;
          *.gz)
            SIZE=$(zcat "$FILE" | wc -c) ;;
          *)
            SIZE=$(wc -c &lt; "$FILE") ;;
        esac
        if (( $SIZE &gt;= (5 * 2**10) )); then
          COMP_SUF=.bz2
        elif (( $SIZE &gt;= (1 * 2**10) )); then
          COMP_SUF=.gz
        else
          COMP_SUF=
        fi
      fi

      # Vérifier si le fichier est déjà compressé avec la méthode specifiée
      BASE_FILE=`basename "$FILE" .gz`
      BASE_FILE=`basename "$BASE_FILE" .bz2`
      if [ "${FILE}" = "${BASE_FILE}${COMP_SUF}" \
         -a "foo${FORCE_OPT}" = "foo" ]; then continue; fi

      # Si on a un lien symbolique
      if [ -h "$FILE" ]; then
        case "$FILE" in
          *.bz2)
            EXT=bz2 ;;
          *.gz)
            EXT=gz ;;
          *)
            EXT=none ;;
        esac

        if [ ! "$EXT" = "none" ]; then
          LINK=`ls -l "$FILE" | cut -d "&gt;" -f2 \
               | tr -d " " | sed s/\.$EXT$//`
          NEWNAME=`echo "$FILE" | sed s/\.$EXT$//`
          mv "$FILE" "$NEWNAME"
          FILE="$NEWNAME"
        else
          LINK=`ls -l "$FILE" | cut -d "&gt;" -f2 | tr -d " "`
        fi

        if [ "$LN_OPT" = "-H" ]; then
          # Change this soft-link into a hard- one
          rm -f "$FILE" &amp;&amp; ln "${LINK}$COMP_SUF" "${FILE}$COMP_SUF"
          chmod --reference "${LINK}$COMP_SUF" "${FILE}$COMP_SUF"
        else
          # Keep this soft-link a soft- one.
          rm -f "$FILE" &amp;&amp; ln -s "${LINK}$COMP_SUF" "${FILE}$COMP_SUF"
        fi
        echo "Réédition du lien $FILE" &gt; $DEST_FD1

      # sinon, si on a un fichier "plain"
      elif [ -f "$FILE" ]; then
        # Gérer les liens en dur&nbsp;: construire la liste des fichiers liés en
        # dur vers un autre qu'on {dé,}compresse.
        # NB. Ce n'est pas optimum car le fichier sera éventuellement compressé
        # autant de fois qu'il est lié en dur. Mais pour l'instant,
        # c'est une méthode sécurisée.
        inode=`ls -li "$FILE" | awk '{print $1}'`
        HLINKS=`find . \! -name "$FILE" -inum $inode`

        if [ -n "$HLINKS" ]; then
          # On a des liens en dur ! Les supprimer maintenant
          for i in $HLINKS; do rm -f "$i"; done
        fi

        # Maintenant, traiter le fichier qui n'a pas de lien en dur
        # On décompresse d'abord pour re-compresser plus tard avec le ratio de
        # compression sélectionné...
        case "$FILE" in
          *.bz2)
            bunzip2 $FILE
            FILE=`basename "$FILE" .bz2`
          ;;
          *.gz)
            gunzip $FILE
            FILE=`basename "$FILE" .gz`
          ;;
        esac

        # Compresse le fichier avec le ratio de compression donné si nécessaire
        case $COMP_SUF in
          *bz2)
            bzip2 ${COMP_LVL} "$FILE" &amp;&amp; chmod 644 "${FILE}${COMP_SUF}"
            echo "$FILE compressé" &gt; $DEST_FD1
            ;;
          *gz)
            gzip ${COMP_LVL} "$FILE" &amp;&amp; chmod 644 "${FILE}${COMP_SUF}"
            echo "$FILE compressé" &gt; $DEST_FD1
            ;;
          *)
            echo "$FILE décompressé" &gt; $DEST_FD1
            ;;
        esac

        # Si le fichier avait des liens en dur, les recréer (en dur ou mou)
        if [ -n "$HLINKS" ]; then
          for i in $HLINKS; do
            NEWFILE=`echo "$i" | sed s/\.gz$// | sed s/\.bz2$//`
            if [ "$LN_OPT" = "-S" ]; then
              # Rendre mou ce lien dur 
              ln -s "${FILE}$COMP_SUF" "${NEWFILE}$COMP_SUF"
            else
              # Garder le lien dur en l'état
              ln "${FILE}$COMP_SUF" "${NEWFILE}$COMP_SUF"
            fi
            # Ne fonctionne vraiment que pour les liens durs. Dangereux pour 
            # les liens mous
            chmod 644 "${NEWFILE}$COMP_SUF"
          done
        fi

      else
        # Il y a un problème quand on n'a ni lien symbolique ni fichier réel.
        # On n'en arrivera bien sûr jamais là...&nbsp;:-(
        echo -n "Whaooo... \"${DIR}/${FILE}\" n'est ni un lien symbolique "
        echo "ni un vrai fichier. Merci de vérifier&nbsp;:"
        ls -l "${DIR}/${FILE}"
        exit 1
      fi
    fi
  done # for FILE
done # for DIR</literal>

EOF</userinput></screen>

  <para>En tant qu'utilisateur <systemitem class="username">root</systemitem>, 
  rendez exécutable <command>compressdoc</command> pour tous les utilisateurs&nbsp;:</para>

<screen><userinput>chmod -v 755 /usr/sbin/compressdoc</userinput></screen>

  <para>Maintenant, en tant qu'utilisateur <systemitem class="username">root</systemitem>, 
  vous pouvez exécuter la commande <command>compressdoc --bz2</command> pour
  compresser toutes les pages de man de votre système. Vous pouvez aussi lancer
  <command>compressdoc --help</command> pour obtenir une aide complète les
  possibilités du script.</para>

  <para>N'oubliez pas que quelques paquets tels que le <application>Système
  X Window</application> et <application>XEmacs</application> installent aussi
  leur documentation à des endroits non standards (tels que
  <filename class="directory">/usr/X11R6/man</filename>, etc.). Assurez-vous
  d'ajouter ces emplacements au fichier <filename>/etc/man_db.conf</filename>,
  sous forme de lignes <envar>MANDATORY_MANPATH</envar> <replaceable>&lt;/chemin&gt;</replaceable>.</para>

  <para>Exemple&nbsp;:</para>

<screen><literal>    ...
    MANDATORY_MANPATH                       /usr/share/man
    MANDATORY_MANPATH                       /usr/X11R6/man
    MANDATORY_MANPATH                       /usr/local/man
    MANDATORY_MANPATH                       /opt/qt/doc/man
    ...</literal></screen>

  <para>En général, les systèmes d'installation des paquets ne compressent pas
  les pages de man/info, ce qui veut dire que vous devrez de nouveau lancer le 
  script si vous voulez maintenir la taille de documentation la plus petite
  possible. Remarquez aussi que l'exécution du script après la mise à jour d'un
  paquet est sécurisée&nbsp;; quand vous avez plusieurs versions d'une page
  (par exemple, une compressée et une décompressée), celle la plus récente est
  conservée et les autres sont effacées.</para>

</sect1>
