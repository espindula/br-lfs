<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../../general.ent">
  %general-entities;
]>
<sect1 id="postlfs-firmware" xreflabel="About Firmware">
  <?dbhtml filename="firmware.html"?>
  <sect1info>
    <othername>$LastChangedBy: bdubbs $</othername>
    <date>$Date: 2012-03-13 13:19:34 -0500 (Tue, 13 Mar 2012) $</date>
  </sect1info>
  <title>A propos des Firmwares</title>
  <indexterm zone="postlfs-firmware">
    <primary sortas="e-lib-firmware">/lib/firmware</primary>
  </indexterm>
  <para> Sur certains PCs actuels il peut être nécéssaire, ou désirable, de charger des firmwares
  pour faire travailler les PC au maximum de leurs possibilités. Il y a un répertoire, <filename
  class="directory">/lib/firmware</filename>, ou le noyau ou les pilotes du noyau cherche des images de firmware.
  </para>

  <para>Préparer des firmwares pour de multiples machines différente, comme les distributions le font, est en dehors
  du périmètre de ce livre.
  </para>
  <para>Actuellement, on peut trouver la plupart des firmwares sur un dépot <userinput>git</userinput>
  : <ulink
  url="http://git.kernel.org/cgit/linux/kernel/git/firmware/linux-firmware.git/tree/"/>.
  Par commodité, le projet LFS a créé un mirroir, mis à jour quotidiennement, ou on peut accéder à ces fichiers de
  firmwares via <userinput>wget</userinput> ou un navigateur web à <ulink
  url="&sources-anduin-http;/linux-firmware/"/>.</para>

  <para>Pour avoir le firmware il faut soit aller avec un navigateur sur le dépôt et ensuite télécharger les fichiers
  dont vous
  avez besoin, ou installer
  <userinput>git</userinput> et cloner ce dépot.</para>

  <para>Pour certains autres firmwares, particulièrement pour les microcode d'Intel, et certains
  périphériques wifi, le firmware recherché n'est pas disponible dans le dépôt précédent.
  Certains d'entre eux seront ajouté ensuite, mais il est parfois nécéssaire de faire une recherche sur internet
  pour les firmwares souhaités.
  </para>
  <para>Les fichiers firmwares sont par convention référencés comme des blobs car vous ne pouvez pas
  déterminer ce qu'ils font. Notez que ces firmwares sont distribués sous des licences différentes et variées qui
  ne permettent pas le désassemblage ou la retro ingénierie.
  </para>
  <para>Les firmwares pour PC tombent dans 4 catégories:</para>
  <itemizedlist spacing="compact">
    <listitem>
      <para>Les firmwares mettant à jour le CPU pour travailler correctement, courament appelé microcode.
       </para>
    </listitem>
    <listitem>
      <para>Les firmwares pour les controleurs vidéo. Sur les machines x86 cela semble s'appliquer seulement aux
      périphériques ATI : les Radeons demandent des firmwares pour pouvoir utiliser le KMS
      (kernel modesetting - option préférable) avec Xorg. Pour les puces radéons plus ancienne (avant R600),
      le firmware est resté dans le noyau.
      </para>
    </listitem>
    <listitem>
      <para>Les Firmwares mettant à jour les ports réseaux cablés. Souvent ils fonctionnent sans les mises à jour, mais
      on peut penser qu'ils travaillent mieux avec les firmwares mis à jour.
      </para>
    </listitem>
    <listitem>
      <para>Les Firmwares pour les autres périphériques, comme le wifi. Ces périphériques ne sont pas
      requis pour que le PC démarre, mais demande un firmware avant que ces périphériques puissent être utilisés.
      </para>
    </listitem>
  </itemizedlist>
  <note><para>Comme il n'est pas utile de charger un firmware fermé (blob), les outils
  suivant peuvent être utile pour déterminer, obtenir, ou préparer le firwmare à utiliser afin de le charger dans
  le système.
    <xref linkend="cpio"/>,
    <xref linkend="git"/>,
    <xref linkend="pciutils"/>, et
    <xref linkend="wget"/></para></note>
  <para condition="html" role="usernotes">Notes utilisateur :
  <ulink url="&blfs-wiki;/aboutfirmware"/></para>
  <sect2 id="cpu-microcode">
    <title>Mise à jour de microcodes pour les CPUs</title>
    <para>En général, le microcode peut être chargé par le BIOS ou l'UEFI, et il peut être mis à jour
    en passant à une nouvelle version de celui-çi. Sur linux, vous pouvez également charger
    le microcode depuis le noyau si vous utilisez au moins un AMD de la famille 10h
    ou un plus récent (introduit après 2007), ou un processeur intel de 1980 et plus
    (Pentium4, Core, etc), si un microcode mis à jour a été publié.
    Ces mises à jour sont actives seulement jusqu'à ce que la machine soit éteinte,
    il est donc nécessaire de les appliquer à chaque démarrage.
    </para>

    <para>Il y a deux façons de charger le microcode, décrit comme "au plus tôt" et "le plus tard".
    Le chargement "au plus tôt" arrive avant que l'espace utilisateur ai été démarré, le chargement "le plus tard"
    arrive quand l'espace utilisateur est démarré. Sans surprise, le chargement "au plus tôt" est préféré
    (voir un commentaire d'explication dans un commit du noyau noté e
    <ulink url="https://lwn.net/Articles/530346/">x86/microcode: Early load
    microcode </ulink> sur LWN.)  En effet, il est utile de contourner une erreur particulière dans
    les premièrs processeurs intel Haswell qui ont le TSX d'activé.
    (Voir <ulink
    url="http://www.anandtech.com/show/8376/intel-disables-tsx-instructions-erratum-found-in-haswell-haswelleep-broadwellyi/">
    Intel Disables TSX Instructions: Erratum Found in Haswell, Haswell-E/EP,
    Broadwell-Y</ulink>.) Sans cette mise à jour glibc peut faire des erreurs
    dans des situations particulières.
    </para>

    <para>Il est beaucoup plus simple de commencer par construire un noyau qui démarre sur votre
    matériel, essayer de charger le microcode "le plus tard" pour voir s'il y a une mise à jour (dans la plupart
    des cas le BIOS ou l'UEFI aura déja appliqué toutes les mises à jours), et ensuite
    faire les étapes supplémentaires dans la configuration du noyau pour un chargement "au plus tôt".
    </para>

    <para>Cela signifie que vous devrez reconfigurer votre noyau si vous utilisez le chargement "au plus tôt",
    aussi laissez les sources construites afin de minimiser ce qui aura besoin d'être reconstruit, et si vous
    êtes incertain, ajoutez votre propre identifiant (A, B,  à la fin de l'EXTRAVERSION dans la configuration
    du noyau, soit "EXTRAVERSION -A" si rien est initialisé.
    </para>

    <para>Pour confirmer quel(s) processeur(s) vous avez (si plus d'un, ils seront identiques) regardez dans
    /proc/cpuinfo.</para>
    <sect3 id="intel-microcode">
      <title>Microcode Intel pour le CPU</title>
      <bridgehead renderas="sect4">Paquet requis</bridgehead>
      <para role='required'>
         <ulink url='http://fedorahosted.org/released/microcode_ctl/'/></para>
      <para>Pour les CPU intel, un paquet supplémentaire, microcode_ctl, est requis. Le paquet choisi
      est la version hébergé sur Fedora &mdash; il y a une version alternative sur github du même
      empaqueteur, mais qui laisse une ancienne version redondante d'un container de microcode AMD, et aussi
      requiert le paquet unzip.
      </para>
      <para>Téléchargement de la dernière version depuis le lien précédent; à la dernière vérification, il
      était en version 2.1-7 et est mis à jour quand intel publie de nouveaux microcodes.</para>
      <para>Ce paquet reformate le microcode fourni par intel dans un format que le noyau peut appliquer.
      Le programme <userinput>intel-microcode2ucode</userinput> est construit et invoqué par le
      Makefile pour créer des blobs individuels de firmwares, donc il n'y a pas de raison de les
      installer.</para>
      <para>Commencez par extraire l'archive et allez dans le répertoire créé.
      Ensuite allez dans le répertoire des sources et lancez:</para>
<screen>
<userinput>make</userinput>
</screen>
      <para>Cela crée de nombreux blobs avec des noms de la forme XX-YY-ZZ. Maintenant vous devez
      déterminer l'identité de votre processeur, pour vois s'il y a un microcode pour lui. Déterminez les valeurs
      décimales de la famille du cpu, le modèle, et le pas en lançant:
      </para>
<screen>
<userinput>head -n7 /proc/cpuinfo</userinput>
</screen>
      <para>Maintenant convertissez la famille du cpu, le modèle et le pas en paire de digits héxadécimal.
      Pour un SandyBridge i3-2120 (décrit comme un Intel(R) Core(TM) i3-2120
      CPU) les bonnes valeurs sont famille de cpu 6, modèle 42, pas 7 donc dans ce cas l'identification requise
      est 06-2a-07. Un coup d'oeil sur les blobs montrera qu'il y en a un pour ce CPU (cependant qui semble
      déjà appliqué par le BIOS). S'il y a un blob pour votre système alors testez s'il peut être appliqué
      en le copiant (remplacez &lt;XX-YY-ZZ&gt; par l'identifiant de votre machine) ou le noyau pourra le trouver.
      </para>
<screen>
<userinput>mkdir -pv /lib/firmware/intel-ucode
cp -v &lt;XX-YY-ZZ&gt; /lib/firmware/intel-ucode</userinput>
</screen>
      <para>Maintenant que le microcode intel a été préparé, utilisez les options suivantes
      quand vous configurez le noyau pour essayer le chargement "tard" du microcode intel:
      </para>
<screen>
<literal>Processor type and features  ---&gt;
  &lt;M&gt; CPU microcode loading support  [CONFIG_MICROCODE]
  [*]      Intel microcode loading support [CONFIG_MICROCODE_INTEL]</literal>
</screen>
      <para>Après que vous ayez démarré le nouveau système avec succès, utilisez la commande
      <userinput>dmesg | grep microcode</userinput> et étudiez les résultats pour voir si le message
      patch_level apparait. Voici un exemple pour le
      SandyBridge i3:</para>
<screen>
<literal>[    0.059906] perf_event_intel: PEBS disabled due to CPU errata, please upgrade microcode
[    2.603083] microcode: CPU0 sig=0x206a7, pf=0x2, revision=0x23
[    2.669378] microcode: CPU0 sig=0x206a7, pf=0x2, revision=0x23
[    2.669994] microcode: CPU0 updated to revision 0x29, date = 2013-06-12
[    2.670069] microcode: CPU1 sig=0x206a7, pf=0x2, revision=0x23
[    2.670139] microcode: CPU1 sig=0x206a7, pf=0x2, revision=0x23
[    2.670501] microcode: CPU1 updated to revision 0x29, date = 2013-06-12
[    2.670509] microcode: CPU2 sig=0x206a7, pf=0x2, revision=0x23
[    2.670540] microcode: CPU2 sig=0x206a7, pf=0x2, revision=0x23
[    2.670917] microcode: CPU2 updated to revision 0x29, date = 2013-06-12
[    2.670955] microcode: CPU3 sig=0x206a7, pf=0x2, revision=0x23
[    2.670988] microcode: CPU3 sig=0x206a7, pf=0x2, revision=0x23
[    2.671348] microcode: CPU3 updated to revision 0x29, date = 2013-06-12
[    2.671356] perf_event_intel: PEBS enabled due to microcode update
[    2.671412] microcode: Microcode Update Driver: v2.00 &lt;tigran@aivazian.fsnet.co.uk&gt;, Peter Oruba</literal>
</screen>
    <para>Si le microcode n'a pas été mis à jour, il n'y a pas de nouveau microcode pour ce processeur.
    S'il a été mis à jour, vous pouvez maintenant faire
    <xref linkend="early-microcode"/>.</para>
    </sect3>
    <sect3 id="and-microcode">
      <title>Microcode AMD pour le CPU</title>
      <para>Commencez par télécharger un paquet de firmware pour votre famille de CPU sur
      <ulink
      url='&sources-anduin-http;/linux-firmware/amd-ucode/'/>.
      La famille est toujours spécifiées en héxa. Les familles 10h à 14h (16 à 20)
      sont dans microcode_amd.bin.  Les familles 15h et 16h ont leur propre paquet.
      Créez le répertoire requis et placez le firmware télécharger dedans en tant qu'utilisateur
      <systemitem class="username">root</systemitem>:</para>
<screen>
<userinput>mkdir -pv /lib/firmware/amd-ucode
cp -v microcode_amd* /lib/firmware/amd-ucode</userinput>
</screen>
      <para>Quand vous configurez le noyau, utilisez les options suivantes pour essayer un chargement "tard" du
      microcode AMD:</para>
<screen>
<literal>Processor type and features  ---&gt;
  &lt;M&gt; CPU microcode loading support   [CONFIG_MICROCODE]
  [*]   AMD microcode loading support [CONFIG_MICROCODE_AMD]</literal>
</screen>
      <para>After you have successfully booted the new system, use the command
      <userinput>dmesg | grep microcode</userinput> et study the results to see
      if the message new patch_level appears, as in this example from an old
      Athlon(tm) II X2:</para>
<screen>
<literal>[    4.183907] microcode: CPU0: patch_level=0x010000b6
[    4.184271] microcode: CPU0: new patch_level=0x010000c8
[    4.184278] microcode: CPU1: patch_level=0x010000b6
[    4.184283] microcode: CPU1: new patch_level=0x010000c8
[    4.184359] microcode: Microcode Update Driver: v2.00 &lt;tigran@aivazian.fsnet.co.uk&gt;, Peter Oruba</literal>
</screen>
    <para>Si le microcode n'a pas été mis à jour, il n'y a pas de nouveau microcode pour ce processeur.
    S'il a été mis à jour, vous pouvez maintenant faire
    <xref linkend="early-microcode"/>.</para>
    </sect3>
    <sect3 id="early-microcode">
      <title>Chargement "tôt" du microcode</title>
      <para>Si vous avez établi d'un microcode mis à jour est disponible pour votre système,
      il est temps de le préparer pour un chargement "tôt". Cela demande un paquet supplémentaire,
      <xref linkend="cpio"/>, ainsi que des modifications à la configuration du noyau et la création d"un initrd
      qui devra être ajouté à grub.cfg.
      </para>
      <para>L'endroit ou vous préparez l'initrd n'est pas important, et une fois fonctionnel vous pouvez appliquer
      le même initrd aux versions futures de LFS ou aux nouveaux noyaux sur cette même machine, au moins jusqu'à ce qu'une
      nouvelle version du microcode soit publiée. Utiliser la suite :
      </para>
<screen>
<userinput>mkdir -p initrd/kernel/x86/microcode
cd initrd</userinput>
</screen>
      <para>Pour une machine AMD, utilisez la commande suivante (remplacez
      &lt;MYCONTAINER&gt; par le nom du paquet de votre famille de CPU):
      </para>
<screen>
<userinput>cp -v /lib/firmware/amd_ucode/&lt;MYCONTAINER&gt; kernel/x86/microcode/AuthenticAMD.bin</userinput>
</screen>
      <para>Ou pour une machine intel copiez le blob approprié en utilisant cette commande:</para>
<screen>
<userinput>cp -v /lib/firmware/intel-ucode/&lt;XX-YY-ZZ&gt; kernel/x86/microcode/GenuineIntel.bin</userinput>
</screen>
      <para>Maintenant préparez l'initrd:</para>
<screen>
<userinput>find . | cpio -o -H newc &gt; /boot/microcode.img</userinput>
</screen>
      <para>Vous devez maintenant reconfigurer et reconstruire votre noyau. Il est prudent pour chaque d'ajouter/changer
      l'EXTRAVERSION dans la configuration du noyau et d'installer le nouveau noyau avec un nouveau nom, ou alors (à moins
      que vous ayez une machine qui requiert une mise à jour du firmware "tôt") attendre la prochaine publication
      SUBLEVEL du noyau de sorte que vous puissiez revenir au noyau existant
       dans le cas où quelque chose irait mal.
      </para>
      <para>Vous devrez également ajouter une nouvelle entrée à /boot/grub/grub.cfg et
      vous devrez ajouter une ligne apres la ligne linux.
      Si /boot est dans une partition séparée: </para>
<screen>
<userinput>initrd /microcode.img</userinput>
</screen>
      <para>ou sinon :</para>
<screen>
<userinput>initrd /boot/microcode.img</userinput>
</screen>
      <para>Vous devez également modifier la config du noyau:</para>
<screen>
<literal>General Setup ---&gt;
  [y] Initial RAM filesystem and RAM disk (initramfs/initrd) support [CONFIG_BLK_DEV_INITRD]
  [y] CPU microcode loading support                                  [CONFIG_MICROCODE]</literal>
</screen>
      <para>Retenez l'initialisation pour le microcode INTEL ou AMD. Quand vous avez sauvegardé le fichier .config,
       soit CONFIG_MICROCODE_INTEL_EARLY=y ou
      CONFIG_MICROCODE_AMD_EARLY=y doit être initialisé, avec
      CONFIG_MICROCODE_EARLY=y.</para>
      <para>Quand vous avez installé et démarré ce noyau, vous pouvez vérifier la sortie de dmesg pour confirmer
      que le chargement "tôt" fonctionne. Les endroits et les temps ou cela se passent sont très différents
      sur les machines AMD et Intel. En premier, un exemple d'Intel ou un noyau de développment est testé, regardez que la première
      notification vient avant que la version du noyau soit indiquée:
      </para>
<screen>
<literal>[    0.000000] CPU0 microcode updated early to revision 0x29, date = 2013-06-12
[    0.000000] Linux version 4.0.0-rc6 (ken@jtm1) (gcc version 4.9.2 (GCC) )
               #3 SMP PREEMPT Mon Mar 30 21:26:02 BST 2015
[    0.000000] Command line: BOOT_IMAGE=/vmlinuz-4.0.0-rc6-sda13 root=/dev/sda13 ro
...
[    0.103091] CPU1 microcode updated early to revision 0x29, date = 2013-06-12
[    0.113241]  #2
[    0.134631]  #3
[    0.147821] x86: Booted up 1 node, 4 CPUs
[    0.147936] smpboot: Total of 4 processors activated (26338.66 BogoMIPS)
...
[    0.272643] microcode: CPU0 sig=0x206a7, pf=0x2, revision=0x29
[    0.272709] microcode: CPU1 sig=0x206a7, pf=0x2, revision=0x29
[    0.272775] microcode: CPU2 sig=0x206a7, pf=0x2, revision=0x29
[    0.272842] microcode: CPU3 sig=0x206a7, pf=0x2, revision=0x29
[    0.272941] microcode: Microcode Update Driver: v2.00 &lt;tigran@aivazian.fsnet.co.uk&gt;, Peter Oruba</literal>
</screen>
      <para>Un deuxième exemple AMD ou la machine lance un noyau stable sur une ancienne version de LFS. Notez que ici, il n'est
      pas indiqué la version du microcode précédent &mdash; comparez cette sortie aux messages de chargement
      "tard" (plus haut) de la même machine:</para>
<screen>
<literal>[    0.000000] Linux version 3.18.11 (ken@milliways) (gcc version 4.9.1 (GCC) )
               #4 SMP Thu Apr 9 21:51:05 BST 2015
[    0.000000] Command line: BOOT_IMAGE=/vmlinuz-3.18.11-sda5 root=/dev/sda5 video=800x600 ro
...
[    0.584009] Trying to unpack rootfs image as initramfs...
[    0.584092] microcode: updated early to new patch_level=0x010000c8
...
[    0.586733] microcode: CPU0: patch_level=0x010000c8
[    0.586778] microcode: CPU1: patch_level=0x010000c8
[    0.586866] microcode: Microcode Update Driver: v2.00 &lt;tigran@aivazian.fsnet.co.uk&gt;, Peter Oruba</literal>
</screen>
    </sect3>
  </sect2>
  <sect2 id="ati-video-firmware">
    <title>Firmware pour les puces video ATI (R600 et plus)</title>

    <para>Ces instructions NE s'applique pas aux anciennes radaeons avant la famille R600.
    Pour elles, le firmware est dans le répertoire du noyau <filename
    class='directory'>/lib/firmware/</filename>. Appliquez les seulement si vous prévoyez d'éviter une configuration graphique
    tels que Xorg et que vous voulez vous contenter d'utiliser l'affichage 80x25 par défaut plutôt qu'un framebuffer.
    </para>
    <para> Les périphériques radéon plus récent demande seulement un simple blod de 2Ko.
    Les périphériques récents ont besoin de plusieurs blobs différents, et certain d'entre eux sont plus gros. La taille
    totale du répertoire des firmwares radéon est de plus de 500 ko &mdash; sur un gros système moderne vous pouvez probablement
    utiliser cet espace, mais cela reste redondant d'installer tous les fichiers inutiles chaque fois que vous construisez
    un système.
</para>
    <para>Une meilleure approche est d'installer <xref linkend="pciutils"/> et ensuite utiliser
    <userinput>lspci</userinput> pour identifier quel controleur VGA est installé.
    </para>
    <para>Avec cette information, vérifiez la page RadeonFeature du wiki Xorg
    <ulink url="http://wiki.x.org/wiki/RadeonFeature/#index5h2">Decoder
    ring for engineering vs marketing names</ulink> pour identifier la famille (vous aurez besoin de savoir
    cela pour identifier le pilote Xorg dans BLFS &mdash; Southern Islands et
    Sea Islands utilise le pilote radeonsi) et le modèle spécifique.</para>
    <para>Maintenant que vous savez quel contrôleur vous allez utiliser, consultez la page
    <ulink url="https://wiki.gentoo.org/wiki/Radeon#Firmware">Radeon</ulink> du wiki Gentoo qui a un tableau
    listant les blobs de firmware requis pour les différentes puces. Notez que
    les puces Southern Islands et Sea Islands utilise des firmwares différents pour les noyaux
    3.17 et supérieur en comparaison des kernels antérieurs. Identifiez et téléchargez les blobs requis
    et ensuite installez les:
    </para>
<screen>
<userinput>mkdir -pv /lib/firmware/radeon
cp -v &lt;YOUR_BLOBS&gt; /lib/firmware/radeon</userinput>
</screen>
    <para>Il y a actuellement deux façons d'installer ces firmwares. BLFS, dans le sous-chapitre
    'Configuration du noyau pour les firmwares supplémentaires' du chapitre <xref
    linkend="xorg-ati-driver"/> donne un exemple de compilation des firmwares dans le noyau - c'est légèrement
    plus rapide à charger, mais utilises plus de mémoire pour le noyau. Ici nous utiliserons la méthode alternative en
    faisant un module du pilote radeon. Dans votre configuration du noyau initialisez la suite :
    </para>
<screen>
<literal>Device Drivers ---&gt;
  Graphics support ---&gt;
      Direct Rendering Manager ---&gt;
            &lt;*&gt; Direct Rendering Manager (XFree86 ... support)  [CONFIG_DRM]
            &lt;m&gt; ATI Radeon                                      [CONFIG_DRM_RADEON]</literal>
</screen>
    <para>Le chargement de plusieurs blobs volumineux dans /lib/firmware prend un temps notable, pendant lequel
    l'écran est blanc. Si vous n'avez pas activé le logo framebuffer du pingouin, ou changé la taille de la console
    en utilisant une police plus grosse, cela n'a probablement pas d'importance. Si vous le souhaitez, vous pouvez légèrement
    réduire le temps si vous vuivez la méthode alternative en spécifiant 'y' pour
    CONFIG_DRM_RADEON couvert dans BLFS au lien précédent &mdash; vous devez spécifier chaque blob radéon utile si vous
    faite cela.</para>
  </sect2>
  <sect2 id="nic-firmware">
    <title>Firmware pour les interfaces réseaux</title>
    <para>Le noyau aime charger des firmware pour quelques pilotes réseau,
    particulièrement ceux du répertoire Realtek (/lib/linux-firmware/rtl_nic/),
    mais il apparait généralement que cela fonctionne sans. Cependant, vous pouvez démarrer le noyau, vérifiez dmesg
    pour les messages à propos de firmwares manquants, et si nécessaire télécharger les firmwares et les mettre dans
    un répertoire spécifique dans
    /lib/firmware afin qu'ils puissent être trouvés pendant la séquence de démarrage. Notez qu'avez les noyaux actuels
    cela fonctionne que le pilote soit compilé dedans ou construit comme un module, il n'est pas utile de construire
    ce firmware dans le noyau. Ici un exemple ou le pilote R8169 a été compilé dedans mais le firmware
    n'est pas disponible. Une fois que le firmware a été fourni, il n'y est plus fait mention dans les démarrages
    suivants. </para>
<screen>
<literal>dmesg | grep firmware | grep r8169
[    7.018028] r8169 0000:01:00.0: Direct firmware load for rtl_nic/rtl8168g-2.fw failed with error -2
[    7.018036] r8169 0000:01:00.0 eth0: unable to load firmware patch rtl_nic/rtl8168g-2.fw (-2)</literal>
</screen>
  </sect2>
  <sect2 id="other-firmware">
    <title>Firmware pour les autres périphériques</title>
    <para> L'identification du bon firmware requiera typiquement l'installation de
    <xref linkend="pciutils"/>, et ensuite l"utilisation de <userinput>lspci</userinput> pour identifier le périphérique.
    Vous pouvez ensuite chercher en ligne pour vérifier quel module il utilise. quel firmware, et ou obtenir le firmware
    &mdash; aucun de ceux la est dans linux-firmware.</para>

    <para>Si possible, vous pouvez commencer par utiliser une connexion cablé quand vous démarrez la première fois votre
    système LFS. Pour utiliser une connexion sans fils vous aurez besoin d'utiliser des outils réseau tel que
    <xref linkend="wireless_tools"/> et <xref
    linkend="wpa_supplicant"/>.</para>

    <para>Les firmwares peuvent aussi être utiles pour d'autres périphériques comme les contrôleurs
    SCSI, les adaptateurs bluetooth, ou les enregistreurs TV. Les mêmes principes s'appliquent.
    </para>
  </sect2>
</sect1>
