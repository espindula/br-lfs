<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../../general.ent">
  %general-entities;

  <!ENTITY certhost              "http://mxr.mozilla.org">
  <!ENTITY certdir               "/mozilla/source/security/nss/lib/ckfw/builtins">
  <!ENTITY ca-bundle-download    "&certhost;&certdir;/certdata.txt?raw=1">
  <!ENTITY ca-bundle-size        "1.2 Mio">
  <!ENTITY cacerts-buildsize     "1.2 Mio">
  <!ENTITY cacerts-time          "moins de 0.1 SBU">
]>

<sect1 id="cacerts" xreflabel="Certificate Authority Certificates">
  <?dbhtml filename="cacerts.html"?>

  <sect1info>
    <othername>$LastChangedBy&nbsp;: bdubbs $</othername>
    <date>$Date&nbsp;: 2012-06-10 18:40:18 +0200 (Sun, 10 Jun 2012) $</date>
  </sect1info>

  <title>Certificate Authority Certificates</title>

  <para>La <foreignphrase>Public Key Inrastructure</foreignphrase> (infrastructure
  de clés publiques) est utilisés dans de nombreux cas de sécurité sur un système
  Linux. Pour qu'un certificat soit fiable, il doit être signé par  un agent
  de confiance, qu'on appelle l'autorité de certificat (<foreignphrase>Certificate 
  Authority</foreignphrase>) (CA).  Les certificats chargés dans cette section
  sont issus de la liste du système de contrôle de on the Mozilla et elle
  est formatée dans une forme utilisée par <xref linkend='openssl'/>.  Les
  certificats peuvent également être utilisés par d'autres applications, 
  directement ou indirectement via
  <application>openssl</application>.</para>

  &lfs70_checked;

  <indexterm zone="cacerts">
    <primary sortas="a-cacerts">Certificate Authority Certificates</primary>
  </indexterm>

  <sect2 role="package">
    <title>Introduction à Certificate Authorities</title>

   <bridgehead renderas="sect3">Informations sur le paquet</bridgehead>
    <itemizedlist spacing="compact">
      <listitem>
        <para>Téléchargement du Certificat CA>&nbsp;: <ulink url="&ca-bundle-download;"/></para>
      </listitem>
      <listitem>
        <para>Taille du bouquet CA>&nbsp;: &ca-bundle-size;</para>
      </listitem>
      <listitem>
        <para>Estimation de l'espace disque requis&nbsp;: &cacerts-buildsize;</para>
      </listitem>
      <listitem>
        <para>Estimation du temps de construction&nbsp;: &cacerts-time;</para>
      </listitem>
    </itemizedlist>

    <bridgehead renderas="sect3">Dépendances de Certificate Authority Certificates</bridgehead>

    <bridgehead renderas="sect4">Requises</bridgehead>
    <para role="required"><xref linkend="openssl"/></para>

    <bridgehead renderas="sect4">Facultative</bridgehead>
    <para role="optional"><xref linkend="wget"/></para>

    <para condition="html" role="usernotes">Notes utilisateur&nbsp;:
    <ulink url='&blfs-wiki;/cacerts'/></para>
  </sect2>

  <sect2 role="installation">
    <title>Installation de Certificate Authority Certificates</title>

    <para>Créez d'abord un script pour reformatter un certificat en forme dont
    a besoin <application>openssl</application>. En tant qu'utilisateur <systemitem
    class="username">root</systemitem>&nbsp;:</para>

  <screen role="root"><userinput>cat > /bin/make-cert.pl &lt;&lt; "EOF"
 #!/usr/bin/perl -w

# Utilisé pour générer des fichiers encodés en PEM à partir du certdata.txt de
# Mozilla. Lancez en tant que ./mkcrt.pl > certificate.crt
#
# Nous devons des parties de ce script à RedHat (mkcabundle.pl)
#
# Ce script modifié pour être utilisé avec un seul fichier de données
# (tempfile.cer) extrait de certdata.txt, récupéré dans la dernière version 
# des sources de Mozilla NSS.
# mozilla/security/nss/lib/ckfw/builtins/certdata.txt
#
# Auteurs&nbsp;: DJ Lucas
#
# Version 20120211

my $certdata = './tempfile.cer';

open( IN, "cat $certdata|" )
    || die "could not open $certdata";

my $incert = 0;

while ( &lt;IN&gt; ) 
{
    if ( /^CKA_VALUE MULTILINE_OCTAL/ ) 
    {
        $incert = 1;
        open( OUT, "|openssl x509 -text -inform DER -fingerprint" )
            || die "could not pipe to openssl x509";
    } 
    
    elsif ( /^END/ &amp;&amp; $incert ) 
    {
        close( OUT );
        $incert = 0;
        print "\n\n";
    } 
    
    elsif ($incert) 
    {
        my @bs = split( /\\/ );
        foreach my $b (@bs) 
        {
            chomp $b;
            printf( OUT "%c", oct($b) ) unless $b eq '';
        }
    }
}
EOF

chmod +x /bin/make-cert.pl</userinput></screen>

   <para>Le script suivant crée les certificats et un bouquet de tous les
   certificats. Il crée un répertoire <filename class='directory'>./certs</filename>
   et <filename>./BLFS-ca-bundle-${VERSION}.crt</filename>.  Créez de nouveau
   ce script en tant qu'utilisateur <systemitem class="username">root</systemitem>&nbsp;:</para>

   <screen role="root"><userinput>cat > /bin/make-ca.sh &lt;&lt; "EOF"
#!/bin/bash
# Début de make-ca.sh
# Script pour peupler le CApath d'OpenSSL à partir d'un bouquet de CAs au 
# format PEM 
#
# Le fichier certdata.txt doit exister dans le répertoire local
# On obtient le numéro de version à partir de la version des données.
#
# Auteurs: DJ Lucas
#
# Version 20120211

certdata="certdata.txt"

if [ ! -r $certdata ]; then
  echo "$certdata must be in the local directory"
  exit 1
fi

REVISION=$(grep CVS_ID $certdata | cut -f4 -d'$')

if [ -z "${REVISION}" ]; then
  echo "$certfile has no 'Revision' in CVS_ID"
  exit 1
fi

VERSION=$(echo $REVISION | cut -f2 -d" ")

TEMPDIR=$(mktemp -d)
TRUSTATTRIBUTES="CKA_TRUST_SERVER_AUTH"
BUNDLE="BLFS-ca-bundle-${VERSION}.crt"
CONVERTSCRIPT="make-cert.pl"
SSLDIR="/etc/ssl"

mkdir "${TEMPDIR}/certs"

# Récupérer une liste des lignes bizarres pour chaque certif
CERTBEGINLIST=$(grep -n "^# Certificate" "${certdata}" | cut -d ":" -f1)

# Récupérer une liste des lignes finales pour chaque certif
CERTENDLIST=`grep -n "^CKA_TRUST_STEP_UP_APPROVED" "${certdata}" | cut -d ":" -f 1`

# Démarrer une boucle
for certbegin in ${CERTBEGINLIST}; do
  for certend in ${CERTENDLIST}; do
    if test "${certend}" -gt "${certbegin}"; then
      break
    fi
  done

  # Envoi vers un fichier temp avec le nom des fichiers en tant que numéro du
  # début de ligne 
  sed -n "${certbegin},${certend}p" "${certdata}" > "${TEMPDIR}/certs/${certbegin}.tmp"
done

unset CERTBEGINLIST CERTDATA CERTENDLIST certebegin certend

mkdir -p certs
rm certs/*      # Make sure the directory is clean

for tempfile in ${TEMPDIR}/certs/*.tmp; do
  # S'assure que le certif est fiable...
  grep "CKA_TRUST_SERVER_AUTH" "${tempfile}" | \
    grep "TRUST_UNKNOWN|NOT_TRUSTED" > /dev/null

  if test "${?}" = "0"; then
    # Affiche une erreur significative et supprime le fichier
    cp "${tempfile}" tempfile.cer
    "${CONVERTSCRIPT}" > tempfile.crt
    keyhash=$(openssl x509 -noout -in tempfile.crt -hash)
    echo "Certificate ${keyhash} is not trusted!  Removing..."
    rm -f tempfile.cer tempfile.crt "${tempfile}"
    continue
  fi

  # Si on exécute à ce moment de la boucle, le certif temporaire est fiable
  # Chercher les données du certif et génère pour lui un fichier de certif

  cp "${tempfile}" tempfile.cer
  "${CONVERTSCRIPT}" > tempfile.crt
  keyhash=$(openssl x509 -noout -in tempfile.crt -hash)
  mv tempfile.crt "certs/${keyhash}.pem"
  rm -f tempfile.cer "${tempfile}"
  echo "Created ${keyhash}.pem"
done

# Supprime les fichiers blacklistés (mis sur liste noire)
# MD5 Collision Proof of Concept CA
if test -f certs/8f111d69.pem; then
  echo "Certificate 8f111d69 is not trusted!  Removing..."
  rm -f certs/8f111d69.pem
fi

# Enfin, génère le bouquet et nettoie.
cat certs/*.pem >  ${BUNDLE}
rm -r "${TEMPDIR}"
EOF

chmod +x /bin/make-ca.sh</userinput></screen>

   <para>Ajoutez un script bref pour supprimer les certificts expirés d'un
   répertoire. Créez de nouveau ce script en tant qu'utilisateur
   <systemitem
   class="username">root</systemitem>&nbsp;:</para>

  <screen role="root"><userinput>cat > /bin/remove-expired-certs.sh &lt;&lt; "EOF"
#!/bin/bash
# Début de /bin/remove-expired-certs.sh
#
# Version 20120211
 
# Garantie que la date soit bien analysée sur tous les systèmes
function mydate()
{
  local y=$( echo $1 | cut -d" " -f4 )
  local M=$( echo $1 | cut -d" " -f1 )
  local d=$( echo $1 | cut -d" " -f2 )
  local m
  
  if [ ${d} -lt 10 ]; then d="0${d}"; fi

  case $M in
    Jan) m="01";;
    Feb) m="02";;
    Mar) m="03";;
    Apr) m="04";;
    May) m="05";;
    Jun) m="06";;
    Jul) m="07";;
    Aug) m="08";;
    Sep) m="09";;
    Oct) m="10";;
    Nov) m="11";;
    Dec) m="12";;
  esac

  certdate="${y}${m}${d}"
}

OPENSSL=/usr/bin/openssl
DIR=/etc/ssl/certs

if [ $# -gt 0 ]; then
  DIR="$1"
fi

certs=$( find ${DIR} -type f -name "*.pem" -o -name "*.crt" )
today=$( date +%Y%m%d )

for cert in $certs; do
  notafter=$( $OPENSSL x509 -enddate -in "${cert}" -noout )
  date=$( echo ${notafter} |  sed 's/^notAfter=//' )
  mydate "$date"

  if [ ${certdate} -lt ${today} ]; then
     echo "${cert} expired on ${certdate}! Removing..."
     rm -f "${cert}"
  fi
done
EOF

chmod +x /bin/remove-expired-certs.sh</userinput></screen>

   <para>Les commandes suivantes récupèreront les certificats et les convertit
   dans le bon format.  Si vous le désirez, vous pouvez utiliser un navigateur
   Internet plutôt que <application>wget</application> mais le fichier devra
   être enregistré sous le nom <filename>certdata.txt</filename>.  Ces commandes
   peuvent être répétées autant de fois que nécessaire pour mettre à jour
   les Certificats CA.</para>

   <screen><userinput>certhost='http://mxr.mozilla.org'                        &amp;&amp;
certdir='/mozilla/source/security/nss/lib/ckfw/builtins' &amp;&amp;
url="$certhost$certdir/certdata.txt?raw=1"               &amp;&amp;

wget --output-document certdata.txt $url &amp;&amp;
unset certhost certdir url               &amp;&amp;
make-ca.sh                               &amp;&amp;
remove-expired-certs.sh certs</userinput></screen>

   <para>Maintenant, en tant qu'utilisateur the <systemitem class="username">root</systemitem>&nbsp;:</para>

<screen role="root"><userinput>SSLDIR=/etc/ssl                                     &amp;&amp;
install -d ${SSLDIR}/certs                          &amp;&amp;
cp -v certs/*.pem ${SSLDIR}/certs                   &amp;&amp;
c_rehash                                            &amp;&amp;
install BLFS-ca-bundle*.crt ${SSLDIR}/ca-bundle.crt &amp;&amp;
unset SSLDIR</userinput></screen>

   <para>Enfin, nettoyez le répertoire courant&nbsp;:</para>

<screen><userinput>rm -r certs BLFS-ca-bundle*</userinput></screen>

  </sect2>

  <sect2 role="content">
    <title>Contenu</title>

    <segmentedlist>
      <segtitle>Programmes installés</segtitle>
      <segtitle>Bibliothèques installées</segtitle>
      <segtitle>Répertoires installés</segtitle>

      <seglistitem>
        <seg>make-ca.sh, make-cert.pl et remove-expired-certs.sh</seg>
        <seg>Aucune</seg>
        <seg>/etc/ssl/certs</seg>
      </seglistitem>
    </segmentedlist>

   <variablelist>
      <bridgehead renderas="sect3">Descriptions courtes</bridgehead>
      <?dbfo list-presentation="list"?>
      <?dbhtml list-presentation="table"?>

      <varlistentry id="make-ca">
        <term><command>make-ca.sh</command></term>
        <listitem>
          <para>est un script <application>bash</application> qui reformate
          le fichier <filename>certdata.txt</filename> pour que
          <application>openssl</application> l'utilise.</para>
          <indexterm zone="cacerts make-ca">
            <primary sortas="b-make-ca">make-ca</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="make-cert">
        <term><command>make-cert.pl</command></term>
        <listitem>
          <para>est un script <application>perl</application> qui
          convertit un certificat binaire unique (format .der) au format .pem.</para>
          <indexterm zone="cacerts make-cert">
            <primary sortas="b-make-cert">make-cert</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="remove-expired-certs">
        <term><command>remove-expired-certs.sh</command></term>
        <listitem>
          <para>est un script <application>perl</application> qui supprime
          les certificats expirés d'un répertoire. Le répertoire par défaut est
          <filename class='directory'>/etc/ssl/certs</filename>.</para>
          <indexterm zone="cacerts remove-expired-certs">
            <primary sortas="b-remove-expired-certs">remove-expired-certs</primary>
          </indexterm>
        </listitem>
      </varlistentry>

   </variablelist>

  </sect2>
</sect1>
