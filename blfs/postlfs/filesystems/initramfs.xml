<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
  "http://www.oasis-opeGGn.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../../general.ent">
  %general-entities;
]>
<sect1 id="initramfs">
  <?dbhtml filename="initramfs.html"?>
  <sect1info>
    <othername>$LastChangedBy : randy $</othername>
    <date>$Date : 2013-02-11 19:51:17 +0100 (Mon, 11 Feb 2013) $</date>
  </sect1info>
  <title>A propos de initramfs</title>
  <para>La seule fonction d'un initramfs est de monter le système de fichier racine.
  L'initramfs est un ensemble complet de répertoires que vous pouvez trouver dans un
  système de fichiers racine normal. Il est regroupé dans une seule archive cpio et compressé
  avec l'un des nombreux algorithmes de compression.</para>
  <para>Au moment du démarrage, le chargeur de démarrage charge le noyau et l'image initramfs
  dans la mémoire et démarre le noyau. Le noyau vérifie la présence d'un initramfs et,
  s'il le trouve, le monte sur / et lance /init. Le programme init est
  typiquement un script shell.  Notez que le processus de démarrage est plus long, même
  significativement plus long, si un initramfs est utilisé.</para>
  <para>Pour la plupart des distributions, les modules du noyau sont la plus importante raison d'avoir un
  initramfs. Dans une distribution générale, il y a beaucoup d'inconnues comme les types de systèmes de fichiers
  et les couches des disques. Dans un sens, c'est l'opposé de LFS où les capacités et les couches du systèmes
  sont connus et un noyau personnalisé est normallement construit.
  Dans cette situation, un initramfs est rarement nécessaire.</para>
  <para>Il y a seulement quatre raison d'avoir un initramfs dans un environnement LFS&nbsp;:
  le chargement du rootfs depuis le réseau, son chargement depuis un volume logique LVM,
  avoir un rootfs chiffré ou un mot de passe est requis, ou pour le confort
  d'un rootfs spécifié par un LABEL ou un UUID. Les autres cas signifient souvent que 
  le noyau n'est pas configuré correctement.</para>
  <sect2 id="initramfs-build">
    <title>Construire un initramfs</title>
    <para>Si vous décidez de construire un initramfs, les scripts suivants
    fourniront les bases pour le faire. Les scripts autoriseront la spécification du 
    rootfs via un UUID de partition ou un LABEL de partition ou un rootfs dans un volume logique
    LVM. Ils ne supportent pas les systèmes de fichier racine chiffrés ou le montage
    des rootfs par des cartes réseaux. Pour plus d'informations sur les possibilités,voir
    <ulink url="http://www.linuxfromscratch.org/hints/read.html">
    L'astuce LFS </ulink> ou <ulink url="http://fedoraproject.org/wiki/Dracut">
    dracut</ulink>.</para>
    <para>Pour installer ces scripts, lancez les commandes suivantes en tant qu'utilisateur
    <systemitem class="username">root</systemitem>&nbsp;:</para>
    
<screen role="root">
<userinput>cat &gt; /sbin/mkinitramfs &lt;&lt; "EOF"
#!/bin/bash
# This file based in part on the mkinitrafms script for the LFS LiveCD
# written by Alexander E. Patrakov and Jeremy Huntwork.
copy()
{
  local file
  if [ "$2" == "lib" ]; then
    file=$(PATH=/lib:/usr/lib type -p $1)
  else
    file=$(type -p $1)
  fi
  if [ -n $file ] ; then
    cp $file $WDIR/$2
  else
    echo "Missing required file: $1 for directory $2"
    rm -rf $WDIR
    exit 1
  fi
}
if [ -z $1 ] ; then
  INITRAMFS_FILE=initrd.img-no-kmods
else
  KERNEL_VERSION=$1
  INITRAMFS_FILE=initrd.img-$KERNEL_VERSION
fi
if [ -n "$KERNEL_VERSION" ] &amp;&amp; [ ! -d "/lib/modules/$1" ] ; then
  echo "No modules directory named $1"
  exit 1
fi
printf "Creating $INITRAMFS_FILE... "
binfiles="sh cat cp dd killall ls mkdir mknod mount "
binfiles="$binfiles umount sed sleep ln rm uname"
sbinfiles="udevadm modprobe blkid switch_root"
#Optional files and locations
for f in mdadm udevd; do
  if [ -x /sbin/$f ] ; then sbinfiles="$sbinfiles $f"; fi
done
unsorted=$(mktemp /tmp/unsorted.XXXXXXXXXX)
DATADIR=/usr/share/mkinitramfs
INITIN=init.in
# Create a temporrary working directory
WDIR=$(mktemp -d /tmp/initrd-work.XXXXXXXXXX)
# Create base directory structure
mkdir -p $WDIR/{bin,dev,lib/firmware,run,sbin,sys,proc}
mkdir -p $WDIR/etc/{modprobe.d,udev/rules.d}
touch $WDIR/etc/modprobe.d/modprobe.conf
ln -s lib $WDIR/lib64
# Create necessary device nodes
mknod -m 640 $WDIR/dev/console c 5 1
mknod -m 664 $WDIR/dev/null    c 1 3
# Install the udev configuration files
if [ -f /etc/udev/udev.conf ]; then
  cp /etc/udev/udev.conf $WDIR/etc/udev/udev.conf
fi
for file in $(find /etc/udev/rules.d/ -type f) ; do
  cp $file $WDIR/etc/udev/rules.d
done
# Install any firmware present
cp -a /lib/firmware $WDIR/lib
# Copy the RAID configureation file if present
if [ -f /etc/mdadm.conf ] ; then
  cp /etc/mdadm.conf $WDIR/etc
fi
# Install the init file
install -m0755 $DATADIR/$INITIN $WDIR/init
if [  -n "$KERNEL_VERSION" ] ; then
  if [ -x /bin/kmod ] ; then
    binfiles="$binfiles kmod"
  else
    binfiles="$binfiles lsmod"
    sbinfiles="$sbinfiles insmod"
  fi
fi
# Install basic binaries
for f in $binfiles ; do
  ldd /bin/$f | sed "s/\t//" | cut -d " " -f1 &gt;&gt; $unsorted
  copy $f bin
done
# Add lvm if present
if [ -x /sbin/lvm ] ; then sbinfiles="$sbinfiles lvm dmsetup"; fi
for f in $sbinfiles ; do
  ldd /sbin/$f | sed "s/\t//" | cut -d " " -f1 &gt;&gt; $unsorted
  copy $f sbin
done
# Add udevd libraries if not in /sbin
if [ -x /lib/udev/udevd ] ; then
  ldd /lib/udev/udevd | sed "s/\t//" | cut -d " " -f1 >> $unsorted
fi
# Add module symlinks if appropriate
if [ -n "$KERNEL_VERSION" ] &amp;&amp; [ -x /bin/kmod ] ; then
  ln -s kmod $WDIR/bin/lsmod
  ln -s kmod $WDIR/bin/insmod
fi
# Add lvm symlinks if appropriate
# Also copy the lvm.conf file
if  [ -x /sbin/lvm ] ; then
  ln -s lvm $WDIR/sbin/lvchange
  ln -s lvm $WDIR/sbin/lvrename
  ln -s lvm $WDIR/sbin/lvextend
  ln -s lvm $WDIR/sbin/lvcreate
  ln -s lvm $WDIR/sbin/lvdisplay
  ln -s lvm $WDIR/sbin/lvscan
  ln -s lvm $WDIR/sbin/pvchange
  ln -s lvm $WDIR/sbin/pvck
  ln -s lvm $WDIR/sbin/pvcreate
  ln -s lvm $WDIR/sbin/pvdisplay
  ln -s lvm $WDIR/sbin/pvscan
  ln -s lvm $WDIR/sbin/vgchange
  ln -s lvm $WDIR/sbin/vgcreate
  ln -s lvm $WDIR/sbin/vgscan
  ln -s lvm $WDIR/sbin/vgrename
  ln -s lvm $WDIR/sbin/vgck
  # Conf file(s)
  cp -a /etc/lvm $WDIR/etc
fi
# Install libraries
sort $unsorted | uniq | while read library ; do
  if [ "$library" == "linux-vdso.so.1" ] ||
     [ "$library" == "linux-gate.so.1" ]; then
    continue
  fi
  copy $library lib
done
cp -a /lib/udev $WDIR/lib
# Install the kernel modules if requested
if [ -n "$KERNEL_VERSION" ]; then
  find                                                                        \
     /lib/modules/$KERNEL_VERSION/kernel/{crypto,fs,lib}                      \
     /lib/modules/$KERNEL_VERSION/kernel/drivers/{block,ata,md,firewire}      \
     /lib/modules/$KERNEL_VERSION/kernel/drivers/{scsi,message,pcmcia,virtio} \
     /lib/modules/$KERNEL_VERSION/kernel/drivers/usb/{host,storage}           \
     -type f 2&gt; /dev/null | cpio --make-directories -p --quiet $WDIR
  cp /lib/modules/$KERNEL_VERSION/modules.{builtin,order}                     \
            $WDIR/lib/modules/$KERNEL_VERSION
  depmod -b $WDIR $KERNEL_VERSION
fi
( cd $WDIR ; find . | cpio -o -H newc --quiet | gzip -9 ) &gt; $INITRAMFS_FILE
# Remove the temporary directory and file
rm -rf $WDIR $unsorted
printf "done.\n"
EOF
<command>chmod 0755 /sbin/mkinitramfs</command></userinput>
</screen>
    
<screen role="root">
<userinput>mkdir -p /usr/share/mkinitramfs &amp;&amp;
cat &gt; /usr/share/mkinitramfs/init.in &lt;&lt; "EOF"
#!/bin/sh
PATH=/bin:/usr/bin:/sbin:/usr/sbin
export PATH
problem()
{
   printf "Encountered a problem!\n\nDropping you to a shell.\n\n"
   sh
}
no_device()
{
   printf "The device %s, which is supposed to contain the\n" $1
   printf "root file system, does not exist.\n"
   printf "Please fix this problem and exit this shell.\n\n"
}
no_mount()
{
   printf "Could not mount device %s\n" $1
   printf "Sleeping forever. Please reboot and fix the kernel command line.\n\n"
   printf "Maybe the device is formatted with an unsupported file system?\n\n"
   printf "Or maybe filesystem type autodetection went wrong, in which case\n"
   printf "you should add the rootfstype=... parameter to the kernel command line.\n\n"
   printf "Available partitions:\n"
}
do_mount_root()
{
   mkdir /.root
   [ -n "$rootflags" ] &amp;&amp; rootflags="$rootflags,"
   rootflags="$rootflags$ro"
   case "$root" in
      /dev/* ) device=$root ;;
      UUID=* ) eval $root; device="/dev/disk/by-uuid/$UUID"  ;;
      LABEL=*) eval $root; device="/dev/disk/by-label/$LABEL" ;;
      ""     ) echo "No root device specified." ; problem    ;;
   esac
   while [ ! -b "$device" ] ; do
       no_device $device
       problem
   done
   if ! mount -n -t "$rootfstype" -o "$rootflags" "$device" /.root ; then
       no_mount $device
       cat /proc/partitions
       while true ; do sleep 10000 ; done
   else
       echo "Successfully mounted device $root"
   fi
}
init=/sbin/init
root=
rootdelay=
rootfstype=auto
ro="ro"
rootflags=
device=
mount -n -t devtmpfs devtmpfs /dev
mount -n -t proc     proc     /proc
mount -n -t sysfs    sysfs    /sys
mount -n -t tmpfs    tmpfs    /run
read -r cmdline &lt; /proc/cmdline
for param in $cmdline ; do
  case $param in
    init=*      ) init=${param#init=}             ;;
    root=*      ) root=${param#root=}             ;;
    rootdelay=* ) rootdelay=${param#rootdelay=}   ;;
    rootfstype=*) rootfstype=${param#rootfstype=} ;;
    rootflags=* ) rootflags=${param#rootflags=}   ;;
    ro          ) ro="ro"                         ;;
    rw          ) ro="rw"                         ;;
  esac
done
# udevd location depends on version
if [ -x /sbin/udevd ]; then
  UDEV_PATH=/sbin
else
  UDEV_PATH=/lib/udev
fi
${UDEV_PATH}/udevd --daemon --resolve-names=never
udevadm trigger
udevadm settle
if [ -f /etc/mdadm.conf ] ; then mdadm -As                       ; fi
if [ -x /sbin/vgchange  ] ; then /sbin/vgchange -a y &gt; /dev/null ; fi
if [ -n "$rootdelay"    ] ; then sleep "$rootdelay"              ; fi
do_mount_root
killall -w ${UDEV_PATH}/udevd
exec switch_root /.root "$init" "$@"
EOF</userinput>
</screen>
  </sect2>
  <sect2 id="initramfs-install">
    <title>Utilisation d'un initramfs</title>
    <bridgehead renderas="sect3">Dépendance d'exécution requise</bridgehead>
    <para role="required">
      <xref linkend="cpio"/>
    </para>
    <para condition="html" role="usernotes">Notes d'utilisateur:
      <ulink url="&blfs-wiki;/initramfs"/>
    </para>
    <para>Pour construire un initramfs, lancer ce qui suit en tant qu'utilisateur <systemitem
    class="username">root</systemitem>&nbsp;:</para>
    
<screen>
<userinput>mkinitramfs [KERNEL VERSION]</userinput>
</screen>
    <para>L'argument facultatif est le répertoire ou les modules appropriés du noyau sont enregistrés.
    Cela peut être un sous-répertoire de <filename
    class='directory'> /lib/modules</filename>.  Si aucun modules n'est spécifié,
    alors l'initramfs est appelé <emphasis>initrd.img-no-kmods</emphasis>.  Si une version du noyau
    est précisé, le fichier initrd est appelé
    <emphasis>initrd.img-$KERNEL_VERSION</emphasis> et est seulement destiné pour le noyau
    spécifiquement précisé. Les fichiers de sortie seront enregistré dans le répertoire courant.</para>
    <para>Après avoir généré le fichier initrd, copiez le dans le répertoire <filename
    class='directory'>/boot</filename>.</para>
    <para>Maintenant éditez <filename>/boot/grub/grub.cfg</filename> et ajoutez une nouvelle entrée
    dans le menu. En dessous, plusieurs exemples sont présentés.</para>
     
<screen>
<userinput># Generic initramfs and root fs identified by UUID
menuentry "LFS Dev (LFS-7.0-Feb14) initrd, Linux 3.0.4"
{
  linux  /vmlinuz-3.0.4-lfs-20120214 root=UUID=54b934a9-302d-415e-ac11-4988408eb0a8 ro
  initrd /initrd.img-no-kmods
}</userinput>
</screen>
     
<screen>
<userinput># Generic initramfs and root fs on LVM partition
menuentry "LFS Dev (LFS-7.0-Feb18) initrd lvm, Linux 3.0.4"
{
  linux  /vmlinuz-3.0.4-lfs-20120218 root=/dev/mapper/myroot ro
  initrd /initrd.img-no-kmods
}</userinput>
</screen>
     
<screen>
<userinput># Specific initramfs and root fs identified by LABEL
menuentry "LFS Dev (LFS-7.1-Feb20) initrd label, Linux 3.2.6"
{
  linux  /vmlinuz-3.2.6-lfs71-120220 root=LABEL=lfs71 ro
  initrd /initrd.img-3.2.6-lfs71-120220
}</userinput>
</screen>
    <para>Finalement, redémarrez le système et sélectionnez le système désiré.</para>
  </sect2>
</sect1>
