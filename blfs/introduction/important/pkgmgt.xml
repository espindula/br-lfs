<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
   "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../../general.ent">
  %general-entities;
]>

<sect1 id="intro-important-pkgmgt">
<sect1info>
<othername>$LastChangedBy: bdubbs $</othername>
<date>$Date: 2005-06-21 20:04:59 $</date>
</sect1info>
<?dbhtml filename="pkgmgt.html"?>
<title>Gestion de paquetages</title>

<para>La gestion de paquetages est un ajout souvent demandé au livre
<acronym>LFS</acronym>. Un gestionnaire de paquetages permet de conserver 
une trace des fichiers installés, simplifiant ainsi leur suppression ou
leur mise à jour. Avant tout, NON &mdash; cette section ne parle pas d'un
gestionnaire de paquetages particulier, elle n'en recommande pas non plus. Elle
fait un tour des techniques les plus populaires pour indiquer comment elles
fonctionnent. Le gestionnaire parfait de paquetages pourrait faire partie de
ces techniques ou pourrait être une combinaison d'une ou plusieurs techniques.
Cette section mentionne brièvement les problèmes pouvant survenir lors de la
mise à jour des paquetages.</para>

<para>Les raisons de l'absence d'un gestionnaire de paquetages sont mentionnées
dans <acronym>LFS</acronym> ou <acronym>BLFS</acronym>&nbsp;:</para>

<itemizedlist>
<listitem><para>S'occuper de la gestion de paquetages est en dehors des buts de
ces livres &mdash; Apprendre comment un système Linux est construit.</para></listitem>
<listitem><para>Il existe de nombreuses solutions pour la gestion de paquetages,
chacune ayant des forces et ses faiblesses. En inclure une qui satisfait tout
le monde est difficile.</para></listitem>
</itemizedlist>

<para>Des astuces ont été écrites sur le thème de la gestion de paquetages.
Visitez le <ulink url="http://www.linuxfromscratch.org/hints/">sous-projet des
astuces</ulink> pour trouver celui qui satisfait vos besoins.</para>


<sect2>
<title>Problèmes de mise à jour</title>

<para>Un gestionnaire de paquetages facilite la mise à jour des nouvelles
versions au moment de leur sortie. Généralement, les instructions dans les
livres <acronym>LFS</acronym> et <acronym>BLFS</acronym> peuvent être utilisées
pour les nouvelles versions. Voici quelques points à connaître pour une mise à
jour de paquetages, spécifiquement sur un système opérationnel.</para>

<itemizedlist>
<listitem><para>Si un des outils de l'ensemble des outils
(glibc, gcc, binutils) doit être mise à jour avec une nouvelle version mineure,
il est plus sûr de reconstruire <acronym>LFS</acronym>. Bien que vous
<emphasis>pourriez</emphasis> être capable de ne pas reconstruire tous les
paquetages dans leur ordre de dépendances. Nous ne vous le recommandons pas.
Par exemple, si glibc-2.2.x a besoin d'être mis à jour vers glibc-2.3.x, il est
préférable de reconstruire. Pour les mises à jour encore plus mineures, une
simple réinstallation fonctionne généralement mais cela n'est pas garanti. Par
exemple, mettre à jour de glibc-2.3.1 à glibc-2.3.2 ne causera aucun problème.
</para></listitem>
<listitem><para>Si un paquetage contenant une bibliothèque partagée est mise à 
jour et si le nom de cette dernière est modifié, alors les paquetages liées
dynamiquement à la bibliothèque devront être recompilés pour être liés à la
nouvelle bibliothèque. (Notez qu'il n'y a aucun corrélation entre la version
du paquetage et le nom de la bibliothèque.) Par exemple, considérez un paquetage
foo-1.2.3 qui installe une bibliothèque partagée de nom
<filename>libfoo.so.1</filename>. Disons que vous mettez à jour le paquetage 
avec une nouvelle version foo-1.2.4 qui installe une bibliothèque partagée de
nom <filename>libfoo.so.2</filename>. Dans ce cas, tous les paquetages liés
dynamiquement à <filename>libfoo.so.1</filename> doivent être recompilés pour
être liés à <filename>libfoo.so.2</filename>. Notez que vous ne devez pas
supprimer les anciennes bibliothèques jusqu'à ce que les paquetages indépendants
soient recompilés.</para></listitem>
<listitem><para>Si vous mettez à jour un système fonctionnel, soyez attentif
aux commandes utilisant <command>cp</command> au lieu de
<command>install</command> pour installer des fichiers. La dernière commande
est généralement plus sain si l'exécutable ou la bibliothèque est toujours
chargé en mémoire.</para></listitem>
</itemizedlist>

</sect2>


<sect2>
<title>Techniques de gestion de paquetages</title>

<para>Ce qui suit est une liste de techniques habituelles de gestion de
paquetages. Avant de prendre une décision sur un gestionnaire de paquetages,
faites une recherche sur les différentes techniques et notamment leurs
faiblesses.</para>

<sect3>
<title>Tout est dans ma tête&nbsp;!</title>

<para>Oui, c'est une technique de gestion de paquetages. Certains n'éprouvent
pas le besoin d'un gestionnaire de paquetages parce qu'ils connaissent très
bien les paquetages et connaissent les fichiers installés par chaque paquetage.
Certains utilisateurs n'en ont pas besoin parce qu'ils plannifient la
reconstruction entière du système lorsqu'un paquetage est
modifié.</para>

</sect3>

<sect3>
<title>Installer dans des répertoires séparés</title>

<para>C'est une gestion des paquetages tellement simple qu'elle ne nécessite
aucun paquetage supplémentaire pour gérer les installations. Chaque paquetage
est installé dans un répertoire séparé. Par exemple, le paquetage foo-1.1 est
installé dans <filename>/usr/pkg/foo-1.1</filename> et un lien symbolique est
créé entre <filename>/usr/pkg/foo</filename> et
<filename>/usr/pkg/foo-1.1</filename>. Lors de l'installation de la
nouvelle version foo-1.2, il est installé dans
<filename>/usr/pkg/foo-1.2</filename> et l'ancien lien symbolique est remplacé
par un lien symbolique vers les nouvelle version.</para>

<para>Les variables d'environnement telles que ceux mentionnées
dans <xref linkend="intro-important-beyond"/> ont besoin d'être étendues pour
inclure <filename>/usr/pkg/foo</filename>. Pour plus que quelques paquetages,
ce schéma devient ingérable.</para>

</sect3>

<sect3>
<title>Gestion de paquetage par lien symbolique</title>

<para>C'est une variante de la technique précédente. Chaque paquetage est
installé de façon similaire au schéma précédent. Mais au lieu de réaliser le
lien symbolique, chaque fichier est lié symbolique à son équivalent dans la
hiérarchie <filename>/usr</filename>. Ceci supprime le besoin d'étendre les
variables d'environnement. Bien que les liens symboliques peuvent être créés
par l'utilisateur, pour automatiser la création, certains gestionnaires de
paquetages ont été écrit avec cette approche. Parmi les plus populaires se
trouvent Stow, Epkg, Graft et Depot.</para>

<para>L'installation doit être faussée, de façon à ce que chaque paquetage
pense qu'il est installé dans <filename class="directory">/usr</filename> alors
qu'en réalité il est installé dans la hiérarchie <filename
class="directory">/usr/pkg</filename>. Installer de cette manière n'est
généralement pas une tâche triviale. Par exemple, considérez que vous installez
un paquetage libfoo-1.1. Les instructions suivantes pourraient ne pas
installer correctement le paquetage&nbsp;:</para>

<screen><userinput><command>./configure --prefix=/usr/pkg/libfoo/1.1
make
make install</command></userinput></screen>

<para>L'installation fonctionnera mais les paquetages dépendants pourraient ne
pas lier libfoo comme vous vous y attenderiez. Si vous compilez un paquetage qui
se lie à libfoo, vous pouvez noter qu'il est lié à
<filename>/usr/pkg/libfoo/1.1/lib/libfoo.so.1</filename> au lieu de
<filename>/usr/lib/libfoo.so.1</filename> comme vous vous y attendez. La bonne
approche est d'utiliser la stratégie <envar>DESTDIR</envar> pour fausser
l'installation du paquetage. Cette approche fonctionne ainsi&nbsp;:</para>

<screen><userinput><command>./configure --prefix=/usr
make
make DESTDIR=/usr/pkg/libfoo/1.1 install</command></userinput></screen>

<para>La plupart des paquetages supportent cette approche mais elle pose
problème à certains. Pour les paquetages non compatibles, vous pouvez soit les
installer manuellement soit trouver plus simple d'instller les paquetages
problèmatiques dans <filename>/opt</filename>.</para>

</sect3>

<sect3>
<title>Basé sur le temps</title>

<para>Avec cette technique, un fichier est balisé avec l'heure avant 
l'installation du paquetage. Après l'installation, une simple utilisation de la
commande <command>find</command> avec les options appropriées peut générer une
trace de tous les fichiers installés après que le fichier temps ne soit créé.
install-log est un gestionnaire de paquetages écrit avec cette approche.</para>

<para>Bien que ce schéma a l'avantage d'être simple, il a deux inconvénients.
Si à l'installation, les fichiers sont installés sans balise de temps autre
que l'heure actuelle, ces fichiers ne seront pas suivis par le gestionnaire de
paquetages. De plus, ce schéma peut seulement être utilisé lorsqu'un
seul paquetage est installé à la fois. Les traces ne sont pas fiables si deux
paquetages sont installés dans deux consoles différentes.</para>

</sect3>

<sect3>
<title>Basé sur LD_PRELOAD</title>

<para>Avec cette approche, une bibliothèque est préchargée avant
l'installation. Lors de cette dernière, cette bibliothèque trace les paquetages
en cours d'installation en s'attachant eux-même aux différents exécutables
comme <command>cp</command>, <command>install</command>, <command>mv</command>
et trace les appels système qui modifient le système de fichiers. Pour que
cette approche fonctionne, tous les exécutables ont besoin d'être liés
dynamiquement sans bit suid ou sgid. Le préchargement de la bibliothèque
pourrait causer quelques effets de bord involontaires lors de
l'installation. Du coup, réalisez quelques tests pour vous assurer que le
gestionnaire de paquetages ne casse rien et trace bien tous les fichiers
appropriés.</para>

</sect3>

<sect3>
<title>Créer des archives de paquetages</title>

<para>Dans ce schéma, l'installation d'un paquetage est faussé dans un
répertoire séparé comme décrit plus haut. Après l'installation, une
archive du paquetage est créée en utilisant les fichiers installés. L'archive
est ensuite utilisée pour installer le paquetage soit sur la machine locale
soit même sur d'autres machines.</para>

<para>Cette approche est utilisée par la plupart des gestionnaires de paquetages
trouvés dans les distributions commerciales. Les exemples de gestionnaires
suivant cette approche sont RPM, pkg-utils, Debian's apt et le système de
portage de Gentoo.</para>

</sect3>

<sect3>
<title>Gestion basée sur les utilisateurs</title>

<para>Ce schéma, unique à <acronym>LFS</acronym>, a été décrit par
Matthias Benkmann et est disponible sur le <ulink
url="http://www.linuxfromscratch.org/hints/">projet des astuces</ulink>.
Dans ce schéma, chaque paquetage est installé en tant qu'utilisateur séparé dans
les emplacements standards. Les fichiers appartenant à un paquetage sont
facilement identifiés grâce à l'identifiant de l'utilisateur. Les
fonctionnalités et avantages de cette approche sont trop complexes pour les
décrire dans cette section. Pour plus de détails, voir l'astuce sur <ulink
url="http://www.linuxfromscratch.org/hints/downloads/files/more_control_and_pkg_
man.txt"/>.</para>

</sect3>

</sect2>

</sect1>
