<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../../general.ent">
  %general-entities;
]>
<sect1 id="unpacking">
  <?dbhtml filename="notes-on-building.html"?>
  <sect1info>
    <othername>$LastChangedBy&nbsp;: randy $</othername>
    <date>$Date&nbsp;: 2012-12-19 20:57:20 +0100 (Wed, 19 Dec 2012) $</date>
  </sect1info>
  <title>Remarques sur la construction de logiciels</title>
  <para>Il se peut que les gens qui ont construit un système LFS connaissent les
  principes généraux du téléchargement et du déballage de logiciel. Certaines de ces
  informations sont répétées ici pour les nouveaux qui construisent
  leurs propres logiciels.</para>
  <para>Chaque groupe d'instructions d'installation contient une adresse Web
  depuis laquelle vous pouvez télécharger le paquet. Les correctifs; cependant, sont enregistrés
  sur les serveurs LFS et sont disponibles via HTTP. Ils sont référencés comme
  nécessaires dans les instructions d'installation.</para>
  <para>Si vous pouvez mettre les fichiers sources là où vous voulez, nous
  supposons que vous avez déballé le paquet et êtes allé dans le répertoire créé
  par le processus de déballage (le répertoire de 'construction'). Nous
  supposons aussi que vous avez décompressé les correctifs requis et qu'ils sont
  dans dans le répertoire de niveau immédiatement supérieur au répertoire de
  'construction'.</para>
  <para>Nous ne saurions que trop vous recommander fortement de démarrer à partir
  d'une <emphasis>arborescence de sources propre</emphasis> à chaque fois.
  Cela veut dire que si vous avez eu une erreur lors de la configuration ou de
  la compilation, il est généralement préférable d'effacer l'arborescence des 
  sources et de la redéballer <emphasis>avant</emphasis> de réessayer. Cela
  ne s'applique évidemment pas si vous êtes un utilisateur avancé habitué à
  modifier les <filename>Makefile</filename>s et le code C, mais si vous avez
  un doute, commencez à partir d'une arborescence propre.</para>
  <sect2>
    <title>Construction de logiciels en tant qu'utilisateur non privilégié (non root)</title>
    <para>La règle d'or de l'administration d'un système Unix est de n'utiliser
    vos super-pouvoirs que si nécessaire. D'où la recommandation de BLFS de construire
    les logiciels en tant qu'utilisateur non privilégié et de ne devenir
    l'utilisateur <systemitem class='username'>root</systemitem> que
    lors de l'installation du logiciel. On suit cette philosophie dans tous les
    paquets du livre. Sauf spécifications contraires, toutes les instructions devraient
    être exécutées en tant qu'utilisateur non privilégié. Le livre vous
    conseillera sur les instructions qui ont besoin des privilèges
    <systemitem class='username'>root</systemitem>.</para>
  </sect2>
  <sect2>
    <title>Déballer le logiciel</title>
    <para>S'il y a un fichier compressé au format <filename class='extension'>.tar</filename>,
    on le déballe en utilisant une des commandes suivantes&nbsp;:</para>
<screen>
<userinput>tar -xvf filename.tar.gz
tar -xvf filename.tgz
tar -xvf filename.tar.Z
tar -xvf filename.tar.bz2</userinput>
</screen>
    <note>
      <para>Vous pouvez ne pas utiliser le paramètre <option>v</option> dans
      les commandes décrites ci-dessus et ci-dessous si vous supprimez le listage
      verbeux de tous les fichiers de l'archive au fur et à mesure qu'ils sont
      extraits. Cela peut aider à accélérer l'extraction mais aussi rendre
      la compréhension des erreurs produites pendant l'extraction moins évidentes.</para>
    </note>
    <para>Vous pouvez utiliser aussi une méthode légèrement différente&nbsp;:</para>
<screen>
<userinput>bzcat filename.tar.bz2 | tar -xv</userinput>
</screen>
    <para>Enfin, vous avez parfois besoin de déballer des correctifs 
    qui ne sont généralement pas au format <filename class='extension'>.tar</filename>.
    La meilleure manière de faire cela est de copier le chemin du fichier dans 
    le parent du répertoire de 'construction' puis d'exécuter une des commandes
    suivantes selon que le fichier est un
    <filename class='extension'>.gz</filename> ou un <filename
    class='extension'>.bz2</filename>&nbsp;:</para>
<screen>
<userinput>gunzip -v patchname.gz
bunzip2 -v patchname.bz2</userinput>
</screen>
  </sect2>
  <sect2>
    <title>Vérifier l'intégrité des fichiers en utilisant 'md5sum'</title>
    <para>En général, pour vérifier que le fichier téléchargé est authentique
    et complet, de nombreux mainteneurs de paquets distribuent aussi des sommes
    md5 des fichiers. Pour vérifier la somme md5 des fichiers téléchargés,
    téléchargez à la fois le fichier et le fichier md5sum correspondant dans le
    même répertoire (de préférence à partir d'emplacements différents en ligne)
    et (en supposant que <filename>file.md5sum</filename> est le fichier
    md5sum téléchargé), lancez la commande suivante&nbsp;:</para>
<screen>
<userinput>md5sum -c file.md5sum</userinput>
</screen>
    <para>S'il y a une erreur, elle sera signalée. Remarquez que le livre BLFS
    comprend les sommes md5 de tous les fichiers sources. Pour utiliser les
    sommes md5 fournies par BLFS, vous pouvez créer un
    <filename>file.md5sum</filename> (mettez les données md5sum et le nom exact
    du fichier téléchargé sur la même ligne d'un fichier, séparés par un espace
    blanc), et lancez la commande montrée ci-dessus. Sinon, lancez simplement la
    commande décrite ci-dessus et comparez la sortie avec les données de somme
    md5 inscrites dans le livre BLFS.</para>
<screen>
<userinput>md5sum <replaceable>&lt;name_of_downloaded_file&gt;</replaceable></userinput>
</screen>
  </sect2>
  <sect2>
    <title>Créer des fichiers journaux pendant l'installation</title>
    <para>Pour les gros paquets, il est commode de créer des fichiers journaux
    plutôt que de dévisager l'écran en espérant récupérer une erreur ou un
    avertissement particulier. Les fichiers journaux sont aussi utiles pour
    déboguer et garder des enregistrements. La commande suivante vous permet de
    créer un journal d'installation. Remplacez 
    <replaceable>&lt;commande&gt;</replaceable> par la commande que vous
    cherchez à exécuter.</para>
<screen>
<userinput>( <replaceable>&lt;command&gt;</replaceable> 2&gt;&amp;1 | tee compile.log &amp;&amp; exit $PIPESTATUS )</userinput>
</screen>
    <para><option>2&gt;&amp;1</option> redirige les messages d'erreur vers
    le même endroit que la sortie standard. La commande
    <command>tee</command> vous permet de voir la sortie en journalisant les
    résultats dans un fichier. Les parenthèses autour de la commande exécutent
    toute la commande dans un sous-shell et, enfin, la commande
    <command>exit $PIPESTATUS</command> s'assure que c'est bien le résultat de
    <replaceable>&lt;commande&gt;</replaceable> qui est retourné 
    et pas le résultat de la commande <command>tee</command>.</para>
  </sect2>
  <sect2 id="parallel-builds" xreflabel="Using Multiple Processors">
    <title>Utilisation de processeurs multiples</title>
    <para>Pour la plupart des systèmes modernes avec des processeurs multiples ( ou coeurs) le temps
     de compilation pour un paquet peut être réduit en effectuant une "construction parallèle" soit en initialisant
     une variable d'environnement ou en disant au programme make combien de processeurs sont disponibles. Par
     exemple, un Core2Duo peut supporter deux processus simultanées avec:
     </para>
    
<screen>
<userinput>export MAKEFLAGS='-j2'</userinput>
</screen>
    <para>or just building with:</para>
    
<screen>
<userinput>make -j2</userinput>
</screen>
    <para>Générallement le nome de processus ne doit pas dépasser le nombre de coeurs supportés par le CPU. Pour
     lister les processeurs de votre système, tapez : <userinput>grep processor /proc/cpuinfo</userinput>.
    </para>
    <para>Dans certains cas, l'utilisation de processeurs multiples peut amener dans une sorte de "course" ou le succès
     de la construction dépend de l'ordre des commandes lancé par le programme
    <command>make</command>. Par exemple, si un exécutable demande un fichier A et un fichier B, en essayant de lier
     le programme avant qu'un des composants dépendants ne soit disponible, aboutira à un échec.
     Cela est possible car les développeurs n'ont pas proprement désigné tous les prérequis utiles pour accomplir une
     étape du Makefile.
    </para>
    <para>Si cela arrive, la meilleure chose à faire est revenir à la construction avec un seul processeur.
     En ajoutant "-j1" à une commande make, cela écrasera l'initialisation similaire dans une variable
     d'environnement MAKEFLAGS.</para>
  </sect2>
  <sect2 id="automating-builds" xreflabel="Automated Building Procedures">
    <title>Procédures de construction automatique</title>
    <para>Il y a des fois où automatiser la construction d'un paquet peut
    s'avérer utile. Chacun a ses raisons de vouloir automatiser la construction,
    et chacun le fait par ses propres moyens. Soit en créant des
    <filename>Makefile</filename>s, des scripts <application>Bash</application>,
    des scripts <application>Perl</application> ou simplement une liste de
    commandes utilisées qui sont copier-coller, sont des méthodes que vous pouvez
    utiliser pour automatiser la construction de paquets BLFS. Détailler
    et donner des exemples sur les nombreuses manières d'automatiser la construction
    de paquets va au-delà des objectifs de cette section. Cette section vous
    présentera l'utilisation de la redirection de fichiers et de la commande
    <command>yes</command> pour vous donner des idées sur la façon
    d'automatiser vos constructions.</para>
    <bridgehead renderas="sect3">Redirection de fichier pour automatiser l'entrée</bridgehead>
    <para>Il y aura des moments, pendant votre aventure BLFS, où vous tomberez 
    sur un paquet ayant une invite de commande vous demandant des informations.
    Ces informations peuvent être des détails de configuration, un chemin
    de répertoire ou une réponse à un accord de licence. Il peut être un challenge
    d'automatiser la construction de ce paquet. On vous demandera occasionnellement
    des informations via une série de questions. Une méthode pour automatiser
    ce type de scénario est de mettre les réponses désirées dans un fichier et
    d'utiliser la redirection pour que le programme utilise les données du fichier
    comme réponses aux questions.</para>
    <para>La construction du paquet <application>CUPS</application> est un bon
    exemple de la façon de rediriger un fichier comme entrée aux invites, cela 
    peut vous aider à automatiser la construction. Si vous lancez la suite de
    test, on vous demande de répondre à une série de questions concernant
    le type de test à exécuter et si vous avez un programme auxiliaire que le 
    test peut utiliser. Vous pouvez créer un fichier avec vos réponses, une par
    ligne, et utiliser une commande ressemblant à celle indiquée ci-dessous
    pour automatiser l'exécution de la suite de tests&nbsp;:</para>
<screen>
<userinput>make check &lt; ../cups-1.1.23-testsuite_parms</userinput>
</screen>
    <para>Cela fait que la suite de tests utilise les réponses du fichier comme
    entrée pour les questions. Vous pouvez finir par faire des essais et des 
    erreurs pour déterminer le format exact de votre fichier d'entrée pour
    certaines choses, mais une fois expérimenté et documenté, vous pouvez
    utiliser cela pour automatiser la construction du paquet.</para>
    <bridgehead renderas="sect3">Utiliser <command>yes</command> pour automatiser
    l'entrée</bridgehead>
    <para>Vous n'aurez parfois besoin que de fournir une réponse ou une même
    réponse à de nombreuses invites. Dans ces cas-là, la commande
    <command>yes</command> fonctionne vraiment bien.
    On peut utiliser la commande <command>yes</command> pour fournir une réponse
    (la même) à une ou plusieurs questions. On peut l'utiliser pour simuler
    un simple appui sur la touche <keycap>Entrée</keycap>, l'entrée de la touche
    <keycap>Y</keycap> ou l'entrée d'une chaîne de texte. La manière la plus facile de
    montrer son utilisation est peut-être de prendre un exemple.</para>
    <para>Créez tout d'abord un petit script <application>Bash</application> en
    entrant les commandes suivantes&nbsp;:</para>
<screen>
<userinput>cat &gt; blfs-yes-test1 &lt;&lt; "EOF"
<literal>#!/bin/bash
echo -n -e "\n\nPlease type something (or nothing) and press Enter -
-->
 "
read A_STRING
if test "$A_STRING" = ""; then A_STRING="Just the Enter key was pressed"
else A_STRING="You entered '$A_STRING'"
fi
echo -e "\n\n$A_STRING\n\n"</literal>
EOF
chmod 755 blfs-yes-test1</userinput>
</screen>
    <para>Maintenant, lancez le script en lançant <command>./blfs-yes-test1</command>
    depuis la ligne de commande. Il attendra une réponse, qui peut être n'importe
    quoi (ou rien) suivi de la touche <keycap>Entrée</keycap>. Après avoir
    entré quelque chose, le résultat sera affiché à l'écran. Utilisez maintenant
    la commande <command>yes</command> pour automatiser l'entrée d'une
    réponse&nbsp;:</para>
<screen>
<userinput>yes | ./blfs-yes-test1</userinput>
</screen>
    <para>Remarquez que la redirection (le piping) de <command>yes</command> 
    en lui-même vers le script aboutit à ce que <keycap>y</keycap> est passé au
    script. Essayez-la maintenant avec une chaine de texte&nbsp;:</para>
<screen>
<userinput>yes 'This is some text' | ./blfs-yes-test1</userinput>
</screen>
    <para>La chaîne exacte était utilisée comme réponse au script. Enfin,
    essayez-la en utilisant une chaîne vide (null)&nbsp;:</para>
<screen>
<userinput>yes '' | ./blfs-yes-test1</userinput>
</screen>
    <para>Remarquez que cela aboutit à ne passer au script que l'appui sur la touche 
    <keycap>Entrée</keycap>. C'est utile parfois quand la réponse par défaut à
    l'invite est suffisante. Cette syntaxe est utilisée dans les instructions
    de <xref linkend="net-tools-automate-example"/> pour accepter tous les
    réglages par défaut à toutes les invites lors de l'étape de configuration.
    Vous pouvez maintenant supprimer le script de test si vous le désirez.</para>
    <bridgehead renderas="sect3">Redirection de fichiers pour automatiser la
    sortie</bridgehead>
    <para>Pour automatiser la construction de certains paquets, surtout ceux
    qui vous demandent de lire un accord de licence page après page, il faut
    utiliser une méthode qui évite de devoir appuyer sur une touche pour
    afficher chaque page. On peut utiliser la redirection de sortie vers un fichier
    dans ce cas-là pour vous aider à automatiser. La section précédente de
    cette page a visé à créer des fichiers journaux de la sortie de la construction.
    La méthode de redirection qui y est décrite utilisait la commande
    <command>tee</command> pour rediriger la sortie tout en affichant aussi
    la sortie à l'écran. D'où le fait qu'on ne verra la sortie que dans un 
    fichier.</para>
    <para>De nouveau, la manière la plus facile de montrer la technique est
    de présenter un exemple. Lancez d'abord la commande&nbsp;:</para>
<screen>
<userinput>ls -l /usr/bin | more</userinput>
</screen>
    <para>Bien entendu, vous devrez voir la sortie page par page car on a
    utilisé le filtre <command>more</command>. Essayez maintenant la même
    commande, mais en redirigeant cette fois la sortie vers un fichier. Le
    fichier spécial <filename>/dev/null</filename> peut être utilisé à la place
    du fichier indiqué, mais vous n'aurez pas de fichier journal à examiner&nbsp;:</para>
<screen>
<userinput>ls -l /usr/bin | more &gt; redirect_test.log 2&gt;&amp;1</userinput>
</screen>
    <para>Remarquez que cette fois, la commande est immédiatement revenue à
    l'invite du shell sans devoir parcourir la sortie page par page. Vous pouvez
    supprimer maintenant le fichier journal.</para>
    <para>Le dernier exemple utilisera la commande <command>yes</command> 
    associée à la redirection de sortie pour éviter de naviguer page par page dans
    la sortie, puis de fournir un <keycap>y</keycap> à l'invite. Cette technique
    pour être utilisée dans les cas où vous devriez, sans elle, naviguer page
    par page dans la sortie d'un fichier (tel qu'un accord de licence), puis
    répondre à la question <quote>Acceptez-vous ce qui précède&nbsp;?</quote>. 
    Pour cet exemple, on a besoin d'un autre petit script <application>Bash</application>&nbsp;:</para>
<screen>
<userinput>cat &gt; blfs-yes-test2 &lt;&lt; "EOF"
<literal>#!/bin/bash
ls -l /usr/bin | more
echo -n -e "\n\nDid you enjoy reading this? (y,n) "
read A_STRING
if test "$A_STRING" = "y"; then A_STRING="You entered the 'y' key"
else A_STRING="You did NOT enter the 'y' key"
fi
echo -e "\n\n$A_STRING\n\n"</literal>
EOF
chmod 755 blfs-yes-test2</userinput>
</screen>
    <para>On peut utiliser ce script pour simuler un programme qui demande que vous
    lisiez un accord de licence et que vous acceptiez le contrat avant que le
    programme n'installe quoique ce soit. Lancez d'abord le script sans
    techniques d'automatisation en exécutant 
    <command>./blfs-yes-test2</command>.</para>
    <para>Maintenant lancez la commande suivante qui utilise les techniques
    d'automatisation, rendant l'utilisation convenable dans un script de construction
    automatisé&nbsp;:</para>
<screen>
<userinput>yes | ./blfs-yes-test2 &gt; blfs-yes-test2.log 2&gt;&amp;1</userinput>
</screen>
    <para>Si vous le désirez, lancez <command>tail blfs-yes-test2.log</command> pour
    voir la fin de la sortie paginée et la confirmation que <keycap>y</keycap>
    a été passé au script. Une fois que cela marche comme cela devrait, vous pouvez
    supprimer le script et le fichier journal.</para>
    <para>Enfin, gardez à l'esprit qu'il y a de nombreux moyens d'automatiser
    et/ou de scripter les commandes de construction. Il n'y a pas
    <quote>une seule</quote> manière de procéder. Votre imagination est
    la seule limite.</para>
  </sect2>
  <sect2>
    <title>Dépendances</title>
    <para>Pour chaque paquet décrit, BLFS liste les dépendances connues. Elles
    sont listées sous plusieurs en-têtes, dont la signification est la suivante&nbsp;:</para>
    <itemizedlist>
      <listitem>
        <para><emphasis>Requis</emphasis> signifie que le paquet cible ne peut
        pas se construire correctement sans avoir d'abord installé la 
        dépendance.</para>
      </listitem>
      <listitem>
        <para><emphasis>Recommandées</emphasis> signifie que BLFS suggère
        fortement d'installer préalablement ce paquet pour une construction propre
        et sans problème, ni pendant le processus de construction ni au moment
        de l'exécution. Les instructions dans le livre considèrent que ses paquets
        sont installés. Des modifications ou contournements peuvent être requis si
        ces paquets ne sont pas installés.
      </para>
      </listitem>
      <listitem>
        <para><emphasis>Facultatives</emphasis> signifie que ce paquet pourrait
        être installé pour ajouter des fonctions. BLFS décrira souvent la
        dépendance pour expliquer la fonctionnalité supplémentaire résultante.</para>
      </listitem>
    </itemizedlist>
  </sect2>
  
  <sect2 id="package_updates">
    <title>Utilisation de paquets sources plus récents</title>
    <para>Occasionnellement, dans le livre, vous pourrez être dans la situation ou un
      paquet ne se construit pas ou ne fonctionne pas correctement. Bien que les
      éditeurs tentent de faire en sorte que chaque paquet dans le livre se construise
      et fonctionne correctement, parfois un paquet a été oublié ou n'a pas été testé 
      avec cette version particulière de BLFS.</para>
    <para>Si vous découvrez un paquet qui ne se construit pas ou ne fonctionne pas 
      correctement, vous pouvez regarder s'il s'agit de la version la plus récente 
      du paquet. Typiquement, cela signifie que vous irez sur le site web du mainteneur
      et téléchargerez l'archive la plus récente et tenterez de construire le paquet.
      Si vous ne pouvez pas déterminer le site web du mainteneur en regardant l'URL
      de chargement, utilisez Google et cherchez le nom du paquet. Par exemple, dans
      la barre de recherche de Google tapez: 'package_name download' (sans les guillemets)
      ou quelque chose de similaire. Parfois en tapant&nbsp;: 'package_name home page'
      vous trouverez le site web du mainteneur.</para>
  </sect2>
  <sect2 id="stripping">
    <title>Nettoyage une fois de plus</title>
    <para>Dans LFS, le nettoyage des symboles de deboguage a été discuté de nombreuses fois.
    Pour la construction des paquets BLFS, il n'y a généralement pas d'instructions qui discute de nouveau
    du nettoyage. Ce n'est probablement pas une bonne idée de nettoyer un
    exécutable ou une bibliothèque tant qu'ils sont utilisés, alors sortir des environnements
    de fenètrage est une bonne idée. Ensuite vous pouvez faire:</para>
    
<screen>
<userinput>find /{,usr/}{bin,lib,sbin} -type f -exec strip --strip-unneeded {} \;</userinput>
</screen>
    <para>Si vous installez des programmes dans d'autres répertoires tels que /opt ou /usr/local,
    vous pouvez vouloir nettoyer les fichiers ici aussi.</para>
    <para>Pour plus d'information sur le nettoyage, regardez <ulink
    url="http://www.technovelty.org/linux/stripping-shared-libraries.html"/>.</para>
  </sect2>
  <sect2 id="libtool">
    <title>Fichiers Libtool</title>
    <para>Un des effets de bord des paquets qui utilisent Autotools, incluant
    libtool, est qu'ils créent beaucoup de fichiers avec une extension .la. Ces
    fichiers ne sont pas utiles dans un environnement LFS. S'il y a des conflits avec des entrées 
    pkconfig, ils peuvent actuellement empêcher des constructions correctes. Vous
    pouvez considérer d'effacer ces fichiers périodiquement:</para>
    
<screen>
<userinput>find /lib /usr/lib -not -path "*Image*" -a -name \*.la -delete</userinput>
</screen>
  <para>La commande suivante efface tous les fichiers .la sauf ceux ayant 
    "Image" dans une partie de leur chemin.  Ces fichiers .la sont utilisés par les programmes de
    ImageMagick. Il peut y avoir d'autres exceptions avec des paquets qui ne sont pas dans BLFS.</para>
    </sect2>
</sect1>
