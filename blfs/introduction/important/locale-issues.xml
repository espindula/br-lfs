<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../../general.ent">
  %general-entities;
]>
<sect1 id="locale-issues" xreflabel="Problèmes liées aux locales">
  <?dbhtml filename="locale-issues.html"?>
  <sect1info>
    <othername>$LastChangedBy&nbsp;: randy $</othername>
    <date>$Date&nbsp;: 2012-12-19 20:57:20 +0100 (Wed, 19 Dec 2012) $</date>
  </sect1info>
  <title>Problèmes liées aux locales</title>
  <para>Cette page contient des informations sur les problèmes liées aux locales.
  Dans les paragraphes suivants, vous trouverez un aperçu générique de ce qui
  peut vous arriver lors de la configuration de votre système pour diverses locales.
  Beaucoup (mais pas tous) des problèmes existants liés aux locales peuvent être
  classés et rangés sous une des en-têtes ci-dessous. Les niveaux de
  sévérité indiqués ci-dessous utilisent les critères suivants&nbsp;:</para>
  <itemizedlist>
    <listitem>
      <para>Critique&nbsp;: Le programme ne remplit pas sa fonction principale.
      Une correction serait ennuyeuse, il vaut mieux chercher un remplaçant.</para>
    </listitem>
    <listitem>
      <para>Haute: Une partie des fonctionnalités fournies par le programme
      n'est pas utilisable. Si cette fonctionnalité est exigée, il vaut mieux
      chercher un remplaçant.</para>
    </listitem>
    <listitem>
      <para>Basse: Le programme fonctionne dans tous les cas d'utilisation
      classiques, mais il manque de certaines fonctionnalités normalement fournies
      par ses équivalents.</para>
    </listitem>
  </itemizedlist>
  <para>Si un moyen spécifique de contournement existe pour un paquet spécifique,
  il apparaîtra sur la page de ce paquet. Pour les informations les plus
  récentes sur les problèmes liés aux locales pour des paquets individuels,
  vérifiez les <ulink url="&blfs-wiki;/BlfsNotes">Notes utilisateur</ulink>
  sur le Wiki de BLFS.</para>
  <sect2 id="locale-not-valid-option"
         xreflabel="Needed Encoding Not a Valid Option">
    <title>L'encodage nécessaire n'est pas une option valide du programme</title>
    <para>Sévérité&nbsp;: Critique</para>
    <para>Certains programmes exigent que l'utilisateur spécifie l'encodage de
    caractères pour leurs données d'entrée et de sortie et ils ne présentent
    qu'un choix limité d'encodages. C'est le cas de l'option <option>-X</option>
    d'<xref linkend="a2ps"/> et de <xref linkend="enscript"/>,
    de l'option <option>-input-charset</option> de
    <ulink url="http://cdrecord.berlios.de/private/cdrecord.html">Cdrtools</ulink> et des encodages offerts pour l'affichage
    du menu de <xref linkend="Links"/>. Si l'encodage désiré n'est pas dans la
    liste, le programme devient en général totalement inutilisable. Pour les
    programmes non interactifs, on peut contourner cela en convertissant le
    document dans un encodage d'entrée supporté avant de le soumettre au
    programme.</para>
    <para>Une solution à ce type de problème consiste à implémenter le
    support nécessaire de l'encodage manquant avec un correctif du programme d'origine
    ou un remplaçant.</para>
  </sect2>
  <sect2 id="locale-assumed-encoding"
         xreflabel="Program Assumes Encoding">
    <title>Le programme suppose l'encodage basé sur la locale de documents
    externes</title>
    <para>Sévérité&nbsp;: Haute pour des documents non textes, basse pour des
    documents textes</para>
    <para>Certains programmes, <xref linkend="nano"/> ou
    <xref linkend="joe"/> par exemple, supposent que les documents sont
    toujours dans l'encodage impliqué par la locale actuelle. Si cette
    supposition peut être valide pour les documents créés par l'utilisateur,
    ce n'est pas sûr pour ceux externes. Quand cette supposition échoue,
    les caractères non ASCII s'affichent mal et le document peut devenir
    illisible.</para>
    <para>Si le document externe est entièrement basé sur du texte, il peut être
    converti dans l'encodage de la locale actuelle en utilisant le programme
    <command>iconv</command>.</para>
    <para>Pour les documents non basés sur du texte, ce n'est pas possible. En fait,
    la supposition du programme peut être complètement invalide pour les
    documents où le système d'exploitation Microsoft Windows a de facto réglé
    les standards. Un exemple de ce problème réside dans les drapeaux ID3v1
    des fichiers MP3 (voir <ulink url="&blfs-wiki;/ID3v1Coding">la page
    ID3v1Coding du Wiki BLFS</ulink> pour plus de détails). Dans ces cas-là,
    la seule solution est de trouver un programme remplaçant qui n'a pas le
    problème (comme un qui vous permettra de spécifier l'encodage supposé du
    document).</para>
    <para>Au sein des paquets BLFS, ce problème s'applique à
    <xref linkend="nano"/>, <xref linkend="joe"/> et à tous les lecteurs
    multimédias, sauf <xref linkend="audacious"/>.</para>
    <para>Un autre problème dans cette catégorie est quand on ne peut pas lire
    les documents qu'on vous a envoyés car leur système d'exploitation a été réglé
    pour gérer différemment les encodages de caractères. Cela peut se produire
    souvent quand l'autre personne utilise Microsoft Windows, qui ne fournit
    qu'un encodage de caractère par pays donné. Par exemple, cela pose des
    problèmes avec les documents TeX encodés en UTF-8 créés sous
    Linux. Sur Windows, la plupart des applications supposeront que ces documents
    ont été créés en utilisant l'encodage 8 bits de Windows par défaut.</para>
    <para>Dans les cas extrêmes, les problèmes de compatibilité d'encodages de
    Windows ne peuvent être résolus qu'en lançant des programmes Windows sous
    <ulink url="http://www.winehq.com/">Wine</ulink>.</para>
  </sect2>
  <sect2 id="locale-wrong-filename-encoding"
         xreflabel="Wrong Filename Encoding">
    <title>Le programme utilise ou crée des noms de fichiers dans un mauvais encodage</title>
    <para>Sévérité&nbsp;: Critique</para>
    <para>Le standard POSIX suppose que l'encodage des noms de fichiers est
    l'encodage impliqué par la catégorie de locale LC_CTYPE actuelle. Ces
    informations sont bien cachées sur la page qui spécifie le comportement des
    programmes <application>Tar</application> et <application>Cpio</application>.
    Certains programmes ne le font pas par défaut (ou n'ont tout simplement pas
    assez d'informations pour le faire). Il en résulte qu'ils créent des
    noms de fichiers qui sont ensuite mal affichés par
    <command>ls</command>, ou ils refusent d'accepter des noms de fichiers
    affichés correctement par <command>ls</command>. Pour la bibliothèque
     <xref linkend="glib2"/>, on peut corriger le problème en réglant la variable
     d'environnement <envar>G_FILENAME_ENCODING</envar> sur la valeur spéciale
    "@locale". Les programmes basés sur <application>Glib2</application> qui
    ne respectent pas cette variable d'environnement sont bogués.</para>
    <para><xref linkend="zip"/>, <xref linkend="unzip"/> ont ce problème car ils
    ont en dur l'encodage accepté du nom de fichier.
    <application>UnZip</application> contient en dur une table de conversion
    entre les encodages CP850 (DOS) et ISO-8859-1 (UNIX) et il utilise cette
    table lorsqu'il extrait des archives créées sous DOS ou
    Microsoft Windows. Cette supposition ne marche cependant que pour les
    États-Unis et pas pour tous ceux qui utilisent une locale UTF-8. Les caractères
    non ASCII seront rognés dans les noms de fichiers extraits.</para>

    <para>La règle générale pour éviter ce type de problème est d'éviter
    d'installer des programmes cassés. Si c'est impossible, vous pouvez
    utiliser l'outil <ulink url="http://j3e.de/linux/convmv/">convmv</ulink>
    en ligne de commande pour corriger les noms de fichiers créés par ces
    programmes cassés, ou rogner volontairement les noms de fichiers existants
    pour satisfaire les présupposés casses de tels programmes.</para>
    <para>Dans d'autres cas, un problème similaire vient de l'importation de
    noms de fichiers d'un système utilisant une locale différente avec un outil
    non conscient de la locale (comme
    <xref linkend="openssh"/>). Pour éviter de rogner les caractères non ASCII
    lors du transfert de fichiers vers un système ayant une locale différente,
    vous pouvez utiliser une des méthodes suivantes&nbsp;:</para>
    <itemizedlist>
      <listitem>
        <para>Transférer malgré tout, réparer les dommages avec
        <command>convmv</command>.</para>
      </listitem>
      <listitem>
        <para>Côté expéditeur, créer une archive tar en passant le paramètre
        <parameter>--format=posix</parameter> à
        <command>tar</command> (cela sera le réglage par défaut dans une
        version à venir de <command>tar</command>).</para>
      </listitem>
      <listitem>
        <para>Envoyer les fichiers en pièces jointes d'un message électronique.
        Les clients de messagerie spécifient l'encodage des noms de fichiers
        joints.</para>
      </listitem>
      <listitem>
        <para>Écrire les fichiers sur un disque amovible formaté avec un
        système de fichiers FAT ou FAT32.</para>
      </listitem>
      <listitem>
        <para>Transférer les fichiers en utilisant Samba.</para>
      </listitem>
      <listitem>
        <para>Transférer les fichiers par FTP en utilisant un serveur
        (cela signifie actuellement seulement wu-ftpd, qui a une mauvaise histoire
        question sécurité) et un client conscients RFC2640 (comme lftp).</para>
      </listitem>
    </itemizedlist>
    <para>Les quatre dernières méthodes fonctionnent car les noms de fichiers
    sont automatiquement convertis de la locale de l'expéditeur en UNICODE et
    stockés ou envoyés sous cette forme. Ils sont alors convertis de façon
    transparente d'UNICODE dans l'encodage de la locale du destinataire.</para>
  </sect2>
  <sect2 id="locale-wrong-multibyte-characters"
         xreflabel="Breaks Multibyte Characters">
    <title>Le programme casse les caractères ou ne compte pas bien les cellules
    de caractères</title>
    <para>Sévérité&nbsp;: Haute ou critique</para>
    <para>De nombreux programmes ont été écrits dans une ère ancienne où les
    locales multioctets n'étaient pas courantes. De tels programmes supposent que
    les types de données C "char", qui sont un des octets, peuvent être utilisés
    pour stocker des caractères uniques. De plus, ils supposent que n'importe
    quelle séquence de caractères est une chaîne valide et que chaque
    caractère occupe une seule cellule de caractère. De telles suppositions
    échouent complètement dans les locales UTF-8. La manifestation visible
    est que le programme tronque les chaînes de façon prématurée (c'est-à-dire
    aux octets 80 au lieu des caractères 80). Les programmes basés sur le
    terminal ne mettent pas bien le curseur à l'écran, ils ne réagissent pas
    à la touche "Effacement" en effaçant un caractère et ils laissent les mauvais
    caractères affiché lors du rafraîchissement de l'écran,
    transformant généralement l'écran en désordre complet.</para>
    <para>La correction de ce type de problème est une tâche pénible du point de
    vue d'un programmeur, comme tout cas de modernisation d'un design défectueux
    par de nouveaux concepts. Dans ce cas, il faut reconcevoir toutes les
    structures de données pour s'accomoder du fait qu'un caractère complet
    peut s'étendre sur un nombre variable de "char"s (ou basculer sur wchar_t
    et convertir comme nécessaire). Pour chaque appel aux fonctions "strlen" et
    équivalent, il faut aussi trouver ce que voulait vraiment dire un nombre
    d'octets, de caractères ou la largeur de la chaîne. Il est parfois plus
    rapide d'écrire depuis zéro un programme ayant la même fonctionnalité.</para>
    <para>Au sein des paquets de BLFS, ce problème s'applique à
    <xref linkend="xine-ui"/> et tous les shells.</para>
  </sect2>
  <sect2 id="locale-wrong-manpage-encoding"
         xreflabel="Incorrect Manual Page Encoding">
    <title>Le paquet installe des pages de manuel dans un mauvais encodage ou
    dans un non affichable</title>
    <para>Sévérité&nbsp;: basse</para>
    <para>LFS s'attend à ce que les pages de manuel soient dans
    l'encodage spécifique à la langue (en général 8-bit), comme indiqué
    sur la <ulink
    url="&lfs-root;/chapter06/man-db.html">page Man DB de LFS</ulink>. Cependant,
    certains paquets installent des pages de manuel traduites dans l'encodage
    UTF-8 (comme Shadow, déjà traité), ou des pages de manuel dans des langues
    non présentes dans la table. Tous les paquets BLFS n'ont pas fait l'objet
    d'une évaluation de leur respect des exigences de LFS (la grande majorité
    a été vérifiée et des corrections ont été mises dans le livre pour les
    paquets connus pour installer des pages de manuel non conformes). Si vous
    trouvez une page de manuel installée par un paquet BLFS qui est dans un
    mauvais encodage, merci de la supprimer ou de la convertir selon vos besoins
    et de le signaler à l'équipe BLFS comme un bogue.</para>
    <para>Vous pouvez facilement vérifier le respect par toutes les pages de
    man de votre système en copiant le petit script shell suivant à un
    endroit accessible,
<screen>
<literal>#!/bin/sh
# Begin checkman.sh
# Usage: find /usr/share/man -type f | xargs checkman.sh
for a in "$@"
do
    # echo "Checking $a..."
    # Pure-ASCII manual page (possibly except comments) is OK
    grep -v '.\\"' "$a" | iconv -f US-ASCII -t US-ASCII >/dev/null 2>&amp;1 \
        &amp;&amp; continue
    # Non-UTF-8 manual page is OK
    iconv -f UTF-8 -t UTF-8 "$a" >/dev/null 2>&amp;1 || continue
    # Found a UTF-8 manual page, bad.
    echo "UTF-8 manual page: $a" >&amp;2
done
# End checkman.sh
</literal>
</screen>
    puis en lançant la commande suivante (modifiez la commande ci-dessous si
    le script <command>checkman.sh</command> n'est pas dans votre variable
    d'environnement <envar>PATH</envar>)&nbsp;:</para>
<screen>
<userinput>find /usr/share/man -type f | xargs checkman.sh</userinput>
</screen>
    <para>Remarquez que si vous avez des pages de manuel installées ailleurs que
    dans <filename class='directory'>/usr/share/man</filename> (comme dans
    <filename class='directory'>/usr/local/share/man</filename>), vous devez
    modifier la commande ci-dessus pour inclure cet emplacement supplémentaire.</para>
  </sect2>
</sect1>
