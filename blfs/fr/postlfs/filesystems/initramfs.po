# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2019-09-01 04:13+0000\n"
"PO-Revision-Date: 2016-12-28 11:27+0000\n"
"Last-Translator: roptat <roptat@lepiller.eu>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"
"X-Generator: Pootle 2.7\n"
"X-POOTLE-MTIME: 1482924437.304380\n"

#. type: Content of: <sect1><sect1info>
#: blfs-en/postlfs/filesystems/initramfs.xml:12
msgid ""
"<othername>$LastChangedBy: bdubbs $</othername> <date>$Date: 2019-06-27 "
"20:55:17 +0000 (Thu, 27 Jun 2019) $</date>"
msgstr ""
"<othername>$LastChangedBy: bdubbs $</othername> <date>$Date: 2019-06-27 "
"20:55:17 +0000 (Thu, 27 Jun 2019) $</date>"

#. type: Content of: <sect1><title>
#: blfs-en/postlfs/filesystems/initramfs.xml:16
msgid "About initramfs"
msgstr "À propos de initramfs"

#. type: Content of: <sect1><para>
#: blfs-en/postlfs/filesystems/initramfs.xml:18
msgid ""
"The only purpose of an initramfs is to mount the root filesystem.  The "
"initramfs is a complete set of directories that you would find on a normal "
"root filesystem.  It is bundled into a single cpio archive and compressed "
"with one of several compression algorithms."
msgstr ""
"La seule fonction d'un initramfs est de monter le système de fichier racine."
"  L'initramfs est un ensemble complet de répertoires que vous pouvez trouver"
" dans un système de fichiers racine normal. Il est regroupé dans une seule "
"archive cpio et compressé avec l'un des nombreux algorithmes de compression."

#. type: Content of: <sect1><para>
#: blfs-en/postlfs/filesystems/initramfs.xml:23
msgid ""
"At boot time, the boot loader loads the kernel and the initramfs image into "
"memory and starts the kernel.  The kernel checks for the presence of the "
"initramfs and, if found, mounts it as / and runs /init. The init program is "
"typically a shell script.  Note that the boot process takes longer, possibly"
" significantly longer, if an initramfs is used."
msgstr ""
"Au moment du démarrage, le chargeur de démarrage charge le noyau et l'image "
"initramfs dans la mémoire et démarre le noyau. Le noyau vérifie la présence "
"d'un initramfs et, s'il le trouve, le monte sur / et lance /init. Le "
"programme init est typiquement un script shell.  Notez que le processus de "
"démarrage est plus long, même significativement plus long, si un initramfs "
"est utilisé."

#. type: Content of: <sect1><para>
#: blfs-en/postlfs/filesystems/initramfs.xml:29
msgid ""
"For most distributions, kernel modules are the biggest reason to have an "
"initramfs.  In a general distribution, there are many unknowns such as file "
"system types and disk layouts.  In a way, this is the opposite of LFS where "
"the system capabilities and layout are known and a custom kernel is normally"
" built.  In this situation, an initramfs is rarely needed."
msgstr ""
"Pour la plupart des distributions, les modules du noyau sont la plus "
"importante raison d'avoir un initramfs. Dans une distribution générale, il y"
" a beaucoup d'inconnues comme les types de systèmes de fichiers et les "
"couches des disques. Dans un sens, c'est l'opposé de LFS où les capacités et"
" les couches du système sont connus et un noyau personnalisé est normalement"
" construit.  Dans cette situation, un initramfs est rarement nécessaire."

#. type: Content of: <sect1><para>
#: blfs-en/postlfs/filesystems/initramfs.xml:35
msgid ""
"There are only four primary reasons to have an initramfs in the LFS "
"environment: loading the rootfs from a network, loading it from an LVM "
"logical volume, having an encrypted rootfs where a password is required, or "
"for the convenience of specifying the rootfs as a LABEL or UUID.  Anything "
"else usually means that the kernel was not configured properly."
msgstr ""
"Il y a seulement quatre raisons d'avoir un initramfs dans un environnement "
"LFS&nbsp;: le chargement du rootfs depuis le réseau, son chargement depuis "
"un volume logique LVM, avoir un rootfs chiffré où un mot de passe est "
"requis, ou pour le confort d'un rootfs spécifié par un LABEL ou un UUID. Les"
" autres cas signifient souvent que le noyau n'est pas configuré "
"correctement."

#. type: Content of: <sect1><sect2><title>
#: blfs-en/postlfs/filesystems/initramfs.xml:42
msgid "Building an initramfs"
msgstr "Construire un initramfs"

#. type: Content of: <sect1><sect2><para>
#: blfs-en/postlfs/filesystems/initramfs.xml:44
msgid ""
"If you do decide to build an initramfs, the following scripts will provide a"
" basis to do it.  The scripts will allow specifying a rootfs via partition "
"UUID or partition LABEL or a rootfs on an LVM logical volume.  They do not "
"support an encrypted root file system or mounting the rootfs over a network "
"card.  For a more complete capability see <ulink "
"url=\"http://www.linuxfromscratch.org/hints/read.html\"> the LFS "
"Hints</ulink> or <ulink url=\"http://fedoraproject.org/wiki/Dracut\"> "
"dracut</ulink>."
msgstr ""
"Si vous décidez de construire un initramfs, les scripts suivants fourniront "
"les bases pour le faire. Les scripts autoriseront la spécification du rootfs"
" via un UUID de partition ou un LABEL de partition ou un rootfs dans un "
"volume logique LVM. Ils ne supportent pas les systèmes de fichier racine "
"chiffrés ou le montage des rootfs par des cartes réseaux. Pour plus "
"d'informations sur les possibilités, voir <ulink "
"url=\"http://www.linuxfromscratch.org/hints/read.html\">L'astuce LFS "
"</ulink> ou <ulink "
"url=\"http://fedoraproject.org/wiki/Dracut\">dracut</ulink>."

#. type: Content of: <sect1><sect2><para>
#: blfs-en/postlfs/filesystems/initramfs.xml:53
msgid ""
"To install these scripts, run the following commands as the <systemitem "
"class=\"username\">root</systemitem> user:"
msgstr ""
"Pour installer ces scripts, lancez les commandes suivantes en tant "
"qu'utilisateur <systemitem class=\"username\">root</systemitem>&nbsp;:"

#. type: Content of: <sect1><sect2><screen>
#: blfs-en/postlfs/filesystems/initramfs.xml:56
#, no-wrap
msgid ""
"<userinput>cat &gt; /sbin/mkinitramfs &lt;&lt; \"EOF\"\n"
"<literal>#!/bin/bash\n"
"# This file based in part on the mkinitramfs script for the LFS LiveCD\n"
"# written by Alexander E. Patrakov and Jeremy Huntwork.\n"
"\n"
"copy()\n"
"{\n"
"  local file\n"
"\n"
"  if [ \"$2\" == \"lib\" ]; then\n"
"    file=$(PATH=/lib:/usr/lib type -p $1)\n"
"  else\n"
"    file=$(type -p $1)\n"
"  fi\n"
"\n"
"  if [ -n $file ] ; then\n"
"    cp $file $WDIR/$2\n"
"  else\n"
"    echo \"Missing required file: $1 for directory $2\"\n"
"    rm -rf $WDIR\n"
"    exit 1\n"
"  fi\n"
"}\n"
"\n"
"if [ -z $1 ] ; then\n"
"  INITRAMFS_FILE=initrd.img-no-kmods\n"
"else\n"
"  KERNEL_VERSION=$1\n"
"  INITRAMFS_FILE=initrd.img-$KERNEL_VERSION\n"
"fi\n"
"\n"
"if [ -n \"$KERNEL_VERSION\" ] &amp;&amp; [ ! -d \"/lib/modules/$1\" ] ; then\n"
"  echo \"No modules directory named $1\"\n"
"  exit 1\n"
"fi\n"
"\n"
"printf \"Creating $INITRAMFS_FILE... \"\n"
"\n"
"binfiles=\"sh cat cp dd killall ls mkdir mknod mount \"\n"
"binfiles=\"$binfiles umount sed sleep ln rm uname\"\n"
"binfiles=\"$binfiles readlink basename\"\n"
"\n"
"# Systemd installs udevadm in /bin. Other udev implementations have it in /sbin\n"
"if [ -x /bin/udevadm ] ; then binfiles=\"$binfiles udevadm\"; fi\n"
"\n"
"sbinfiles=\"modprobe blkid switch_root\"\n"
"\n"
"#Optional files and locations\n"
"for f in mdadm mdmon udevd udevadm; do\n"
"  if [ -x /sbin/$f ] ; then sbinfiles=\"$sbinfiles $f\"; fi\n"
"done\n"
"\n"
"unsorted=$(mktemp /tmp/unsorted.XXXXXXXXXX)\n"
"\n"
"DATADIR=/usr/share/mkinitramfs\n"
"INITIN=init.in\n"
"\n"
"# Create a temporary working directory\n"
"WDIR=$(mktemp -d /tmp/initrd-work.XXXXXXXXXX)\n"
"\n"
"# Create base directory structure\n"
"mkdir -p $WDIR/{bin,dev,lib/firmware,run,sbin,sys,proc,usr}\n"
"mkdir -p $WDIR/etc/{modprobe.d,udev/rules.d}\n"
"touch $WDIR/etc/modprobe.d/modprobe.conf\n"
"ln -s lib $WDIR/lib64\n"
"ln -s ../bin $WDIR/usr/bin\n"
"\n"
"# Create necessary device nodes\n"
"mknod -m 640 $WDIR/dev/console c 5 1\n"
"mknod -m 664 $WDIR/dev/null    c 1 3\n"
"\n"
"# Install the udev configuration files\n"
"if [ -f /etc/udev/udev.conf ]; then\n"
"  cp /etc/udev/udev.conf $WDIR/etc/udev/udev.conf\n"
"fi\n"
"\n"
"for file in $(find /etc/udev/rules.d/ -type f) ; do\n"
"  cp $file $WDIR/etc/udev/rules.d\n"
"done\n"
"\n"
"# Install any firmware present\n"
"cp -a /lib/firmware $WDIR/lib\n"
"\n"
"# Copy the RAID configuration file if present\n"
"if [ -f /etc/mdadm.conf ] ; then\n"
"  cp /etc/mdadm.conf $WDIR/etc\n"
"fi\n"
"\n"
"# Install the init file\n"
"install -m0755 $DATADIR/$INITIN $WDIR/init\n"
"\n"
"if [  -n \"$KERNEL_VERSION\" ] ; then\n"
"  if [ -x /bin/kmod ] ; then\n"
"    binfiles=\"$binfiles kmod\"\n"
"  else\n"
"    binfiles=\"$binfiles lsmod\"\n"
"    sbinfiles=\"$sbinfiles insmod\"\n"
"  fi\n"
"fi\n"
"\n"
"# Install basic binaries\n"
"for f in $binfiles ; do\n"
"  if [ -e /bin/$f ]; then d=\"/bin\"; else d=\"/usr/bin\"; fi\n"
"  ldd $d/$f | sed \"s/\\t//\" | cut -d \" \" -f1 &gt;&gt; $unsorted\n"
"  copy $d/$f bin\n"
"done\n"
"\n"
"# Add lvm if present\n"
"if [ -x /sbin/lvm ] ; then sbinfiles=\"$sbinfiles lvm dmsetup\"; fi\n"
"\n"
"for f in $sbinfiles ; do\n"
"  ldd /sbin/$f | sed \"s/\\t//\" | cut -d \" \" -f1 &gt;&gt; $unsorted\n"
"  copy $f sbin\n"
"done\n"
"\n"
"# Add udevd libraries if not in /sbin\n"
"if [ -x /lib/udev/udevd ] ; then\n"
"  ldd /lib/udev/udevd | sed \"s/\\t//\" | cut -d \" \" -f1 &gt;&gt; $unsorted\n"
"elif [ -x /lib/systemd/systemd-udevd ] ; then\n"
"  ldd /lib/systemd/systemd-udevd | sed \"s/\\t//\" | cut -d \" \" -f1 &gt;&gt; $unsorted\n"
"fi\n"
"\n"
"# Add module symlinks if appropriate\n"
"if [ -n \"$KERNEL_VERSION\" ] &amp;&amp; [ -x /bin/kmod ] ; then\n"
"  ln -s kmod $WDIR/bin/lsmod\n"
"  ln -s kmod $WDIR/bin/insmod\n"
"fi\n"
"\n"
"# Add lvm symlinks if appropriate\n"
"# Also copy the lvm.conf file\n"
"if  [ -x /sbin/lvm ] ; then\n"
"  ln -s lvm $WDIR/sbin/lvchange\n"
"  ln -s lvm $WDIR/sbin/lvrename\n"
"  ln -s lvm $WDIR/sbin/lvextend\n"
"  ln -s lvm $WDIR/sbin/lvcreate\n"
"  ln -s lvm $WDIR/sbin/lvdisplay\n"
"  ln -s lvm $WDIR/sbin/lvscan\n"
"\n"
"  ln -s lvm $WDIR/sbin/pvchange\n"
"  ln -s lvm $WDIR/sbin/pvck\n"
"  ln -s lvm $WDIR/sbin/pvcreate\n"
"  ln -s lvm $WDIR/sbin/pvdisplay\n"
"  ln -s lvm $WDIR/sbin/pvscan\n"
"\n"
"  ln -s lvm $WDIR/sbin/vgchange\n"
"  ln -s lvm $WDIR/sbin/vgcreate\n"
"  ln -s lvm $WDIR/sbin/vgscan\n"
"  ln -s lvm $WDIR/sbin/vgrename\n"
"  ln -s lvm $WDIR/sbin/vgck\n"
"  # Conf file(s)\n"
"  cp -a /etc/lvm $WDIR/etc\n"
"fi\n"
"\n"
"# Install libraries\n"
"sort $unsorted | uniq | while read library ; do\n"
"  if [ \"$library\" == \"linux-vdso.so.1\" ] ||\n"
"     [ \"$library\" == \"linux-gate.so.1\" ]; then\n"
"    continue\n"
"  fi\n"
"\n"
"  copy $library lib\n"
"done\n"
"\n"
"if [ -d /lib/udev ]; then\n"
"  cp -a /lib/udev $WDIR/lib\n"
"fi\n"
"if [ -d /lib/systemd ]; then\n"
"  cp -a /lib/systemd $WDIR/lib\n"
"fi\n"
"\n"
"# Install the kernel modules if requested\n"
"if [ -n \"$KERNEL_VERSION\" ]; then\n"
"  find                                                                        \\\n"
"     /lib/modules/$KERNEL_VERSION/kernel/{crypto,fs,lib}                      \\\n"
"     /lib/modules/$KERNEL_VERSION/kernel/drivers/{block,ata,md,firewire}      \\\n"
"     /lib/modules/$KERNEL_VERSION/kernel/drivers/{scsi,message,pcmcia,virtio} \\\n"
"     /lib/modules/$KERNEL_VERSION/kernel/drivers/usb/{host,storage}           \\\n"
"     -type f 2&gt; /dev/null | cpio --make-directories -p --quiet $WDIR\n"
"\n"
"  cp /lib/modules/$KERNEL_VERSION/modules.{builtin,order}                     \\\n"
"            $WDIR/lib/modules/$KERNEL_VERSION\n"
"\n"
"  depmod -b $WDIR $KERNEL_VERSION\n"
"fi\n"
"\n"
"( cd $WDIR ; find . | cpio -o -H newc --quiet | gzip -9 ) &gt; $INITRAMFS_FILE\n"
"\n"
"# Remove the temporary directory and file\n"
"rm -rf $WDIR $unsorted\n"
"printf \"done.\\n\"\n"
"</literal>\n"
"EOF\n"
"\n"
"chmod 0755 /sbin/mkinitramfs</userinput>"
msgstr ""
"<userinput>cat &gt; /sbin/mkinitramfs &lt;&lt; \"EOF\"\n"
"<literal>#!/bin/bash\n"
"# This file based in part on the mkinitramfs script for the LFS LiveCD\n"
"# written by Alexander E. Patrakov and Jeremy Huntwork.\n"
"\n"
"copy()\n"
"{\n"
"  local file\n"
"\n"
"  if [ \"$2\" == \"lib\" ]; then\n"
"    file=$(PATH=/lib:/usr/lib type -p $1)\n"
"  else\n"
"    file=$(type -p $1)\n"
"  fi\n"
"\n"
"  if [ -n $file ] ; then\n"
"    cp $file $WDIR/$2\n"
"  else\n"
"    echo \"Missing required file: $1 for directory $2\"\n"
"    rm -rf $WDIR\n"
"    exit 1\n"
"  fi\n"
"}\n"
"\n"
"if [ -z $1 ] ; then\n"
"  INITRAMFS_FILE=initrd.img-no-kmods\n"
"else\n"
"  KERNEL_VERSION=$1\n"
"  INITRAMFS_FILE=initrd.img-$KERNEL_VERSION\n"
"fi\n"
"\n"
"if [ -n \"$KERNEL_VERSION\" ] &amp;&amp; [ ! -d \"/lib/modules/$1\" ] ; then\n"
"  echo \"No modules directory named $1\"\n"
"  exit 1\n"
"fi\n"
"\n"
"printf \"Creating $INITRAMFS_FILE... \"\n"
"\n"
"binfiles=\"sh cat cp dd killall ls mkdir mknod mount \"\n"
"binfiles=\"$binfiles umount sed sleep ln rm uname\"\n"
"binfiles=\"$binfiles readlink basename\"\n"
"\n"
"# Systemd installs udevadm in /bin. Other udev implementations have it in /sbin\n"
"if [ -x /bin/udevadm ] ; then binfiles=\"$binfiles udevadm\"; fi\n"
"\n"
"sbinfiles=\"modprobe blkid switch_root\"\n"
"\n"
"#Optional files and locations\n"
"for f in mdadm mdmon udevd udevadm; do\n"
"  if [ -x /sbin/$f ] ; then sbinfiles=\"$sbinfiles $f\"; fi\n"
"done\n"
"\n"
"unsorted=$(mktemp /tmp/unsorted.XXXXXXXXXX)\n"
"\n"
"DATADIR=/usr/share/mkinitramfs\n"
"INITIN=init.in\n"
"\n"
"# Create a temporary working directory\n"
"WDIR=$(mktemp -d /tmp/initrd-work.XXXXXXXXXX)\n"
"\n"
"# Create base directory structure\n"
"mkdir -p $WDIR/{bin,dev,lib/firmware,run,sbin,sys,proc,usr}\n"
"mkdir -p $WDIR/etc/{modprobe.d,udev/rules.d}\n"
"touch $WDIR/etc/modprobe.d/modprobe.conf\n"
"ln -s lib $WDIR/lib64\n"
"ln -s ../bin $WDIR/usr/bin\n"
"\n"
"# Create necessary device nodes\n"
"mknod -m 640 $WDIR/dev/console c 5 1\n"
"mknod -m 664 $WDIR/dev/null    c 1 3\n"
"\n"
"# Install the udev configuration files\n"
"if [ -f /etc/udev/udev.conf ]; then\n"
"  cp /etc/udev/udev.conf $WDIR/etc/udev/udev.conf\n"
"fi\n"
"\n"
"for file in $(find /etc/udev/rules.d/ -type f) ; do\n"
"  cp $file $WDIR/etc/udev/rules.d\n"
"done\n"
"\n"
"# Install any firmware present\n"
"cp -a /lib/firmware $WDIR/lib\n"
"\n"
"# Copy the RAID configuration file if present\n"
"if [ -f /etc/mdadm.conf ] ; then\n"
"  cp /etc/mdadm.conf $WDIR/etc\n"
"fi\n"
"\n"
"# Install the init file\n"
"install -m0755 $DATADIR/$INITIN $WDIR/init\n"
"\n"
"if [  -n \"$KERNEL_VERSION\" ] ; then\n"
"  if [ -x /bin/kmod ] ; then\n"
"    binfiles=\"$binfiles kmod\"\n"
"  else\n"
"    binfiles=\"$binfiles lsmod\"\n"
"    sbinfiles=\"$sbinfiles insmod\"\n"
"  fi\n"
"fi\n"
"\n"
"# Install basic binaries\n"
"for f in $binfiles ; do\n"
"  if [ -e /bin/$f ]; then d=\"/bin\"; else d=\"/usr/bin\"; fi\n"
"  ldd $d/$f | sed \"s/\\t//\" | cut -d \" \" -f1 &gt;&gt; $unsorted\n"
"  copy $d/$f bin\n"
"done\n"
"\n"
"# Add lvm if present\n"
"if [ -x /sbin/lvm ] ; then sbinfiles=\"$sbinfiles lvm dmsetup\"; fi\n"
"\n"
"for f in $sbinfiles ; do\n"
"  ldd /sbin/$f | sed \"s/\\t//\" | cut -d \" \" -f1 &gt;&gt; $unsorted\n"
"  copy $f sbin\n"
"done\n"
"\n"
"# Add udevd libraries if not in /sbin\n"
"if [ -x /lib/udev/udevd ] ; then\n"
"  ldd /lib/udev/udevd | sed \"s/\\t//\" | cut -d \" \" -f1 &gt;&gt; $unsorted\n"
"elif [ -x /lib/systemd/systemd-udevd ] ; then\n"
"  ldd /lib/systemd/systemd-udevd | sed \"s/\\t//\" | cut -d \" \" -f1 &gt;&gt; $unsorted\n"
"fi\n"
"\n"
"# Add module symlinks if appropriate\n"
"if [ -n \"$KERNEL_VERSION\" ] &amp;&amp; [ -x /bin/kmod ] ; then\n"
"  ln -s kmod $WDIR/bin/lsmod\n"
"  ln -s kmod $WDIR/bin/insmod\n"
"fi\n"
"\n"
"# Add lvm symlinks if appropriate\n"
"# Also copy the lvm.conf file\n"
"if  [ -x /sbin/lvm ] ; then\n"
"  ln -s lvm $WDIR/sbin/lvchange\n"
"  ln -s lvm $WDIR/sbin/lvrename\n"
"  ln -s lvm $WDIR/sbin/lvextend\n"
"  ln -s lvm $WDIR/sbin/lvcreate\n"
"  ln -s lvm $WDIR/sbin/lvdisplay\n"
"  ln -s lvm $WDIR/sbin/lvscan\n"
"\n"
"  ln -s lvm $WDIR/sbin/pvchange\n"
"  ln -s lvm $WDIR/sbin/pvck\n"
"  ln -s lvm $WDIR/sbin/pvcreate\n"
"  ln -s lvm $WDIR/sbin/pvdisplay\n"
"  ln -s lvm $WDIR/sbin/pvscan\n"
"\n"
"  ln -s lvm $WDIR/sbin/vgchange\n"
"  ln -s lvm $WDIR/sbin/vgcreate\n"
"  ln -s lvm $WDIR/sbin/vgscan\n"
"  ln -s lvm $WDIR/sbin/vgrename\n"
"  ln -s lvm $WDIR/sbin/vgck\n"
"  # Conf file(s)\n"
"  cp -a /etc/lvm $WDIR/etc\n"
"fi\n"
"\n"
"# Install libraries\n"
"sort $unsorted | uniq | while read library ; do\n"
"  if [ \"$library\" == \"linux-vdso.so.1\" ] ||\n"
"     [ \"$library\" == \"linux-gate.so.1\" ]; then\n"
"    continue\n"
"  fi\n"
"\n"
"  copy $library lib\n"
"done\n"
"\n"
"if [ -d /lib/udev ]; then\n"
"  cp -a /lib/udev $WDIR/lib\n"
"fi\n"
"if [ -d /lib/systemd ]; then\n"
"  cp -a /lib/systemd $WDIR/lib\n"
"fi\n"
"\n"
"# Install the kernel modules if requested\n"
"if [ -n \"$KERNEL_VERSION\" ]; then\n"
"  find                                                                        \\\n"
"     /lib/modules/$KERNEL_VERSION/kernel/{crypto,fs,lib}                      \\\n"
"     /lib/modules/$KERNEL_VERSION/kernel/drivers/{block,ata,md,firewire}      \\\n"
"     /lib/modules/$KERNEL_VERSION/kernel/drivers/{scsi,message,pcmcia,virtio} \\\n"
"     /lib/modules/$KERNEL_VERSION/kernel/drivers/usb/{host,storage}           \\\n"
"     -type f 2&gt; /dev/null | cpio --make-directories -p --quiet $WDIR\n"
"\n"
"  cp /lib/modules/$KERNEL_VERSION/modules.{builtin,order}                     \\\n"
"            $WDIR/lib/modules/$KERNEL_VERSION\n"
"\n"
"  depmod -b $WDIR $KERNEL_VERSION\n"
"fi\n"
"\n"
"( cd $WDIR ; find . | cpio -o -H newc --quiet | gzip -9 ) &gt; $INITRAMFS_FILE\n"
"\n"
"# Remove the temporary directory and file\n"
"rm -rf $WDIR $unsorted\n"
"printf \"done.\\n\"\n"
"</literal>\n"
"EOF\n"
"\n"
"chmod 0755 /sbin/mkinitramfs</userinput>"

#. type: Content of: <sect1><sect2><screen>
#: blfs-en/postlfs/filesystems/initramfs.xml:251
#, no-wrap
msgid ""
"<userinput>mkdir -p /usr/share/mkinitramfs &amp;&amp;\n"
"cat &gt; /usr/share/mkinitramfs/init.in &lt;&lt; \"EOF\"\n"
"<literal>#!/bin/sh\n"
"\n"
"PATH=/bin:/usr/bin:/sbin:/usr/sbin\n"
"export PATH\n"
"\n"
"problem()\n"
"{\n"
"   printf \"Encountered a problem!\\n\\nDropping you to a shell.\\n\\n\"\n"
"   sh\n"
"}\n"
"\n"
"no_device()\n"
"{\n"
"   printf \"The device %s, which is supposed to contain the\\n\" $1\n"
"   printf \"root file system, does not exist.\\n\"\n"
"   printf \"Please fix this problem and exit this shell.\\n\\n\"\n"
"}\n"
"\n"
"no_mount()\n"
"{\n"
"   printf \"Could not mount device %s\\n\" $1\n"
"   printf \"Sleeping forever. Please reboot and fix the kernel command line.\\n\\n\"\n"
"   printf \"Maybe the device is formatted with an unsupported file system?\\n\\n\"\n"
"   printf \"Or maybe filesystem type autodetection went wrong, in which case\\n\"\n"
"   printf \"you should add the rootfstype=... parameter to the kernel command line.\\n\\n\"\n"
"   printf \"Available partitions:\\n\"\n"
"}\n"
"\n"
"do_mount_root()\n"
"{\n"
"   mkdir /.root\n"
"   [ -n \"$rootflags\" ] &amp;&amp; rootflags=\"$rootflags,\"\n"
"   rootflags=\"$rootflags$ro\"\n"
"\n"
"   case \"$root\" in\n"
"      /dev/* ) device=$root ;;\n"
"      UUID=* ) eval $root; device=\"/dev/disk/by-uuid/$UUID\"  ;;\n"
"      LABEL=*) eval $root; device=\"/dev/disk/by-label/$LABEL\" ;;\n"
"      \"\"     ) echo \"No root device specified.\" ; problem    ;;\n"
"   esac\n"
"\n"
"   while [ ! -b \"$device\" ] ; do\n"
"       no_device $device\n"
"       problem\n"
"   done\n"
"\n"
"   if ! mount -n -t \"$rootfstype\" -o \"$rootflags\" \"$device\" /.root ; then\n"
"       no_mount $device\n"
"       cat /proc/partitions\n"
"       while true ; do sleep 10000 ; done\n"
"   else\n"
"       echo \"Successfully mounted device $root\"\n"
"   fi\n"
"}\n"
"\n"
"init=/sbin/init\n"
"root=\n"
"rootdelay=\n"
"rootfstype=auto\n"
"ro=\"ro\"\n"
"rootflags=\n"
"device=\n"
"\n"
"mount -n -t devtmpfs devtmpfs /dev\n"
"mount -n -t proc     proc     /proc\n"
"mount -n -t sysfs    sysfs    /sys\n"
"mount -n -t tmpfs    tmpfs    /run\n"
"\n"
"read -r cmdline &lt; /proc/cmdline\n"
"\n"
"for param in $cmdline ; do\n"
"  case $param in\n"
"    init=*      ) init=${param#init=}             ;;\n"
"    root=*      ) root=${param#root=}             ;;\n"
"    rootdelay=* ) rootdelay=${param#rootdelay=}   ;;\n"
"    rootfstype=*) rootfstype=${param#rootfstype=} ;;\n"
"    rootflags=* ) rootflags=${param#rootflags=}   ;;\n"
"    ro          ) ro=\"ro\"                         ;;\n"
"    rw          ) ro=\"rw\"                         ;;\n"
"  esac\n"
"done\n"
"\n"
"# udevd location depends on version\n"
"if [ -x /sbin/udevd ]; then\n"
"  UDEVD=/sbin/udevd\n"
"elif [ -x /lib/udev/udevd ]; then\n"
"  UDEVD=/lib/udev/udevd\n"
"elif [ -x /lib/systemd/systemd-udevd ]; then\n"
"  UDEVD=/lib/systemd/systemd-udevd\n"
"else\n"
"  echo \"Cannot find udevd nor systemd-udevd\"\n"
"  problem\n"
"fi\n"
"\n"
"${UDEVD} --daemon --resolve-names=never\n"
"udevadm trigger\n"
"udevadm settle\n"
"\n"
"if [ -f /etc/mdadm.conf ] ; then mdadm -As                       ; fi\n"
"if [ -x /sbin/vgchange  ] ; then /sbin/vgchange -a y &gt; /dev/null ; fi\n"
"if [ -n \"$rootdelay\"    ] ; then sleep \"$rootdelay\"              ; fi\n"
"\n"
"do_mount_root\n"
"\n"
"killall -w ${UDEVD##*/}\n"
"\n"
"exec switch_root /.root \"$init\" \"$@\"\n"
"</literal>\n"
"EOF</userinput>"
msgstr ""
"<userinput>mkdir -p /usr/share/mkinitramfs &amp;&amp;\n"
"cat &gt; /usr/share/mkinitramfs/init.in &lt;&lt; \"EOF\"\n"
"<literal>#!/bin/sh\n"
"\n"
"PATH=/bin:/usr/bin:/sbin:/usr/sbin\n"
"export PATH\n"
"\n"
"problem()\n"
"{\n"
"   printf \"Encountered a problem!\\n\\nDropping you to a shell.\\n\\n\"\n"
"   sh\n"
"}\n"
"\n"
"no_device()\n"
"{\n"
"   printf \"The device %s, which is supposed to contain the\\n\" $1\n"
"   printf \"root file system, does not exist.\\n\"\n"
"   printf \"Please fix this problem and exit this shell.\\n\\n\"\n"
"}\n"
"\n"
"no_mount()\n"
"{\n"
"   printf \"Could not mount device %s\\n\" $1\n"
"   printf \"Sleeping forever. Please reboot and fix the kernel command line.\\n\\n\"\n"
"   printf \"Maybe the device is formatted with an unsupported file system?\\n\\n\"\n"
"   printf \"Or maybe filesystem type autodetection went wrong, in which case\\n\"\n"
"   printf \"you should add the rootfstype=... parameter to the kernel command line.\\n\\n\"\n"
"   printf \"Available partitions:\\n\"\n"
"}\n"
"\n"
"do_mount_root()\n"
"{\n"
"   mkdir /.root\n"
"   [ -n \"$rootflags\" ] &amp;&amp; rootflags=\"$rootflags,\"\n"
"   rootflags=\"$rootflags$ro\"\n"
"\n"
"   case \"$root\" in\n"
"      /dev/* ) device=$root ;;\n"
"      UUID=* ) eval $root; device=\"/dev/disk/by-uuid/$UUID\"  ;;\n"
"      LABEL=*) eval $root; device=\"/dev/disk/by-label/$LABEL\" ;;\n"
"      \"\"     ) echo \"No root device specified.\" ; problem    ;;\n"
"   esac\n"
"\n"
"   while [ ! -b \"$device\" ] ; do\n"
"       no_device $device\n"
"       problem\n"
"   done\n"
"\n"
"   if ! mount -n -t \"$rootfstype\" -o \"$rootflags\" \"$device\" /.root ; then\n"
"       no_mount $device\n"
"       cat /proc/partitions\n"
"       while true ; do sleep 10000 ; done\n"
"   else\n"
"       echo \"Successfully mounted device $root\"\n"
"   fi\n"
"}\n"
"\n"
"init=/sbin/init\n"
"root=\n"
"rootdelay=\n"
"rootfstype=auto\n"
"ro=\"ro\"\n"
"rootflags=\n"
"device=\n"
"\n"
"mount -n -t devtmpfs devtmpfs /dev\n"
"mount -n -t proc     proc     /proc\n"
"mount -n -t sysfs    sysfs    /sys\n"
"mount -n -t tmpfs    tmpfs    /run\n"
"\n"
"read -r cmdline &lt; /proc/cmdline\n"
"\n"
"for param in $cmdline ; do\n"
"  case $param in\n"
"    init=*      ) init=${param#init=}             ;;\n"
"    root=*      ) root=${param#root=}             ;;\n"
"    rootdelay=* ) rootdelay=${param#rootdelay=}   ;;\n"
"    rootfstype=*) rootfstype=${param#rootfstype=} ;;\n"
"    rootflags=* ) rootflags=${param#rootflags=}   ;;\n"
"    ro          ) ro=\"ro\"                         ;;\n"
"    rw          ) ro=\"rw\"                         ;;\n"
"  esac\n"
"done\n"
"\n"
"# udevd location depends on version\n"
"if [ -x /sbin/udevd ]; then\n"
"  UDEVD=/sbin/udevd\n"
"elif [ -x /lib/udev/udevd ]; then\n"
"  UDEVD=/lib/udev/udevd\n"
"elif [ -x /lib/systemd/systemd-udevd ]; then\n"
"  UDEVD=/lib/systemd/systemd-udevd\n"
"else\n"
"  echo \"Cannot find udevd nor systemd-udevd\"\n"
"  problem\n"
"fi\n"
"\n"
"${UDEVD} --daemon --resolve-names=never\n"
"udevadm trigger\n"
"udevadm settle\n"
"\n"
"if [ -f /etc/mdadm.conf ] ; then mdadm -As                       ; fi\n"
"if [ -x /sbin/vgchange  ] ; then /sbin/vgchange -a y &gt; /dev/null ; fi\n"
"if [ -n \"$rootdelay\"    ] ; then sleep \"$rootdelay\"              ; fi\n"
"\n"
"do_mount_root\n"
"\n"
"killall -w ${UDEVD##*/}\n"
"\n"
"exec switch_root /.root \"$init\" \"$@\"\n"
"</literal>\n"
"EOF</userinput>"

#. type: Content of: <sect1><sect2><title>
#: blfs-en/postlfs/filesystems/initramfs.xml:366
msgid "Using an initramfs"
msgstr "Utilisation d'un initramfs"

#. type: Content of: <sect1><sect2><bridgehead>
#: blfs-en/postlfs/filesystems/initramfs.xml:368
msgid "Required Runtime Dependency"
msgstr "Dépendance d'exécution requise"

#. type: Content of: <sect1><sect2><para>
#: blfs-en/postlfs/filesystems/initramfs.xml:371
msgid "<xref role=\"runtime\" linkend=\"cpio\"/>"
msgstr "<xref role=\"runtime\" linkend=\"cpio\"/>"

#. type: Content of: <sect1><sect2><para>
#: blfs-en/postlfs/filesystems/initramfs.xml:374
msgid "User Notes: <ulink url=\"&blfs-wiki;/initramfs\"/>"
msgstr "Notes utilisateur&nbsp;: <ulink url=\"&blfs-wiki;/initramfs\"/>"

#. type: Content of: <sect1><sect2><para>
#: blfs-en/postlfs/filesystems/initramfs.xml:379
msgid ""
"To build an initramfs, run the following as the <systemitem "
"class=\"username\">root</systemitem> user:"
msgstr ""
"Pour construire un initramfs, lancer ce qui suit en tant qu'utilisateur "
"<systemitem class=\"username\">root</systemitem>&nbsp;:"

#. type: Content of: <sect1><sect2><screen>
#: blfs-en/postlfs/filesystems/initramfs.xml:382
#, no-wrap
msgid "<userinput>mkinitramfs [KERNEL VERSION]</userinput>"
msgstr "<userinput>mkinitramfs [KERNEL VERSION]</userinput>"

#. type: Content of: <sect1><sect2><para>
#: blfs-en/postlfs/filesystems/initramfs.xml:384
msgid ""
"The optional argument is the directory where the appropriate kernel modules "
"are located. This must be a subdirectory of <filename class='directory'> "
"/lib/modules</filename>.  If no modules are specified, then the initramfs is"
" named <emphasis>initrd.img-no-kmods</emphasis>.  If a kernel version is "
"specified, the initrd is named "
"<emphasis>initrd.img-$KERNEL_VERSION</emphasis> and is only appropriate for "
"the specific kernel specified. The output file will be placed in the current"
" directory."
msgstr ""
"L'argument facultatif est le répertoire où les modules appropriés du noyau "
"sont enregistrés.  Cela peut être un sous-répertoire de <filename "
"class='directory'> /lib/modules</filename>.  Si aucun module n'est spécifié,"
" alors l'initramfs est appelé <emphasis>initrd.img-no-kmods</emphasis>.  Si "
"une version du noyau est précisé, le fichier initrd est appelé "
"<emphasis>initrd.img-$KERNEL_VERSION</emphasis> et est seulement destiné "
"pour le noyau spécifiquement précisé. Les fichiers de sortie seront "
"enregistrés dans le répertoire courant."

#. type: Content of: <sect1><sect2><para>
#: blfs-en/postlfs/filesystems/initramfs.xml:393
msgid ""
"After generating the initrd, copy it to the <filename "
"class='directory'>/boot</filename> directory."
msgstr ""
"Après avoir généré le fichier initrd, copiez-le dans le répertoire <filename"
" class='directory'>/boot</filename>."

#. type: Content of: <sect1><sect2><para>
#: blfs-en/postlfs/filesystems/initramfs.xml:396
msgid ""
"Now edit <filename>/boot/grub/grub.cfg</filename> and add a new menuentry.  "
"Below are several examples."
msgstr ""
"Maintenant éditez <filename>/boot/grub/grub.cfg</filename> et ajoutez une "
"nouvelle entrée dans le menu. En dessous, plusieurs exemples sont présentés."

#. type: Content of: <sect1><sect2><screen>
#: blfs-en/postlfs/filesystems/initramfs.xml:399
#, no-wrap
msgid ""
"<userinput># Generic initramfs and root fs identified by UUID\n"
"menuentry \"LFS Dev (LFS-7.0-Feb14) initrd, Linux 3.0.4\"\n"
"{\n"
"  linux  /vmlinuz-3.0.4-lfs-20120214 root=UUID=54b934a9-302d-415e-ac11-4988408eb0a8 ro\n"
"  initrd /initrd.img-no-kmods\n"
"}</userinput>"
msgstr ""
"<userinput># Generic initramfs and root fs identified by UUID\n"
"menuentry \"LFS Dev (LFS-7.0-Feb14) initrd, Linux 3.0.4\"\n"
"{\n"
"  linux  /vmlinuz-3.0.4-lfs-20120214 root=UUID=54b934a9-302d-415e-ac11-4988408eb0a8 ro\n"
"  initrd /initrd.img-no-kmods\n"
"}</userinput>"

#. type: Content of: <sect1><sect2><screen>
#: blfs-en/postlfs/filesystems/initramfs.xml:406
#, no-wrap
msgid ""
"<userinput># Generic initramfs and root fs on LVM partition\n"
"menuentry \"LFS Dev (LFS-7.0-Feb18) initrd lvm, Linux 3.0.4\"\n"
"{\n"
"  linux  /vmlinuz-3.0.4-lfs-20120218 root=/dev/mapper/myroot ro\n"
"  initrd /initrd.img-no-kmods\n"
"}</userinput>"
msgstr ""
"<userinput># Generic initramfs and root fs on LVM partition\n"
"menuentry \"LFS Dev (LFS-7.0-Feb18) initrd lvm, Linux 3.0.4\"\n"
"{\n"
"  linux  /vmlinuz-3.0.4-lfs-20120218 root=/dev/mapper/myroot ro\n"
"  initrd /initrd.img-no-kmods\n"
"}</userinput>"

#. type: Content of: <sect1><sect2><screen>
#: blfs-en/postlfs/filesystems/initramfs.xml:413
#, no-wrap
msgid ""
"<userinput># Specific initramfs and root fs identified by LABEL\n"
"menuentry \"LFS Dev (LFS-7.1-Feb20) initrd label, Linux 3.2.6\"\n"
"{\n"
"  linux  /vmlinuz-3.2.6-lfs71-120220 root=LABEL=lfs71 ro\n"
"  initrd /initrd.img-3.2.6-lfs71-120220\n"
"}</userinput>"
msgstr ""
"<userinput># Specific initramfs and root fs identified by LABEL\n"
"menuentry \"LFS Dev (LFS-7.1-Feb20) initrd label, Linux 3.2.6\"\n"
"{\n"
"  linux  /vmlinuz-3.2.6-lfs71-120220 root=LABEL=lfs71 ro\n"
"  initrd /initrd.img-3.2.6-lfs71-120220\n"
"}</userinput>"

#. type: Content of: <sect1><sect2><para>
#: blfs-en/postlfs/filesystems/initramfs.xml:420
msgid "Finally, reboot the system and select the desired system."
msgstr "Finalement, redémarrez le système et sélectionnez le système désiré."
