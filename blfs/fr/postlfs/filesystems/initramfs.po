# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2020-05-24 04:06+0000\n"
"PO-Revision-Date: 2020-02-06 18:13+0000\n"
"Last-Translator: roptat <roptat@lepiller.eu>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"
"X-Generator: Pootle 2.8\n"
"X-POOTLE-MTIME: 1581012805.987154\n"

#. type: Content of: <sect1><sect1info>
#: blfs-en/postlfs/filesystems/initramfs.xml:12
#| msgid ""
#| "<othername>$LastChangedBy: pierre $</othername> <date>$Date: 2020-05-14 "
#| "08:54:12 +0000 (Thu, 14 May 2020) $</date>"
msgid ""
"<othername>$LastChangedBy: pierre $</othername> <date>$Date: 2020-05-23 "
"20:54:29 +0000 (Sat, 23 May 2020) $</date>"
msgstr ""
"<othername>$LastChangedBy: pierre $</othername> <date>$Date: 2020-05-23 "
"20:54:29 +0000 (Sat, 23 May 2020) $</date>"

#. type: Content of: <sect1><title>
#: blfs-en/postlfs/filesystems/initramfs.xml:16
msgid "About initramfs"
msgstr "À propos de initramfs"

#. type: Content of: <sect1><para>
#: blfs-en/postlfs/filesystems/initramfs.xml:19
msgid ""
"The only purpose of an initramfs is to mount the root filesystem.  The "
"initramfs is a complete set of directories that you would find on a normal "
"root filesystem.  It is bundled into a single cpio archive and compressed "
"with one of several compression algorithms."
msgstr ""
"La seule fonction d'un initramfs est de monter le système de fichier racine."
"  L'initramfs est un ensemble complet de répertoires que vous pouvez trouver"
" dans un système de fichiers racine normal. Il est regroupé dans une seule "
"archive cpio et compressé avec l'un des nombreux algorithmes de compression."

#. type: Content of: <sect1><para>
#: blfs-en/postlfs/filesystems/initramfs.xml:26
msgid ""
"At boot time, the boot loader loads the kernel and the initramfs image into "
"memory and starts the kernel.  The kernel checks for the presence of the "
"initramfs and, if found, mounts it as / and runs /init. The init program is "
"typically a shell script.  Note that the boot process takes longer, possibly"
" significantly longer, if an initramfs is used."
msgstr ""
"Au moment du démarrage, le chargeur de démarrage charge le noyau et l'image "
"initramfs dans la mémoire et démarre le noyau. Le noyau vérifie la présence "
"d'un initramfs et, s'il le trouve, le monte sur / et lance /init. Le "
"programme init est typiquement un script shell.  Notez que le processus de "
"démarrage est plus long, même significativement plus long, si un initramfs "
"est utilisé."

#. type: Content of: <sect1><para>
#: blfs-en/postlfs/filesystems/initramfs.xml:34
msgid ""
"For most distributions, kernel modules are the biggest reason to have an "
"initramfs.  In a general distribution, there are many unknowns such as file "
"system types and disk layouts.  In a way, this is the opposite of LFS where "
"the system capabilities and layout are known and a custom kernel is normally"
" built.  In this situation, an initramfs is rarely needed."
msgstr ""
"Pour la plupart des distributions, les modules du noyau sont la plus "
"importante raison d'avoir un initramfs. Dans une distribution générale, il y"
" a beaucoup d'inconnues comme les types de systèmes de fichiers et les "
"couches des disques. Dans un sens, c'est l'opposé de LFS où les capacités et"
" les couches du système sont connus et un noyau personnalisé est normalement"
" construit.  Dans cette situation, un initramfs est rarement nécessaire."

#. type: Content of: <sect1><para>
#: blfs-en/postlfs/filesystems/initramfs.xml:43
msgid ""
"There are only four primary reasons to have an initramfs in the LFS "
"environment: loading the rootfs from a network, loading it from an LVM "
"logical volume, having an encrypted rootfs where a password is required, or "
"for the convenience of specifying the rootfs as a LABEL or UUID.  Anything "
"else usually means that the kernel was not configured properly."
msgstr ""
"Il y a seulement quatre raisons d'avoir un initramfs dans un environnement "
"LFS&nbsp;: le chargement du rootfs depuis le réseau, son chargement depuis "
"un volume logique LVM, avoir un rootfs chiffré où un mot de passe est "
"requis, ou pour le confort d'un rootfs spécifié par un LABEL ou un UUID. Les"
" autres cas signifient souvent que le noyau n'est pas configuré "
"correctement."

#. type: Content of: <sect1><sect2><title>
#: blfs-en/postlfs/filesystems/initramfs.xml:51
msgid "Building an initramfs"
msgstr "Construire un initramfs"

#. type: Content of: <sect1><sect2><para>
#: blfs-en/postlfs/filesystems/initramfs.xml:54
#, fuzzy
#| msgid ""
#| "If you do decide to build an initramfs, the following scripts will provide a"
#| " basis to do it.  The scripts will allow specifying a rootfs via partition "
#| "UUID or partition LABEL or a rootfs on an LVM logical volume.  They do not "
#| "support an encrypted root file system or mounting the rootfs over a network "
#| "card.  For a more complete capability see <ulink "
#| "url=\"http://www.linuxfromscratch.org/hints/read.html\"> the LFS "
#| "Hints</ulink> or <ulink url=\"http://fedoraproject.org/wiki/Dracut\"> "
#| "dracut</ulink>."
msgid ""
"If you do decide to build an initramfs, the following scripts will provide a"
" basis to do it.  The scripts will allow specifying a rootfs via partition "
"UUID or partition LABEL or a rootfs on an LVM logical volume.  They do not "
"support an encrypted root file system or mounting the rootfs over a network "
"card.  For a more complete capability see <ulink "
"url=\"http://www.linuxfromscratch.org/hints/read.html\"> the LFS "
"Hints</ulink> or <ulink "
"url=\"http://fedoraproject.org/wiki/Dracut\">dracut</ulink>."
msgstr ""
"Si vous décidez de construire un initramfs, les scripts suivants fourniront "
"les bases pour le faire. Les scripts autoriseront la spécification du rootfs"
" via un UUID de partition ou un LABEL de partition ou un rootfs dans un "
"volume logique LVM. Ils ne supportent pas les systèmes de fichier racine "
"chiffrés ou le montage des rootfs par des cartes réseaux. Pour plus "
"d'informations sur les possibilités, voir <ulink "
"url=\"http://www.linuxfromscratch.org/hints/read.html\">L'astuce LFS "
"</ulink> ou <ulink "
"url=\"http://fedoraproject.org/wiki/Dracut\">dracut</ulink>."

#. type: Content of: <sect1><sect2><para>
#: blfs-en/postlfs/filesystems/initramfs.xml:65
msgid ""
"To install these scripts, run the following commands as the <systemitem "
"class=\"username\">root</systemitem> user:"
msgstr ""
"Pour installer ces scripts, lancez les commandes suivantes en tant "
"qu'utilisateur <systemitem class=\"username\">root</systemitem>&nbsp;:"

#. type: Content of: <sect1><sect2><screen>
#: blfs-en/postlfs/filesystems/initramfs.xml:69
#, no-wrap
#| msgid ""
#| "<userinput>cat &gt; /sbin/mkinitramfs &lt;&lt; \"EOF\"\n"
#| "<literal>#!/bin/bash\n"
#| "# This file based in part on the mkinitramfs script for the LFS LiveCD\n"
#| "# written by Alexander E. Patrakov and Jeremy Huntwork.\n"
#| "\n"
#| "copy()\n"
#| "{\n"
#| "  local file\n"
#| "\n"
#| "  if [ \"$2\" = \"lib\" ]; then\n"
#| "    file=$(find /lib /usr/lib -maxdepth 1 -name $1 | head -n 1)\n"
#| "  else\n"
#| "    file=$(find /bin /usr/bin /sbin /usr/sbin -maxdepth 1 -name $1 | head -n 1)\n"
#| "  fi\n"
#| "\n"
#| "  if [ -n \"$file\" ] ; then\n"
#| "    cp $file $WDIR/$2\n"
#| "  else\n"
#| "    echo \"Missing required file: $1 for directory $2\"\n"
#| "    rm -rf $WDIR\n"
#| "    exit 1\n"
#| "  fi\n"
#| "}\n"
#| "\n"
#| "if [ -z $1 ] ; then\n"
#| "  INITRAMFS_FILE=initrd.img-no-kmods\n"
#| "else\n"
#| "  KERNEL_VERSION=$1\n"
#| "  INITRAMFS_FILE=initrd.img-$KERNEL_VERSION\n"
#| "fi\n"
#| "\n"
#| "if [ -n \"$KERNEL_VERSION\" ] &amp;&amp; [ ! -d \"/lib/modules/$1\" ] ; then\n"
#| "  echo \"No modules directory named $1\"\n"
#| "  exit 1\n"
#| "fi\n"
#| "\n"
#| "printf \"Creating $INITRAMFS_FILE... \"\n"
#| "\n"
#| "binfiles=\"sh cat cp dd killall ls mkdir mknod mount \"\n"
#| "binfiles=\"$binfiles umount sed sleep ln rm uname\"\n"
#| "binfiles=\"$binfiles readlink basename\"\n"
#| "\n"
#| "# Systemd installs udevadm in /bin. Other udev implementations have it in /sbin\n"
#| "if [ -x /bin/udevadm ] ; then binfiles=\"$binfiles udevadm\"; fi\n"
#| "\n"
#| "sbinfiles=\"modprobe blkid switch_root\"\n"
#| "\n"
#| "#Optional files and locations\n"
#| "for f in mdadm mdmon udevd udevadm; do\n"
#| "  if [ -x /sbin/$f ] ; then sbinfiles=\"$sbinfiles $f\"; fi\n"
#| "done\n"
#| "\n"
#| "unsorted=$(mktemp /tmp/unsorted.XXXXXXXXXX)\n"
#| "\n"
#| "DATADIR=/usr/share/mkinitramfs\n"
#| "INITIN=init.in\n"
#| "\n"
#| "# Create a temporary working directory\n"
#| "WDIR=$(mktemp -d /tmp/initrd-work.XXXXXXXXXX)\n"
#| "\n"
#| "# Create base directory structure\n"
#| "mkdir -p $WDIR/{bin,dev,lib/firmware,run,sbin,sys,proc,usr}\n"
#| "mkdir -p $WDIR/etc/{modprobe.d,udev/rules.d}\n"
#| "touch $WDIR/etc/modprobe.d/modprobe.conf\n"
#| "ln -s lib $WDIR/lib64\n"
#| "ln -s ../bin $WDIR/usr/bin\n"
#| "\n"
#| "# Create necessary device nodes\n"
#| "mknod -m 640 $WDIR/dev/console c 5 1\n"
#| "mknod -m 664 $WDIR/dev/null    c 1 3\n"
#| "\n"
#| "# Install the udev configuration files\n"
#| "if [ -f /etc/udev/udev.conf ]; then\n"
#| "  cp /etc/udev/udev.conf $WDIR/etc/udev/udev.conf\n"
#| "fi\n"
#| "\n"
#| "for file in $(find /etc/udev/rules.d/ -type f) ; do\n"
#| "  cp $file $WDIR/etc/udev/rules.d\n"
#| "done\n"
#| "\n"
#| "# Install any firmware present\n"
#| "cp -a /lib/firmware $WDIR/lib\n"
#| "\n"
#| "# Copy the RAID configuration file if present\n"
#| "if [ -f /etc/mdadm.conf ] ; then\n"
#| "  cp /etc/mdadm.conf $WDIR/etc\n"
#| "fi\n"
#| "\n"
#| "# Install the init file\n"
#| "install -m0755 $DATADIR/$INITIN $WDIR/init\n"
#| "\n"
#| "if [  -n \"$KERNEL_VERSION\" ] ; then\n"
#| "  if [ -x /bin/kmod ] ; then\n"
#| "    binfiles=\"$binfiles kmod\"\n"
#| "  else\n"
#| "    binfiles=\"$binfiles lsmod\"\n"
#| "    sbinfiles=\"$sbinfiles insmod\"\n"
#| "  fi\n"
#| "fi\n"
#| "\n"
#| "# Install basic binaries\n"
#| "for f in $binfiles ; do\n"
#| "  if [ -e /bin/$f ]; then d=\"/bin\"; else d=\"/usr/bin\"; fi\n"
#| "  ldd $d/$f | sed \"s/\\t//\" | cut -d \" \" -f1 &gt;&gt; $unsorted\n"
#| "  copy $d/$f bin\n"
#| "done\n"
#| "\n"
#| "# Add lvm if present\n"
#| "if [ -x /sbin/lvm ] ; then sbinfiles=\"$sbinfiles lvm dmsetup\"; fi\n"
#| "\n"
#| "# Add mdadm if present\n"
#| "if [ -x /sbin/mdadm ] ; then sbinfiles=\"$sbinfiles mdadm\"; fi\n"
#| "\n"
#| "# Add udevd if present in /sbin (newer versions of udev have it in\n"
#| "# /lib/udev)\n"
#| "if [ -x /sbin/udevd ] ; then sbinfiles=\"$sbinfiles udevd\"; fi\n"
#| "\n"
#| "for f in $sbinfiles ; do\n"
#| "  ldd /sbin/$f | sed \"s/\\t//\" | cut -d \" \" -f1 &gt;&gt; $unsorted\n"
#| "  copy $f sbin\n"
#| "done\n"
#| "\n"
#| "# Add udevd libraries if not in /sbin\n"
#| "if [ -x /lib/udev/udevd ] ; then\n"
#| "  ldd /lib/udev/udevd | sed \"s/\\t//\" | cut -d \" \" -f1 &gt;&gt; $unsorted\n"
#| "elif [ -x /lib/systemd/systemd-udevd ] ; then\n"
#| "  ldd /lib/systemd/systemd-udevd | sed \"s/\\t//\" | cut -d \" \" -f1 &gt;&gt; $unsorted\n"
#| "fi\n"
#| "\n"
#| "# Add module symlinks if appropriate\n"
#| "if [ -n \"$KERNEL_VERSION\" ] &amp;&amp; [ -x /bin/kmod ] ; then\n"
#| "  ln -s kmod $WDIR/bin/lsmod\n"
#| "  ln -s kmod $WDIR/bin/insmod\n"
#| "fi\n"
#| "\n"
#| "ln -s bash $WDIR/bin/sh\n"
#| "\n"
#| "# Add lvm symlinks if appropriate\n"
#| "# Also copy the lvm.conf file\n"
#| "if  [ -x /sbin/lvm ] ; then\n"
#| "  ln -s lvm $WDIR/sbin/lvchange\n"
#| "  ln -s lvm $WDIR/sbin/lvrename\n"
#| "  ln -s lvm $WDIR/sbin/lvextend\n"
#| "  ln -s lvm $WDIR/sbin/lvcreate\n"
#| "  ln -s lvm $WDIR/sbin/lvdisplay\n"
#| "  ln -s lvm $WDIR/sbin/lvscan\n"
#| "\n"
#| "  ln -s lvm $WDIR/sbin/pvchange\n"
#| "  ln -s lvm $WDIR/sbin/pvck\n"
#| "  ln -s lvm $WDIR/sbin/pvcreate\n"
#| "  ln -s lvm $WDIR/sbin/pvdisplay\n"
#| "  ln -s lvm $WDIR/sbin/pvscan\n"
#| "\n"
#| "  ln -s lvm $WDIR/sbin/vgchange\n"
#| "  ln -s lvm $WDIR/sbin/vgcreate\n"
#| "  ln -s lvm $WDIR/sbin/vgscan\n"
#| "  ln -s lvm $WDIR/sbin/vgrename\n"
#| "  ln -s lvm $WDIR/sbin/vgck\n"
#| "  # Conf file(s)\n"
#| "  cp -a /etc/lvm $WDIR/etc\n"
#| "fi\n"
#| "\n"
#| "# Install libraries\n"
#| "sort $unsorted | uniq | while read library ; do\n"
#| "# linux-vdso and linux-gate are pseudo libraries and do not correspond to a file\n"
#| "# libsystemd-shared is in /lib/systemd, so it is not found by copy, and\n"
#| "# it is copied below anyway\n"
#| "  if [[ \"$library\" == linux-vdso.so.1 ]] ||\n"
#| "     [[ \"$library\" == linux-gate.so.1 ]] ||\n"
#| "     [[ \"$library\" == libsystemd-shared* ]]; then\n"
#| "    continue\n"
#| "  fi\n"
#| "\n"
#| "  copy $library lib\n"
#| "done\n"
#| "\n"
#| "if [ -d /lib/udev ]; then\n"
#| "  cp -a /lib/udev $WDIR/lib\n"
#| "fi\n"
#| "if [ -d /lib/systemd ]; then\n"
#| "  cp -a /lib/systemd $WDIR/lib\n"
#| "fi\n"
#| "if [ -d /lib/elogind ]; then\n"
#| "  cp -a /lib/elogind $WDIR/lib\n"
#| "fi\n"
#| "\n"
#| "# Install the kernel modules if requested\n"
#| "if [ -n \"$KERNEL_VERSION\" ]; then\n"
#| "  find                                                                        \\\n"
#| "     /lib/modules/$KERNEL_VERSION/kernel/{crypto,fs,lib}                      \\\n"
#| "     /lib/modules/$KERNEL_VERSION/kernel/drivers/{block,ata,md,firewire}      \\\n"
#| "     /lib/modules/$KERNEL_VERSION/kernel/drivers/{scsi,message,pcmcia,virtio} \\\n"
#| "     /lib/modules/$KERNEL_VERSION/kernel/drivers/usb/{host,storage}           \\\n"
#| "     -type f 2&gt; /dev/null | cpio --make-directories -p --quiet $WDIR\n"
#| "\n"
#| "  cp /lib/modules/$KERNEL_VERSION/modules.{builtin,order}                     \\\n"
#| "            $WDIR/lib/modules/$KERNEL_VERSION\n"
#| "\n"
#| "  depmod -b $WDIR $KERNEL_VERSION\n"
#| "fi\n"
#| "\n"
#| "( cd $WDIR ; find . | cpio -o -H newc --quiet | gzip -9 ) &gt; $INITRAMFS_FILE\n"
#| "\n"
#| "# Prepare early loading of microcode if available\n"
#| "if ls /lib/firmware/intel-ucode/* &gt;/dev/null 2&gt;&amp;1 ||\n"
#| "   ls /lib/firmware/amd-ucode/*   &gt;/dev/null 2&gt;&amp;1; then\n"
#| "\n"
#| "# first empty WDIR to reuse it\n"
#| "  rm -r $WDIR/*\n"
#| "\n"
#| "  DSTDIR=$WDIR/kernel/x86/microcode\n"
#| "  mkdir -p $DSTDIR\n"
#| "\n"
#| "  if [ -d /lib/firmware/amd-ucode ]; then\n"
#| "    cat /lib/firmware/amd-ucode/microcode_amd*.bin &gt; $DSTDIR/AuthenticAMD.bin\n"
#| "  fi\n"
#| "\n"
#| "  if [ -d /lib/firmware/intel-ucode ]; then\n"
#| "    cat /lib/firmware/intel-ucode/* &gt; $DSTDIR/GenuineIntel.bin\n"
#| "  fi\n"
#| "\n"
#| "  ( cd $WDIR; find . | cpio -o -H newc --quiet ) &gt; microcode.img\n"
#| "  cat microcode.img $INITRAMFS_FILE &gt; tmpfile\n"
#| "  mv tmpfile $INITRAMFS_FILE\n"
#| "  rm microcode.img\n"
#| "fi\n"
#| "\n"
#| "# Remove the temporary directories and files\n"
#| "rm -rf $WDIR $unsorted\n"
#| "printf \"done.\\n\"\n"
#| "</literal>\n"
#| "EOF\n"
#| "\n"
#| "chmod 0755 /sbin/mkinitramfs</userinput>"
msgid ""
"<userinput>cat &gt; /sbin/mkinitramfs &lt;&lt; \"EOF\"\n"
"<literal>#!/bin/bash\n"
"# This file based in part on the mkinitramfs script for the LFS LiveCD\n"
"# written by Alexander E. Patrakov and Jeremy Huntwork.\n"
"\n"
"copy()\n"
"{\n"
"  local file\n"
"\n"
"  if [ \"$2\" = \"lib\" ]; then\n"
"    file=$(PATH=/lib:/usr/lib type -p $1)\n"
"  else\n"
"    file=$(type -p $1)\n"
"  fi\n"
"\n"
"  if [ -n \"$file\" ] ; then\n"
"    cp $file $WDIR/$2\n"
"  else\n"
"    echo \"Missing required file: $1 for directory $2\"\n"
"    rm -rf $WDIR\n"
"    exit 1\n"
"  fi\n"
"}\n"
"\n"
"if [ -z $1 ] ; then\n"
"  INITRAMFS_FILE=initrd.img-no-kmods\n"
"else\n"
"  KERNEL_VERSION=$1\n"
"  INITRAMFS_FILE=initrd.img-$KERNEL_VERSION\n"
"fi\n"
"\n"
"if [ -n \"$KERNEL_VERSION\" ] &amp;&amp; [ ! -d \"/lib/modules/$1\" ] ; then\n"
"  echo \"No modules directory named $1\"\n"
"  exit 1\n"
"fi\n"
"\n"
"printf \"Creating $INITRAMFS_FILE... \"\n"
"\n"
"binfiles=\"sh cat cp dd killall ls mkdir mknod mount \"\n"
"binfiles=\"$binfiles umount sed sleep ln rm uname\"\n"
"binfiles=\"$binfiles readlink basename\"\n"
"\n"
"# Systemd installs udevadm in /bin. Other udev implementations have it in /sbin\n"
"if [ -x /bin/udevadm ] ; then binfiles=\"$binfiles udevadm\"; fi\n"
"\n"
"sbinfiles=\"modprobe blkid switch_root\"\n"
"\n"
"#Optional files and locations\n"
"for f in mdadm mdmon udevd udevadm; do\n"
"  if [ -x /sbin/$f ] ; then sbinfiles=\"$sbinfiles $f\"; fi\n"
"done\n"
"\n"
"unsorted=$(mktemp /tmp/unsorted.XXXXXXXXXX)\n"
"\n"
"DATADIR=/usr/share/mkinitramfs\n"
"INITIN=init.in\n"
"\n"
"# Create a temporary working directory\n"
"WDIR=$(mktemp -d /tmp/initrd-work.XXXXXXXXXX)\n"
"\n"
"# Create base directory structure\n"
"mkdir -p $WDIR/{bin,dev,lib/firmware,run,sbin,sys,proc,usr}\n"
"mkdir -p $WDIR/etc/{modprobe.d,udev/rules.d}\n"
"touch $WDIR/etc/modprobe.d/modprobe.conf\n"
"ln -s lib $WDIR/lib64\n"
"ln -s ../bin $WDIR/usr/bin\n"
"\n"
"# Create necessary device nodes\n"
"mknod -m 640 $WDIR/dev/console c 5 1\n"
"mknod -m 664 $WDIR/dev/null    c 1 3\n"
"\n"
"# Install the udev configuration files\n"
"if [ -f /etc/udev/udev.conf ]; then\n"
"  cp /etc/udev/udev.conf $WDIR/etc/udev/udev.conf\n"
"fi\n"
"\n"
"for file in $(find /etc/udev/rules.d/ -type f) ; do\n"
"  cp $file $WDIR/etc/udev/rules.d\n"
"done\n"
"\n"
"# Install any firmware present\n"
"cp -a /lib/firmware $WDIR/lib\n"
"\n"
"# Copy the RAID configuration file if present\n"
"if [ -f /etc/mdadm.conf ] ; then\n"
"  cp /etc/mdadm.conf $WDIR/etc\n"
"fi\n"
"\n"
"# Install the init file\n"
"install -m0755 $DATADIR/$INITIN $WDIR/init\n"
"\n"
"if [  -n \"$KERNEL_VERSION\" ] ; then\n"
"  if [ -x /bin/kmod ] ; then\n"
"    binfiles=\"$binfiles kmod\"\n"
"  else\n"
"    binfiles=\"$binfiles lsmod\"\n"
"    sbinfiles=\"$sbinfiles insmod\"\n"
"  fi\n"
"fi\n"
"\n"
"# Install basic binaries\n"
"for f in $binfiles ; do\n"
"  if [ -e /bin/$f ]; then d=\"/bin\"; else d=\"/usr/bin\"; fi\n"
"  ldd $d/$f | sed \"s/\\t//\" | cut -d \" \" -f1 &gt;&gt; $unsorted\n"
"  copy $d/$f bin\n"
"done\n"
"\n"
"# Add lvm if present\n"
"if [ -x /sbin/lvm ] ; then sbinfiles=\"$sbinfiles lvm dmsetup\"; fi\n"
"\n"
"# Add mdadm if present\n"
"if [ -x /sbin/mdadm ] ; then sbinfiles=\"$sbinfiles mdadm\"; fi\n"
"\n"
"# Add udevd if present in /sbin (newer versions of udev have it in\n"
"# /lib/udev)\n"
"if [ -x /sbin/udevd ] ; then sbinfiles=\"$sbinfiles udevd\"; fi\n"
"\n"
"for f in $sbinfiles ; do\n"
"  ldd /sbin/$f | sed \"s/\\t//\" | cut -d \" \" -f1 &gt;&gt; $unsorted\n"
"  copy $f sbin\n"
"done\n"
"\n"
"# Add udevd libraries if not in /sbin\n"
"if [ -x /lib/udev/udevd ] ; then\n"
"  ldd /lib/udev/udevd | sed \"s/\\t//\" | cut -d \" \" -f1 &gt;&gt; $unsorted\n"
"elif [ -x /lib/systemd/systemd-udevd ] ; then\n"
"  ldd /lib/systemd/systemd-udevd | sed \"s/\\t//\" | cut -d \" \" -f1 &gt;&gt; $unsorted\n"
"fi\n"
"\n"
"# Add module symlinks if appropriate\n"
"if [ -n \"$KERNEL_VERSION\" ] &amp;&amp; [ -x /bin/kmod ] ; then\n"
"  ln -s kmod $WDIR/bin/lsmod\n"
"  ln -s kmod $WDIR/bin/insmod\n"
"fi\n"
"\n"
"ln -s bash $WDIR/bin/sh\n"
"\n"
"# Add lvm symlinks if appropriate\n"
"# Also copy the lvm.conf file\n"
"if  [ -x /sbin/lvm ] ; then\n"
"  ln -s lvm $WDIR/sbin/lvchange\n"
"  ln -s lvm $WDIR/sbin/lvrename\n"
"  ln -s lvm $WDIR/sbin/lvextend\n"
"  ln -s lvm $WDIR/sbin/lvcreate\n"
"  ln -s lvm $WDIR/sbin/lvdisplay\n"
"  ln -s lvm $WDIR/sbin/lvscan\n"
"\n"
"  ln -s lvm $WDIR/sbin/pvchange\n"
"  ln -s lvm $WDIR/sbin/pvck\n"
"  ln -s lvm $WDIR/sbin/pvcreate\n"
"  ln -s lvm $WDIR/sbin/pvdisplay\n"
"  ln -s lvm $WDIR/sbin/pvscan\n"
"\n"
"  ln -s lvm $WDIR/sbin/vgchange\n"
"  ln -s lvm $WDIR/sbin/vgcreate\n"
"  ln -s lvm $WDIR/sbin/vgscan\n"
"  ln -s lvm $WDIR/sbin/vgrename\n"
"  ln -s lvm $WDIR/sbin/vgck\n"
"  # Conf file(s)\n"
"  cp -a /etc/lvm $WDIR/etc\n"
"fi\n"
"\n"
"# Install libraries\n"
"sort $unsorted | uniq | while read library ; do\n"
"# linux-vdso and linux-gate are pseudo libraries and do not correspond to a file\n"
"# libsystemd-shared is in /lib/systemd, so it is not found by copy, and\n"
"# it is copied below anyway\n"
"  if [[ \"$library\" == linux-vdso.so.1 ]] ||\n"
"     [[ \"$library\" == linux-gate.so.1 ]] ||\n"
"     [[ \"$library\" == libsystemd-shared* ]]; then\n"
"    continue\n"
"  fi\n"
"\n"
"  copy $library lib\n"
"done\n"
"\n"
"if [ -d /lib/udev ]; then\n"
"  cp -a /lib/udev $WDIR/lib\n"
"fi\n"
"if [ -d /lib/systemd ]; then\n"
"  cp -a /lib/systemd $WDIR/lib\n"
"fi\n"
"if [ -d /lib/elogind ]; then\n"
"  cp -a /lib/elogind $WDIR/lib\n"
"fi\n"
"\n"
"# Install the kernel modules if requested\n"
"if [ -n \"$KERNEL_VERSION\" ]; then\n"
"  find                                                                        \\\n"
"     /lib/modules/$KERNEL_VERSION/kernel/{crypto,fs,lib}                      \\\n"
"     /lib/modules/$KERNEL_VERSION/kernel/drivers/{block,ata,md,firewire}      \\\n"
"     /lib/modules/$KERNEL_VERSION/kernel/drivers/{scsi,message,pcmcia,virtio} \\\n"
"     /lib/modules/$KERNEL_VERSION/kernel/drivers/usb/{host,storage}           \\\n"
"     -type f 2&gt; /dev/null | cpio --make-directories -p --quiet $WDIR\n"
"\n"
"  cp /lib/modules/$KERNEL_VERSION/modules.{builtin,order}                     \\\n"
"            $WDIR/lib/modules/$KERNEL_VERSION\n"
"\n"
"  depmod -b $WDIR $KERNEL_VERSION\n"
"fi\n"
"\n"
"( cd $WDIR ; find . | cpio -o -H newc --quiet | gzip -9 ) &gt; $INITRAMFS_FILE\n"
"\n"
"# Prepare early loading of microcode if available\n"
"if ls /lib/firmware/intel-ucode/* &gt;/dev/null 2&gt;&amp;1 ||\n"
"   ls /lib/firmware/amd-ucode/*   &gt;/dev/null 2&gt;&amp;1; then\n"
"\n"
"# first empty WDIR to reuse it\n"
"  rm -r $WDIR/*\n"
"\n"
"  DSTDIR=$WDIR/kernel/x86/microcode\n"
"  mkdir -p $DSTDIR\n"
"\n"
"  if [ -d /lib/firmware/amd-ucode ]; then\n"
"    cat /lib/firmware/amd-ucode/microcode_amd*.bin &gt; $DSTDIR/AuthenticAMD.bin\n"
"  fi\n"
"\n"
"  if [ -d /lib/firmware/intel-ucode ]; then\n"
"    cat /lib/firmware/intel-ucode/* &gt; $DSTDIR/GenuineIntel.bin\n"
"  fi\n"
"\n"
"  ( cd $WDIR; find . | cpio -o -H newc --quiet ) &gt; microcode.img\n"
"  cat microcode.img $INITRAMFS_FILE &gt; tmpfile\n"
"  mv tmpfile $INITRAMFS_FILE\n"
"  rm microcode.img\n"
"fi\n"
"\n"
"# Remove the temporary directories and files\n"
"rm -rf $WDIR $unsorted\n"
"printf \"done.\\n\"\n"
"</literal>\n"
"EOF\n"
"\n"
"chmod 0755 /sbin/mkinitramfs</userinput>"
msgstr ""
"<userinput>cat &gt; /sbin/mkinitramfs &lt;&lt; \"EOF\"\n"
"<literal>#!/bin/bash\n"
"# This file based in part on the mkinitramfs script for the LFS LiveCD\n"
"# written by Alexander E. Patrakov and Jeremy Huntwork.\n"
"\n"
"copy()\n"
"{\n"
"  local file\n"
"\n"
"  if [ \"$2\" = \"lib\" ]; then\n"
"    file=$(PATH=/lib:/usr/lib type -p $1)\n"
"  else\n"
"    file=$(type -p $1)\n"
"  fi\n"
"\n"
"  if [ -n \"$file\" ] ; then\n"
"    cp $file $WDIR/$2\n"
"  else\n"
"    echo \"Missing required file: $1 for directory $2\"\n"
"    rm -rf $WDIR\n"
"    exit 1\n"
"  fi\n"
"}\n"
"\n"
"if [ -z $1 ] ; then\n"
"  INITRAMFS_FILE=initrd.img-no-kmods\n"
"else\n"
"  KERNEL_VERSION=$1\n"
"  INITRAMFS_FILE=initrd.img-$KERNEL_VERSION\n"
"fi\n"
"\n"
"if [ -n \"$KERNEL_VERSION\" ] &amp;&amp; [ ! -d \"/lib/modules/$1\" ] ; then\n"
"  echo \"No modules directory named $1\"\n"
"  exit 1\n"
"fi\n"
"\n"
"printf \"Creating $INITRAMFS_FILE... \"\n"
"\n"
"binfiles=\"sh cat cp dd killall ls mkdir mknod mount \"\n"
"binfiles=\"$binfiles umount sed sleep ln rm uname\"\n"
"binfiles=\"$binfiles readlink basename\"\n"
"\n"
"# Systemd installs udevadm in /bin. Other udev implementations have it in /sbin\n"
"if [ -x /bin/udevadm ] ; then binfiles=\"$binfiles udevadm\"; fi\n"
"\n"
"sbinfiles=\"modprobe blkid switch_root\"\n"
"\n"
"#Optional files and locations\n"
"for f in mdadm mdmon udevd udevadm; do\n"
"  if [ -x /sbin/$f ] ; then sbinfiles=\"$sbinfiles $f\"; fi\n"
"done\n"
"\n"
"unsorted=$(mktemp /tmp/unsorted.XXXXXXXXXX)\n"
"\n"
"DATADIR=/usr/share/mkinitramfs\n"
"INITIN=init.in\n"
"\n"
"# Create a temporary working directory\n"
"WDIR=$(mktemp -d /tmp/initrd-work.XXXXXXXXXX)\n"
"\n"
"# Create base directory structure\n"
"mkdir -p $WDIR/{bin,dev,lib/firmware,run,sbin,sys,proc,usr}\n"
"mkdir -p $WDIR/etc/{modprobe.d,udev/rules.d}\n"
"touch $WDIR/etc/modprobe.d/modprobe.conf\n"
"ln -s lib $WDIR/lib64\n"
"ln -s ../bin $WDIR/usr/bin\n"
"\n"
"# Create necessary device nodes\n"
"mknod -m 640 $WDIR/dev/console c 5 1\n"
"mknod -m 664 $WDIR/dev/null    c 1 3\n"
"\n"
"# Install the udev configuration files\n"
"if [ -f /etc/udev/udev.conf ]; then\n"
"  cp /etc/udev/udev.conf $WDIR/etc/udev/udev.conf\n"
"fi\n"
"\n"
"for file in $(find /etc/udev/rules.d/ -type f) ; do\n"
"  cp $file $WDIR/etc/udev/rules.d\n"
"done\n"
"\n"
"# Install any firmware present\n"
"cp -a /lib/firmware $WDIR/lib\n"
"\n"
"# Copy the RAID configuration file if present\n"
"if [ -f /etc/mdadm.conf ] ; then\n"
"  cp /etc/mdadm.conf $WDIR/etc\n"
"fi\n"
"\n"
"# Install the init file\n"
"install -m0755 $DATADIR/$INITIN $WDIR/init\n"
"\n"
"if [  -n \"$KERNEL_VERSION\" ] ; then\n"
"  if [ -x /bin/kmod ] ; then\n"
"    binfiles=\"$binfiles kmod\"\n"
"  else\n"
"    binfiles=\"$binfiles lsmod\"\n"
"    sbinfiles=\"$sbinfiles insmod\"\n"
"  fi\n"
"fi\n"
"\n"
"# Install basic binaries\n"
"for f in $binfiles ; do\n"
"  if [ -e /bin/$f ]; then d=\"/bin\"; else d=\"/usr/bin\"; fi\n"
"  ldd $d/$f | sed \"s/\\t//\" | cut -d \" \" -f1 &gt;&gt; $unsorted\n"
"  copy $d/$f bin\n"
"done\n"
"\n"
"# Add lvm if present\n"
"if [ -x /sbin/lvm ] ; then sbinfiles=\"$sbinfiles lvm dmsetup\"; fi\n"
"\n"
"# Add mdadm if present\n"
"if [ -x /sbin/mdadm ] ; then sbinfiles=\"$sbinfiles mdadm\"; fi\n"
"\n"
"# Add udevd if present in /sbin (newer versions of udev have it in\n"
"# /lib/udev)\n"
"if [ -x /sbin/udevd ] ; then sbinfiles=\"$sbinfiles udevd\"; fi\n"
"\n"
"for f in $sbinfiles ; do\n"
"  ldd /sbin/$f | sed \"s/\\t//\" | cut -d \" \" -f1 &gt;&gt; $unsorted\n"
"  copy $f sbin\n"
"done\n"
"\n"
"# Add udevd libraries if not in /sbin\n"
"if [ -x /lib/udev/udevd ] ; then\n"
"  ldd /lib/udev/udevd | sed \"s/\\t//\" | cut -d \" \" -f1 &gt;&gt; $unsorted\n"
"elif [ -x /lib/systemd/systemd-udevd ] ; then\n"
"  ldd /lib/systemd/systemd-udevd | sed \"s/\\t//\" | cut -d \" \" -f1 &gt;&gt; $unsorted\n"
"fi\n"
"\n"
"# Add module symlinks if appropriate\n"
"if [ -n \"$KERNEL_VERSION\" ] &amp;&amp; [ -x /bin/kmod ] ; then\n"
"  ln -s kmod $WDIR/bin/lsmod\n"
"  ln -s kmod $WDIR/bin/insmod\n"
"fi\n"
"\n"
"ln -s bash $WDIR/bin/sh\n"
"\n"
"# Add lvm symlinks if appropriate\n"
"# Also copy the lvm.conf file\n"
"if  [ -x /sbin/lvm ] ; then\n"
"  ln -s lvm $WDIR/sbin/lvchange\n"
"  ln -s lvm $WDIR/sbin/lvrename\n"
"  ln -s lvm $WDIR/sbin/lvextend\n"
"  ln -s lvm $WDIR/sbin/lvcreate\n"
"  ln -s lvm $WDIR/sbin/lvdisplay\n"
"  ln -s lvm $WDIR/sbin/lvscan\n"
"\n"
"  ln -s lvm $WDIR/sbin/pvchange\n"
"  ln -s lvm $WDIR/sbin/pvck\n"
"  ln -s lvm $WDIR/sbin/pvcreate\n"
"  ln -s lvm $WDIR/sbin/pvdisplay\n"
"  ln -s lvm $WDIR/sbin/pvscan\n"
"\n"
"  ln -s lvm $WDIR/sbin/vgchange\n"
"  ln -s lvm $WDIR/sbin/vgcreate\n"
"  ln -s lvm $WDIR/sbin/vgscan\n"
"  ln -s lvm $WDIR/sbin/vgrename\n"
"  ln -s lvm $WDIR/sbin/vgck\n"
"  # Conf file(s)\n"
"  cp -a /etc/lvm $WDIR/etc\n"
"fi\n"
"\n"
"# Install libraries\n"
"sort $unsorted | uniq | while read library ; do\n"
"# linux-vdso and linux-gate are pseudo libraries and do not correspond to a file\n"
"# libsystemd-shared is in /lib/systemd, so it is not found by copy, and\n"
"# it is copied below anyway\n"
"  if [[ \"$library\" == linux-vdso.so.1 ]] ||\n"
"     [[ \"$library\" == linux-gate.so.1 ]] ||\n"
"     [[ \"$library\" == libsystemd-shared* ]]; then\n"
"    continue\n"
"  fi\n"
"\n"
"  copy $library lib\n"
"done\n"
"\n"
"if [ -d /lib/udev ]; then\n"
"  cp -a /lib/udev $WDIR/lib\n"
"fi\n"
"if [ -d /lib/systemd ]; then\n"
"  cp -a /lib/systemd $WDIR/lib\n"
"fi\n"
"if [ -d /lib/elogind ]; then\n"
"  cp -a /lib/elogind $WDIR/lib\n"
"fi\n"
"\n"
"# Install the kernel modules if requested\n"
"if [ -n \"$KERNEL_VERSION\" ]; then\n"
"  find                                                                        \\\n"
"     /lib/modules/$KERNEL_VERSION/kernel/{crypto,fs,lib}                      \\\n"
"     /lib/modules/$KERNEL_VERSION/kernel/drivers/{block,ata,md,firewire}      \\\n"
"     /lib/modules/$KERNEL_VERSION/kernel/drivers/{scsi,message,pcmcia,virtio} \\\n"
"     /lib/modules/$KERNEL_VERSION/kernel/drivers/usb/{host,storage}           \\\n"
"     -type f 2&gt; /dev/null | cpio --make-directories -p --quiet $WDIR\n"
"\n"
"  cp /lib/modules/$KERNEL_VERSION/modules.{builtin,order}                     \\\n"
"            $WDIR/lib/modules/$KERNEL_VERSION\n"
"\n"
"  depmod -b $WDIR $KERNEL_VERSION\n"
"fi\n"
"\n"
"( cd $WDIR ; find . | cpio -o -H newc --quiet | gzip -9 ) &gt; $INITRAMFS_FILE\n"
"\n"
"# Prepare early loading of microcode if available\n"
"if ls /lib/firmware/intel-ucode/* &gt;/dev/null 2&gt;&amp;1 ||\n"
"   ls /lib/firmware/amd-ucode/*   &gt;/dev/null 2&gt;&amp;1; then\n"
"\n"
"# first empty WDIR to reuse it\n"
"  rm -r $WDIR/*\n"
"\n"
"  DSTDIR=$WDIR/kernel/x86/microcode\n"
"  mkdir -p $DSTDIR\n"
"\n"
"  if [ -d /lib/firmware/amd-ucode ]; then\n"
"    cat /lib/firmware/amd-ucode/microcode_amd*.bin &gt; $DSTDIR/AuthenticAMD.bin\n"
"  fi\n"
"\n"
"  if [ -d /lib/firmware/intel-ucode ]; then\n"
"    cat /lib/firmware/intel-ucode/* &gt; $DSTDIR/GenuineIntel.bin\n"
"  fi\n"
"\n"
"  ( cd $WDIR; find . | cpio -o -H newc --quiet ) &gt; microcode.img\n"
"  cat microcode.img $INITRAMFS_FILE &gt; tmpfile\n"
"  mv tmpfile $INITRAMFS_FILE\n"
"  rm microcode.img\n"
"fi\n"
"\n"
"# Remove the temporary directories and files\n"
"rm -rf $WDIR $unsorted\n"
"printf \"done.\\n\"\n"
"</literal>\n"
"EOF\n"
"\n"
"chmod 0755 /sbin/mkinitramfs</userinput>"

#. type: Content of: <sect1><sect2><screen>
#: blfs-en/postlfs/filesystems/initramfs.xml:304
#, no-wrap
#| msgid ""
#| "<userinput>mkdir -p /usr/share/mkinitramfs &amp;&amp;\n"
#| "cat &gt; /usr/share/mkinitramfs/init.in &lt;&lt; \"EOF\"\n"
#| "<literal>#!/bin/sh\n"
#| "\n"
#| "PATH=/bin:/usr/bin:/sbin:/usr/sbin\n"
#| "export PATH\n"
#| "\n"
#| "problem()\n"
#| "{\n"
#| "   printf \"Encountered a problem!\\n\\nDropping you to a shell.\\n\\n\"\n"
#| "   sh\n"
#| "}\n"
#| "\n"
#| "no_device()\n"
#| "{\n"
#| "   printf \"The device %s, which is supposed to contain the\\n\" $1\n"
#| "   printf \"root file system, does not exist.\\n\"\n"
#| "   printf \"Please fix this problem and exit this shell.\\n\\n\"\n"
#| "}\n"
#| "\n"
#| "no_mount()\n"
#| "{\n"
#| "   printf \"Could not mount device %s\\n\" $1\n"
#| "   printf \"Sleeping forever. Please reboot and fix the kernel command line.\\n\\n\"\n"
#| "   printf \"Maybe the device is formatted with an unsupported file system?\\n\\n\"\n"
#| "   printf \"Or maybe filesystem type autodetection went wrong, in which case\\n\"\n"
#| "   printf \"you should add the rootfstype=... parameter to the kernel command line.\\n\\n\"\n"
#| "   printf \"Available partitions:\\n\"\n"
#| "}\n"
#| "\n"
#| "do_mount_root()\n"
#| "{\n"
#| "   mkdir /.root\n"
#| "   [ -n \"$rootflags\" ] &amp;&amp; rootflags=\"$rootflags,\"\n"
#| "   rootflags=\"$rootflags$ro\"\n"
#| "\n"
#| "   case \"$root\" in\n"
#| "      /dev/* ) device=$root ;;\n"
#| "      UUID=* ) eval $root; device=\"/dev/disk/by-uuid/$UUID\"  ;;\n"
#| "      LABEL=*) eval $root; device=\"/dev/disk/by-label/$LABEL\" ;;\n"
#| "      \"\"     ) echo \"No root device specified.\" ; problem    ;;\n"
#| "   esac\n"
#| "\n"
#| "   while [ ! -b \"$device\" ] ; do\n"
#| "       no_device $device\n"
#| "       problem\n"
#| "   done\n"
#| "\n"
#| "   if ! mount -n -t \"$rootfstype\" -o \"$rootflags\" \"$device\" /.root ; then\n"
#| "       no_mount $device\n"
#| "       cat /proc/partitions\n"
#| "       while true ; do sleep 10000 ; done\n"
#| "   else\n"
#| "       echo \"Successfully mounted device $root\"\n"
#| "   fi\n"
#| "}\n"
#| "\n"
#| "do_try_resume()\n"
#| "{\n"
#| "   case \"$resume\" in\n"
#| "      UUID=* ) eval $resume; resume=\"/dev/disk/by-uuid/$UUID\"  ;;\n"
#| "      LABEL=*) eval $resume; resume=\"/dev/disk/by-label/$LABEL\" ;;\n"
#| "   esac\n"
#| "\n"
#| "   if $noresume || ! [ -b \"$resume\" ]; then return; fi\n"
#| "\n"
#| "   ls -lH \"$resume\" | ( read x x x x maj min x\n"
#| "       echo -n ${maj%,}:$min &gt; /sys/power/resume )\n"
#| "}\n"
#| "\n"
#| "init=/sbin/init\n"
#| "root=\n"
#| "rootdelay=\n"
#| "rootfstype=auto\n"
#| "ro=\"ro\"\n"
#| "rootflags=\n"
#| "device=\n"
#| "resume=\n"
#| "noresume=false\n"
#| "\n"
#| "mount -n -t devtmpfs devtmpfs /dev\n"
#| "mount -n -t proc     proc     /proc\n"
#| "mount -n -t sysfs    sysfs    /sys\n"
#| "mount -n -t tmpfs    tmpfs    /run\n"
#| "\n"
#| "read -r cmdline &lt; /proc/cmdline\n"
#| "\n"
#| "for param in $cmdline ; do\n"
#| "  case $param in\n"
#| "    init=*      ) init=${param#init=}             ;;\n"
#| "    root=*      ) root=${param#root=}             ;;\n"
#| "    rootdelay=* ) rootdelay=${param#rootdelay=}   ;;\n"
#| "    rootfstype=*) rootfstype=${param#rootfstype=} ;;\n"
#| "    rootflags=* ) rootflags=${param#rootflags=}   ;;\n"
#| "    resume=*    ) resume=${param#resume=}         ;;\n"
#| "    noresume    ) noresume=true                   ;;\n"
#| "    ro          ) ro=\"ro\"                         ;;\n"
#| "    rw          ) ro=\"rw\"                         ;;\n"
#| "  esac\n"
#| "done\n"
#| "\n"
#| "# udevd location depends on version\n"
#| "if [ -x /sbin/udevd ]; then\n"
#| "  UDEVD=/sbin/udevd\n"
#| "elif [ -x /lib/udev/udevd ]; then\n"
#| "  UDEVD=/lib/udev/udevd\n"
#| "elif [ -x /lib/systemd/systemd-udevd ]; then\n"
#| "  UDEVD=/lib/systemd/systemd-udevd\n"
#| "else\n"
#| "  echo \"Cannot find udevd nor systemd-udevd\"\n"
#| "  problem\n"
#| "fi\n"
#| "\n"
#| "${UDEVD} --daemon --resolve-names=never\n"
#| "udevadm trigger\n"
#| "udevadm settle\n"
#| "\n"
#| "if [ -f /etc/mdadm.conf ] ; then mdadm -As                       ; fi\n"
#| "if [ -x /sbin/vgchange  ] ; then /sbin/vgchange -a y &gt; /dev/null ; fi\n"
#| "if [ -n \"$rootdelay\"    ] ; then sleep \"$rootdelay\"              ; fi\n"
#| "\n"
#| "do_try_resume # This function will not return if resuming from disk\n"
#| "do_mount_root\n"
#| "\n"
#| "killall -w ${UDEVD##*/}\n"
#| "\n"
#| "exec switch_root /.root \"$init\" \"$@\"\n"
#| "</literal>\n"
#| "EOF</userinput>"
msgid ""
"<userinput>mkdir -p /usr/share/mkinitramfs &amp;&amp;\n"
"cat &gt; /usr/share/mkinitramfs/init.in &lt;&lt; \"EOF\"\n"
"<literal>#!/bin/sh\n"
"\n"
"PATH=/bin:/usr/bin:/sbin:/usr/sbin\n"
"export PATH\n"
"\n"
"problem()\n"
"{\n"
"   printf \"Encountered a problem!\\n\\nDropping you to a shell.\\n\\n\"\n"
"   sh\n"
"}\n"
"\n"
"no_device()\n"
"{\n"
"   printf \"The device %s, which is supposed to contain the\\n\" $1\n"
"   printf \"root file system, does not exist.\\n\"\n"
"   printf \"Please fix this problem and exit this shell.\\n\\n\"\n"
"}\n"
"\n"
"no_mount()\n"
"{\n"
"   printf \"Could not mount device %s\\n\" $1\n"
"   printf \"Sleeping forever. Please reboot and fix the kernel command line.\\n\\n\"\n"
"   printf \"Maybe the device is formatted with an unsupported file system?\\n\\n\"\n"
"   printf \"Or maybe filesystem type autodetection went wrong, in which case\\n\"\n"
"   printf \"you should add the rootfstype=... parameter to the kernel command line.\\n\\n\"\n"
"   printf \"Available partitions:\\n\"\n"
"}\n"
"\n"
"do_mount_root()\n"
"{\n"
"   mkdir /.root\n"
"   [ -n \"$rootflags\" ] &amp;&amp; rootflags=\"$rootflags,\"\n"
"   rootflags=\"$rootflags$ro\"\n"
"\n"
"   case \"$root\" in\n"
"      /dev/*    ) device=$root ;;\n"
"      UUID=*    ) eval $root; device=\"/dev/disk/by-uuid/$UUID\" ;;\n"
"      PARTUUID=*) eval $root; device=\"/dev/disk/by-partuuid/$PARTUUID\" ;;\n"
"      LABEL=*   ) eval $root; device=\"/dev/disk/by-label/$LABEL\" ;;\n"
"      \"\"        ) echo \"No root device specified.\" ; problem ;;\n"
"   esac\n"
"\n"
"   while [ ! -b \"$device\" ] ; do\n"
"       no_device $device\n"
"       problem\n"
"   done\n"
"\n"
"   if ! mount -n -t \"$rootfstype\" -o \"$rootflags\" \"$device\" /.root ; then\n"
"       no_mount $device\n"
"       cat /proc/partitions\n"
"       while true ; do sleep 10000 ; done\n"
"   else\n"
"       echo \"Successfully mounted device $root\"\n"
"   fi\n"
"}\n"
"\n"
"do_try_resume()\n"
"{\n"
"   case \"$resume\" in\n"
"      UUID=* ) eval $resume; resume=\"/dev/disk/by-uuid/$UUID\"  ;;\n"
"      LABEL=*) eval $resume; resume=\"/dev/disk/by-label/$LABEL\" ;;\n"
"   esac\n"
"\n"
"   if $noresume || ! [ -b \"$resume\" ]; then return; fi\n"
"\n"
"   ls -lH \"$resume\" | ( read x x x x maj min x\n"
"       echo -n ${maj%,}:$min &gt; /sys/power/resume )\n"
"}\n"
"\n"
"init=/sbin/init\n"
"root=\n"
"rootdelay=\n"
"rootfstype=auto\n"
"ro=\"ro\"\n"
"rootflags=\n"
"device=\n"
"resume=\n"
"noresume=false\n"
"\n"
"mount -n -t devtmpfs devtmpfs /dev\n"
"mount -n -t proc     proc     /proc\n"
"mount -n -t sysfs    sysfs    /sys\n"
"mount -n -t tmpfs    tmpfs    /run\n"
"\n"
"read -r cmdline &lt; /proc/cmdline\n"
"\n"
"for param in $cmdline ; do\n"
"  case $param in\n"
"    init=*      ) init=${param#init=}             ;;\n"
"    root=*      ) root=${param#root=}             ;;\n"
"    rootdelay=* ) rootdelay=${param#rootdelay=}   ;;\n"
"    rootfstype=*) rootfstype=${param#rootfstype=} ;;\n"
"    rootflags=* ) rootflags=${param#rootflags=}   ;;\n"
"    resume=*    ) resume=${param#resume=}         ;;\n"
"    noresume    ) noresume=true                   ;;\n"
"    ro          ) ro=\"ro\"                         ;;\n"
"    rw          ) ro=\"rw\"                         ;;\n"
"  esac\n"
"done\n"
"\n"
"# udevd location depends on version\n"
"if [ -x /sbin/udevd ]; then\n"
"  UDEVD=/sbin/udevd\n"
"elif [ -x /lib/udev/udevd ]; then\n"
"  UDEVD=/lib/udev/udevd\n"
"elif [ -x /lib/systemd/systemd-udevd ]; then\n"
"  UDEVD=/lib/systemd/systemd-udevd\n"
"else\n"
"  echo \"Cannot find udevd nor systemd-udevd\"\n"
"  problem\n"
"fi\n"
"\n"
"${UDEVD} --daemon --resolve-names=never\n"
"udevadm trigger\n"
"udevadm settle\n"
"\n"
"if [ -f /etc/mdadm.conf ] ; then mdadm -As                       ; fi\n"
"if [ -x /sbin/vgchange  ] ; then /sbin/vgchange -a y &gt; /dev/null ; fi\n"
"if [ -n \"$rootdelay\"    ] ; then sleep \"$rootdelay\"              ; fi\n"
"\n"
"do_try_resume # This function will not return if resuming from disk\n"
"do_mount_root\n"
"\n"
"killall -w ${UDEVD##*/}\n"
"\n"
"exec switch_root /.root \"$init\" \"$@\"\n"
"</literal>\n"
"EOF</userinput>"
msgstr ""
"<userinput>mkdir -p /usr/share/mkinitramfs &amp;&amp;\n"
"cat &gt; /usr/share/mkinitramfs/init.in &lt;&lt; \"EOF\"\n"
"<literal>#!/bin/sh\n"
"\n"
"PATH=/bin:/usr/bin:/sbin:/usr/sbin\n"
"export PATH\n"
"\n"
"problem()\n"
"{\n"
"   printf \"Encountered a problem!\\n\\nDropping you to a shell.\\n\\n\"\n"
"   sh\n"
"}\n"
"\n"
"no_device()\n"
"{\n"
"   printf \"The device %s, which is supposed to contain the\\n\" $1\n"
"   printf \"root file system, does not exist.\\n\"\n"
"   printf \"Please fix this problem and exit this shell.\\n\\n\"\n"
"}\n"
"\n"
"no_mount()\n"
"{\n"
"   printf \"Could not mount device %s\\n\" $1\n"
"   printf \"Sleeping forever. Please reboot and fix the kernel command line.\\n\\n\"\n"
"   printf \"Maybe the device is formatted with an unsupported file system?\\n\\n\"\n"
"   printf \"Or maybe filesystem type autodetection went wrong, in which case\\n\"\n"
"   printf \"you should add the rootfstype=... parameter to the kernel command line.\\n\\n\"\n"
"   printf \"Available partitions:\\n\"\n"
"}\n"
"\n"
"do_mount_root()\n"
"{\n"
"   mkdir /.root\n"
"   [ -n \"$rootflags\" ] &amp;&amp; rootflags=\"$rootflags,\"\n"
"   rootflags=\"$rootflags$ro\"\n"
"\n"
"   case \"$root\" in\n"
"      /dev/*    ) device=$root ;;\n"
"      UUID=*    ) eval $root; device=\"/dev/disk/by-uuid/$UUID\" ;;\n"
"      PARTUUID=*) eval $root; device=\"/dev/disk/by-partuuid/$PARTUUID\" ;;\n"
"      LABEL=*   ) eval $root; device=\"/dev/disk/by-label/$LABEL\" ;;\n"
"      \"\"        ) echo \"No root device specified.\" ; problem ;;\n"
"   esac\n"
"\n"
"   while [ ! -b \"$device\" ] ; do\n"
"       no_device $device\n"
"       problem\n"
"   done\n"
"\n"
"   if ! mount -n -t \"$rootfstype\" -o \"$rootflags\" \"$device\" /.root ; then\n"
"       no_mount $device\n"
"       cat /proc/partitions\n"
"       while true ; do sleep 10000 ; done\n"
"   else\n"
"       echo \"Successfully mounted device $root\"\n"
"   fi\n"
"}\n"
"\n"
"do_try_resume()\n"
"{\n"
"   case \"$resume\" in\n"
"      UUID=* ) eval $resume; resume=\"/dev/disk/by-uuid/$UUID\"  ;;\n"
"      LABEL=*) eval $resume; resume=\"/dev/disk/by-label/$LABEL\" ;;\n"
"   esac\n"
"\n"
"   if $noresume || ! [ -b \"$resume\" ]; then return; fi\n"
"\n"
"   ls -lH \"$resume\" | ( read x x x x maj min x\n"
"       echo -n ${maj%,}:$min &gt; /sys/power/resume )\n"
"}\n"
"\n"
"init=/sbin/init\n"
"root=\n"
"rootdelay=\n"
"rootfstype=auto\n"
"ro=\"ro\"\n"
"rootflags=\n"
"device=\n"
"resume=\n"
"noresume=false\n"
"\n"
"mount -n -t devtmpfs devtmpfs /dev\n"
"mount -n -t proc     proc     /proc\n"
"mount -n -t sysfs    sysfs    /sys\n"
"mount -n -t tmpfs    tmpfs    /run\n"
"\n"
"read -r cmdline &lt; /proc/cmdline\n"
"\n"
"for param in $cmdline ; do\n"
"  case $param in\n"
"    init=*      ) init=${param#init=}             ;;\n"
"    root=*      ) root=${param#root=}             ;;\n"
"    rootdelay=* ) rootdelay=${param#rootdelay=}   ;;\n"
"    rootfstype=*) rootfstype=${param#rootfstype=} ;;\n"
"    rootflags=* ) rootflags=${param#rootflags=}   ;;\n"
"    resume=*    ) resume=${param#resume=}         ;;\n"
"    noresume    ) noresume=true                   ;;\n"
"    ro          ) ro=\"ro\"                         ;;\n"
"    rw          ) ro=\"rw\"                         ;;\n"
"  esac\n"
"done\n"
"\n"
"# udevd location depends on version\n"
"if [ -x /sbin/udevd ]; then\n"
"  UDEVD=/sbin/udevd\n"
"elif [ -x /lib/udev/udevd ]; then\n"
"  UDEVD=/lib/udev/udevd\n"
"elif [ -x /lib/systemd/systemd-udevd ]; then\n"
"  UDEVD=/lib/systemd/systemd-udevd\n"
"else\n"
"  echo \"Cannot find udevd nor systemd-udevd\"\n"
"  problem\n"
"fi\n"
"\n"
"${UDEVD} --daemon --resolve-names=never\n"
"udevadm trigger\n"
"udevadm settle\n"
"\n"
"if [ -f /etc/mdadm.conf ] ; then mdadm -As                       ; fi\n"
"if [ -x /sbin/vgchange  ] ; then /sbin/vgchange -a y &gt; /dev/null ; fi\n"
"if [ -n \"$rootdelay\"    ] ; then sleep \"$rootdelay\"              ; fi\n"
"\n"
"do_try_resume # This function will not return if resuming from disk\n"
"do_mount_root\n"
"\n"
"killall -w ${UDEVD##*/}\n"
"\n"
"exec switch_root /.root \"$init\" \"$@\"\n"
"</literal>\n"
"EOF</userinput>"

#. type: Content of: <sect1><sect2><title>
#: blfs-en/postlfs/filesystems/initramfs.xml:438
msgid "Using an initramfs"
msgstr "Utilisation d'un initramfs"

#. type: Content of: <sect1><sect2><bridgehead>
#: blfs-en/postlfs/filesystems/initramfs.xml:440
msgid "Required Runtime Dependency"
msgstr "Dépendance d'exécution requise"

#. type: Content of: <sect1><sect2><para>
#: blfs-en/postlfs/filesystems/initramfs.xml:443
msgid "<xref role=\"runtime\" linkend=\"cpio\"/>"
msgstr "<xref role=\"runtime\" linkend=\"cpio\"/>"

#. type: Content of: <sect1><sect2><bridgehead>
#: blfs-en/postlfs/filesystems/initramfs.xml:446
msgid "Other Runtime Dependencies"
msgstr "Dépendances de Other Runtime"

#. type: Content of: <sect1><sect2><para>
#: blfs-en/postlfs/filesystems/initramfs.xml:449
msgid ""
"<xref role=\"runtime\" linkend=\"lvm2\"/> and/or <xref role=\"runtime\" "
"linkend=\"mdadm\"/> must be installed before generating the initramfs, if "
"the system partition uses them."
msgstr ""
"<xref role=\"runtime\" linkend=\"lvm2\"/> et <xref role=\"runtime\" "
"linkend=\"mdadm\"/> doivent être installés avant de générer l'initramfs, si "
"les partitions du système les utilise."

#. type: Content of: <sect1><sect2><para>
#: blfs-en/postlfs/filesystems/initramfs.xml:454
msgid "User Notes: <ulink url=\"&blfs-wiki;/initramfs\"/>"
msgstr "Notes utilisateur&nbsp;: <ulink url=\"&blfs-wiki;/initramfs\"/>"

#. type: Content of: <sect1><sect2><para>
#: blfs-en/postlfs/filesystems/initramfs.xml:460
msgid ""
"To build an initramfs, run the following as the <systemitem "
"class=\"username\">root</systemitem> user:"
msgstr ""
"Pour construire un initramfs, lancer ce qui suit en tant qu'utilisateur "
"<systemitem class=\"username\">root</systemitem>&nbsp;:"

#. type: Content of: <sect1><sect2><screen>
#: blfs-en/postlfs/filesystems/initramfs.xml:464
#, no-wrap
msgid "<userinput>mkinitramfs [KERNEL VERSION]</userinput>"
msgstr "<userinput>mkinitramfs [KERNEL VERSION]</userinput>"

#. type: Content of: <sect1><sect2><para>
#: blfs-en/postlfs/filesystems/initramfs.xml:467
msgid ""
"The optional argument is the directory where the appropriate kernel modules "
"are located. This must be a subdirectory of <filename class='directory'> "
"/lib/modules</filename>.  If no modules are specified, then the initramfs is"
" named <emphasis>initrd.img-no-kmods</emphasis>.  If a kernel version is "
"specified, the initrd is named "
"<emphasis>initrd.img-$KERNEL_VERSION</emphasis> and is only appropriate for "
"the specific kernel specified. The output file will be placed in the current"
" directory."
msgstr ""
"L'argument facultatif est le répertoire où les modules appropriés du noyau "
"sont enregistrés.  Cela peut être un sous-répertoire de <filename "
"class='directory'> /lib/modules</filename>.  Si aucun module n'est spécifié,"
" alors l'initramfs est appelé <emphasis>initrd.img-no-kmods</emphasis>.  Si "
"une version du noyau est précisé, le fichier initrd est appelé "
"<emphasis>initrd.img-$KERNEL_VERSION</emphasis> et est seulement destiné "
"pour le noyau spécifiquement précisé. Les fichiers de sortie seront "
"enregistrés dans le répertoire courant."

#. type: Content of: <sect1><sect2><para>
#: blfs-en/postlfs/filesystems/initramfs.xml:478
msgid ""
"If early loading of microcode is needed (see <xref linkend=\"cpu-"
"microcode\"/>), you can install the appropriate blob or container in "
"<filename class=\"directory\">/lib/firmware</filename>.  It will be "
"automatically added to the initrd when running "
"<command>mkinitramfs</command>."
msgstr ""
"Si vous avez besoin du chargement de microcode au plus tôt (voir <xref "
"linkend=\"cpu-microcode\"/>), vous pouvez installer le blob ou le conteneur "
"approprié dans <filename class=\"directory\">/lib/firmware</filename>. Il "
"sera automatiquement ajouté à l'initrd quand vous lancerez "
"<command>mkinitfs</command>."

#. type: Content of: <sect1><sect2><para>
#: blfs-en/postlfs/filesystems/initramfs.xml:486
msgid ""
"After generating the initrd, copy it to the <filename "
"class='directory'>/boot</filename> directory."
msgstr ""
"Après avoir généré le fichier initrd, copiez-le dans le répertoire <filename"
" class='directory'>/boot</filename>."

#. type: Content of: <sect1><sect2><para>
#: blfs-en/postlfs/filesystems/initramfs.xml:491
msgid ""
"Now edit <filename>/boot/grub/grub.cfg</filename> and add a new menuentry.  "
"Below are several examples."
msgstr ""
"Maintenant éditez <filename>/boot/grub/grub.cfg</filename> et ajoutez une "
"nouvelle entrée dans le menu. En dessous, plusieurs exemples sont présentés."

#. type: Content of: <sect1><sect2><screen>
#: blfs-en/postlfs/filesystems/initramfs.xml:495
#, no-wrap
msgid ""
"<userinput># Generic initramfs and root fs identified by UUID\n"
"menuentry \"LFS Dev (LFS-7.0-Feb14) initrd, Linux 3.0.4\"\n"
"{\n"
"  linux  /vmlinuz-3.0.4-lfs-20120214 root=UUID=54b934a9-302d-415e-ac11-4988408eb0a8 ro\n"
"  initrd /initrd.img-no-kmods\n"
"}</userinput>"
msgstr ""
"<userinput># Generic initramfs and root fs identified by UUID\n"
"menuentry \"LFS Dev (LFS-7.0-Feb14) initrd, Linux 3.0.4\"\n"
"{\n"
"  linux  /vmlinuz-3.0.4-lfs-20120214 root=UUID=54b934a9-302d-415e-ac11-4988408eb0a8 ro\n"
"  initrd /initrd.img-no-kmods\n"
"}</userinput>"

#. type: Content of: <sect1><sect2><screen>
#: blfs-en/postlfs/filesystems/initramfs.xml:502
#, no-wrap
msgid ""
"<userinput># Generic initramfs and root fs on LVM partition\n"
"menuentry \"LFS Dev (LFS-7.0-Feb18) initrd lvm, Linux 3.0.4\"\n"
"{\n"
"  linux  /vmlinuz-3.0.4-lfs-20120218 root=/dev/mapper/myroot ro\n"
"  initrd /initrd.img-no-kmods\n"
"}</userinput>"
msgstr ""
"<userinput># Generic initramfs and root fs on LVM partition\n"
"menuentry \"LFS Dev (LFS-7.0-Feb18) initrd lvm, Linux 3.0.4\"\n"
"{\n"
"  linux  /vmlinuz-3.0.4-lfs-20120218 root=/dev/mapper/myroot ro\n"
"  initrd /initrd.img-no-kmods\n"
"}</userinput>"

#. type: Content of: <sect1><sect2><screen>
#: blfs-en/postlfs/filesystems/initramfs.xml:509
#, no-wrap
msgid ""
"<userinput># Specific initramfs and root fs identified by LABEL\n"
"menuentry \"LFS Dev (LFS-7.1-Feb20) initrd label, Linux 3.2.6\"\n"
"{\n"
"  linux  /vmlinuz-3.2.6-lfs71-120220 root=LABEL=lfs71 ro\n"
"  initrd /initrd.img-3.2.6-lfs71-120220\n"
"}</userinput>"
msgstr ""
"<userinput># Specific initramfs and root fs identified by LABEL\n"
"menuentry \"LFS Dev (LFS-7.1-Feb20) initrd label, Linux 3.2.6\"\n"
"{\n"
"  linux  /vmlinuz-3.2.6-lfs71-120220 root=LABEL=lfs71 ro\n"
"  initrd /initrd.img-3.2.6-lfs71-120220\n"
"}</userinput>"

#. type: Content of: <sect1><sect2><para>
#: blfs-en/postlfs/filesystems/initramfs.xml:517
msgid "Finally, reboot the system and select the desired system."
msgstr "Finalement, redémarrez le système et sélectionnez le système désiré."
