<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../../general.ent">
  %general-entities;
]>

<sect1 id="locale-issues" xreflabel="Problèmes liés aux locales">
  <?dbhtml filename="locale-issues.html"?>

  <sect1info>
<date>$Date$</date></sect1info>

  <title>Problèmes liés aux locales</title>

  <para>Cette page contient des informations sur les problèmes liés aux
locales. Dans les paragraphes suivants, vous trouverez un aperçu générique
de ce qui peut arriver lors de la configuration de votre système pour
diverses locales. Beaucoup (mais pas tous) de problèmes existants liés aux
locales peuvent être classés et rangés sous un des en-têtes ci-dessous. Les
niveaux de sévérité indiqués ci-dessous utilisent les critères
suivants&nbsp;:</para>

  <itemizedlist>
    <listitem>
      <para>Critique&nbsp;: le programme ne remplit pas sa fonction principale.  Une
correction serait très intrusive, il vaut mieux chercher un remplaçant.</para>
    </listitem>
    <listitem>
      <para>Haute&nbsp;: une partie des fonctionnalités fournies par le programme n'est
pas utilisable. Si cette fonctionnalité est nécessaire, il vaut mieux
chercher un remplaçant.</para>
    </listitem>
    <listitem>
      <para>Basse&nbsp;: le programme fonctionne dans tous les cas d'utilisation
classiques, mais certaines fonctionnalités normalement fournies par ses
équivalents sont absentes.</para>
    </listitem>
  </itemizedlist>

  <para>Si un moyen de contournement existe pour un paquet spécifique, il apparaîtra
sur la page de ce paquet. Pour les informations les plus récentes sur les
problèmes liés aux locales pour des paquets individuels, vérifiez les <ulink
url="&blfs-wiki;/BlfsNotes">Notes utilisateur</ulink> sur le Wiki de BLFS.</para>

  <sect2 id="locale-not-valid-option"
         xreflabel="L'encodage nécessaire n'est pas une option valide">

    <title>L'encodage nécessaire n'est pas une option valide du programme</title>

    <para>Sévérité&nbsp;: critique</para>

    <para><!--    <xref linkend="a2ps"/>
 and -->
Certains programmes exigent que l'utilisateur spécifie l'encodage de
caractères pour leurs données d'entrée et de sortie mais ne présentent qu'un
choix limité d'encodages. C'est le cas de l'option <option>-X</option>
d'<xref linkend="enscript"/>, de l'option <option>-input-charset</option> de
<xref linkend="cdrtools"/> non corrigé et des encodages disponibles pour
l'affichage du menu de <xref linkend="Links"/>. Si l'encodage requis n'est
pas dans la liste, le programme devient généralement totalement
inutilisable. Pour les programmes non interactifs, on peut contourner cela
en convertissant le document dans un encodage d'entrée pris en charge avant
de le soumettre au programme.</para>

    <para>Une solution à ce type de problème consiste à implémenter le support
nécessaire de l'encodage manquant avec un correctif du programme d'origine
ou de trouver un remplaçant.</para>

  </sect2>

  <sect2 id="locale-assumed-encoding"
         xreflabel="Le programme présuppose un encodage particulier">

    <title>Le programme suppose l'encodage basé sur la locale de documents externes</title>

    <para>Sévérité&nbsp;: haute pour des documents non-textes, basse pour des
documents textes</para>

    <para>Certains programmes, <xref linkend="nano"/> ou <xref linkend="joe"/> par
exemple, supposent que les documents sont toujours dans l'encodage impliqué
par la locale actuelle. Si cette supposition peut être valide pour les
documents créés par l'utilisateur, ce n'est pas sûr pour ceux
externes. Quand cette supposition échoue, les caractères non-ASCII
s'affichent mal et le document peut devenir illisible.</para>

    <para>Si le document externe est entièrement basé sur du texte, il peut être
converti dans l'encodage de la locale actuelle en utilisant le programme
<command>iconv</command>.</para>

    <para>Pour les documents non textuels, ce n'est pas possible. En effet, la
supposition du programme peut être complètement invalide pour les documents
où le système d'exploitation Microsoft Windows a fixé des normes de
facto. Un exemple de ce problème réside dans les attributs ID3v1 des
fichiers MP3 (voir <ulink url="&blfs-wiki;/ID3v1Coding">la page ID3v1Coding
du Wiki BLFS</ulink> pour plus de détails). Dans ces cas-là, la seule
solution est de trouver un programme remplaçant qui n'a pas ce problème
(comme un qui vous permettra de spécifier l'encodage supposé du document).</para>

    <para>Au sein des paquets BLFS, ce problème s'applique à <xref linkend="nano"/>,
<xref linkend="joe"/> et à tous les lecteurs multimédias à l'exception de
<xref linkend="audacious"/>.</para>

    <para>Un autre problème dans cette catégorie est quand une personne ne peut pas
lire les documents que vous leur avez envoyés car leur système
d'exploitation est programmé pour gérer différemment les encodages de
caractères. Cela peut souvent se produire quand l'autre personne utilise
Microsoft Windows, qui ne fournit qu'un encodage de caractère pour un pays
donné. Cela pose des problèmes avec les documents TeX encodés en UTF-8 créés
sous Linux par exemple. Sur Windows, la plupart des applications supposeront
que ces documents ont été créés en utilisant l'encodage 8 bits de Windows
par défaut.
    </para>

    <para>Dans les cas extrêmes, les problèmes de compatibilité de l'encodage de
Windows ne peuvent être résolus qu'en lançant des programmes Windows sous
<ulink url="https://www.winehq.com/">Wine</ulink>.</para>

  </sect2>

  <sect2 id="locale-wrong-filename-encoding"
         xreflabel="L'encodage d'un nom de fichier est incorrect">

    <title>Le programme utilise ou crée des noms de fichiers dans le mauvais encodage</title>

    <para>Sévérité&nbsp;: critique</para>

    <para>Le standard POSIX suppose que l'encodage des noms de fichiers est l'encodage
impliqué par la catégorie de locale LC_CTYPE actuelle. Cette information est
bien cachée sur la page qui spécifie le comportement des programmes
<application>Tar</application> et <application>Cpio</application>. Certains
programmes ne le font pas par défaut (ou n'ont tout simplement pas assez
d'informations pour le faire). En conséquence, ces derniers créent des noms
de fichiers qui sont ensuite mal affichés par <command>ls</command> ou
refusent d'accepter des noms de fichiers affichés correctement par
<command>ls</command>. Pour la bibliothèque <xref linkend="glib2"/>, on peut
corriger le problème en réglant la variable d'environnement
<envar>G_FILENAME_ENCODING</envar> sur la valeur spéciale
«&nbsp;@locale&nbsp;». Les programmes basés sur
<application>Glib2</application> qui ne respectent pas cette variable
d'environnement sont bogués.</para>

    <para>Les paquets <xref linkend="zip"/> et <xref linkend="unzip"/> ont ce problème
car ils codent l'encodage attendu du nom de fichier en
dur. <application>UnZip</application> contient une table de conversion codée
en dur entre les encodages CP850 (DOS) et ISO-8859-1 (UNIX) et utilise cette
table lors de l'extraction des archives créées sous DOS ou Microsoft
Windows. Cette supposition ne marche cependant que pour les États-Unis et
pas pour ceux qui utilisent une locale UTF-8. Les caractères non-ASCII
seront rognés dans les noms de fichiers extraits.</para>

    

    <!--<para>
On the other hand,
    <application>Nautilus CD Burner</application> checks names of
    files added to its window for UTF-8 validity. This is wrong for
    users of non-UTF-8 locales. Also,
    <application>Nautilus CD Burner</application> unconditionally
    calls <command>mkisofs</command> with the
    <parameter>-input-charset UTF-8</parameter> parameter, which is
    only correct in UTF-8 locales.</para>-->
<para>La règle générale pour éviter ce type de problème est d'éviter d'installer
des programmes cassés. Si c'est impossible, vous pouvez utiliser l'outil
<ulink url="https://j3e.de/linux/convmv/">convmv</ulink> en ligne de
commande pour corriger les noms de fichiers créés par ces programmes
endommagés ou rogner volontairement les noms de fichiers existants pour
satisfaire les attentes de ces programmes.</para>

    <para><!--<xref linkend="nfs-utils"/>
 or-->
Dans d'autres cas, un problème similaire vient de l'importation de noms de
fichiers d'un système utilisant une locale différente avec un outil non
conscient de la locale (comme <xref linkend="openssh"/>). Pour éviter de
rogner les caractères non-ASCII lors du transfert de fichiers vers un
système ayant une locale différente, vous pouvez utiliser une des méthodes
suivantes&nbsp;:</para>

    <itemizedlist>
      <listitem>
        <para>Transférer malgré tout et réparer les dommages avec
<command>convmv</command>.</para>
      </listitem>
      <listitem>
        <para>Côté expéditeur, créer une archive tar en passant le paramètre
<parameter>--format=posix</parameter> à <command>tar</command> (cela sera le
réglage par défaut dans une version à venir de <command>tar</command>).</para>
      </listitem>
      <listitem>
        <para>Envoyer les fichiers en pièces jointes. Les clients de messagerie spécifient
l'encodage des noms de fichiers joints.</para>
      </listitem>
      <listitem>
        <para>Écrire les fichiers sur un disque amovible formaté avec un système de
fichiers FAT ou FAT32.</para>
      </listitem>
      <listitem>
        <para>Transférer les fichiers en utilisant Samba.</para>
      </listitem>
      <listitem>
        <para>Transférer les fichiers par FTP en utilisant un serveur (actuellement, cela
signifie seulement wu-ftpd qui a de mauvais antécédents en matière de
sécurité) et un client (comme lftp) conscient du RFC2640</para>
      </listitem>
    </itemizedlist>

    <para>Les quatre dernières méthodes fonctionnent car les noms de fichiers sont
automatiquement convertis de la locale de l'expéditeur en UNICODE et stockés
ou envoyés sous cette forme. Ils sont alors convertis de façon transparente
de l'UNICODE à l'encodage de la locale du destinataire.</para>

  </sect2>

  <sect2 id="locale-wrong-multibyte-characters"
         xreflabel="Casse les caractères multi-octets">

    <title>Le programme casse les caractères multi-octets ou ne compte pas bien les
cellules de caractères</title>

    <para>Sévérité&nbsp;: haute ou critique</para>

    <para>De nombreux programmes ont été écrits à une époque plus ancienne où les
locales multi-octets n'étaient pas courantes. De tels programmes supposent
que les types de données C "char", qui sont un octet, peuvent être utilisés
pour stocker des caractères uniques. De plus, ils supposent que n'importe
quelle séquence de caractères est une chaîne valide et que chaque caractère
occupe une seule cellule de caractère. De telles suppositions échouent
complètement dans les locales UTF-8. La conséquence évidente est que le
programme tronque les chaînes de façon prématurée (c'est-à-dire aux octets
80 au lieu des caractères 80). Les programmes basés sur le terminal ne
placent pas bien le curseur à l'écran, ne réagissent pas à la touche
«&nbsp;Effacement&nbsp;» en effaçant un caractère et laissent les mauvais
caractères affichés lors du rafraîchissement de l'écran, transformant
généralement l'écran en désordre complet.</para>

    <para>La correction de ce type de problème est une tâche pénible du point de vue
d'un programmeur, comme tout cas de modernisation d'un design défectueux par
de nouveaux concepts. Dans ce cas, il faut concevoir de nouveau toutes les
structures de données pour s’accommoder du fait qu'un caractère complet peut
s'étendre sur un nombre variable de «&nbsp;char&nbsp;» (ou basculer sur
wchar_t et convertir au besoin). Pour chaque utilisation des fonctions
«&nbsp;strlen&nbsp;» et équivalent, il faut aussi trouver ce que veut
vraiment dire un nombre d'octets, de caractères ou la largeur de la
chaîne. Il est parfois plus rapide d'écrire un programme ayant la même
fonctionnalité en partant de zéro.
    </para>

    <para>Au sein des paquets de BLFS, ce problème s'applique à<xref
linkend="xine-ui"/> et tous les shells.</para>

  </sect2>

  <sect2 id="locale-wrong-manpage-encoding"
         xreflabel="L'encodage des pages de manuel est incorrect">

    <title>Le paquet installe des pages de manuel dans un encodage incorrect ou non
affichable</title>

    <para>Sévérité&nbsp;: basse</para>

    <para>LFS s'attend à ce que les pages de manuel soient dans l'encodage spécifique
à la langue (en général 8-bit), comme indiqué sur la <ulink
url="&lfs-root;/chapter08/man-db.html">page Man DB de
LFS</ulink>. Cependant, certains paquets installent des pages de manuel
traduites dans l'encodage UTF-8 (comme avec Shadow qui a déjà été traité),
ou des pages de manuel dans des langues non présentes dans la table. Tous
les paquets BLFS n'ont pas fait l'objet d'une évaluation de leur respect des
exigences de LFS (la grande majorité a été vérifiée et des corrections ont
été mises dans le livre pour les paquets connus pour installer des pages de
manuel non conformes). Si vous trouvez une page de manuel installée par un
paquet BLFS qui est dans un mauvais encodage, merci de la supprimer ou de la
convertir selon vos besoins et de le signaler à l'équipe BLFS comme un
bogue.</para>

    <para>Vous pouvez facilement vérifier le respect par toutes les pages de manuel de
votre système en copiant le petit script shell suivant à un endroit
accessible, <screen><literal>#!/bin/sh
# Begin checkman.sh
# Usage: find /usr/share/man -type f | xargs checkman.sh
for a in "$@"
do
    # echo "Checking $a..."
    # Pure-ASCII manual page (possibly except comments) is OK
    grep -v '.\\"' "$a" | iconv -f US-ASCII -t US-ASCII >/dev/null 2>&amp;1 \
        &amp;&amp; continue
    # Non-UTF-8 manual page is OK
    iconv -f UTF-8 -t UTF-8 "$a" >/dev/null 2>&amp;1 || continue
    # Found a UTF-8 manual page, bad.
    echo "UTF-8 manual page: $a" >&amp;2
done
# End checkman.sh
</literal></screen> puis en lançant la commande
suivante (modifiez la commande ci-dessous si le script
<command>checkman.sh</command> n'est pas dans votre variable d'environnement
<envar>PATH</envar>)&nbsp;:</para>

<screen><userinput>find /usr/share/man -type f | xargs checkman.sh</userinput></screen>

    <para>Remarquez cependant que si vous avez des pages de manuel installées ailleurs
que dans <filename class='directory'>/usr/share/man</filename> (comme dans
<filename class='directory'>/usr/local/share/man</filename>), vous devez
modifier la commande ci-dessus pour inclure cet emplacement supplémentaire.</para>

  </sect2>

</sect1>
