<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../../general.ent">
  %general-entities;
]>

<sect1 id="unpacking">
  <?dbhtml filename="notes-on-building.html"?>


  <title>Remarques sur la construction de logiciels</title>

  <para>Celles et ceux qui ont construit un système LFS connaissent sans doute les
principes généraux du téléchargement et de l'extraction de
logiciel. Certaines de ces informations sont répétées ici pour les nouveaux
qui construisent leurs propres logiciels.</para>

  <para>Chaque ensemble d'instructions d'installation contient une URL sur laquelle
laquelle vous pouvez télécharger le paquet. Cependant, les correctifs sont
enregistrés sur les serveurs LFS et disponibles via HTTP. Ces derniers sont
référencés, si besoin, dans les instructions d'installation.</para>

  <para>Même si vous pouvez placer les fichiers sources où vous voulez, nous
supposons que vous avez extrait le paquet et êtes allé dans le répertoire
créé par le processus de décompression (le répertoire de
«&nbsp;construction&nbsp;»). Nous supposons aussi que vous avez décompressé
les correctifs requis et qu'ils sont dans le répertoire directement
au-dessus du répertoire de «&nbsp;construction&nbsp;».</para>

  <para>Nous ne saurions que trop vous recommander de démarrer à partir d'une
<emphasis>arborescence de sources propre</emphasis> à chaque fois.  Cela
veut dire que si vous avez eu une erreur lors de la configuration ou de la
compilation, il est généralement préférable de supprimer l'arborescence des
sources et de l'extraire de nouveau <emphasis>avant</emphasis> de
réessayer. Cela ne s'applique évidemment pas si vous êtes un utilisateur
avancé habitué à modifier les <filename>Makefile</filename>s et le code
C. Si vous avez un doute cependant, commencez à partir d'une arborescence
propre.</para>

  <sect2>
    <title>Construction de logiciels en tant qu'utilisateur non privilégié (non root)</title>

    <para>La règle d'or de l'administration d'un système Unix est de n'utiliser vos
super-pouvoirs que si nécessaire. D'où la recommandation de BLFS de
construire les logiciels en tant qu'utilisateur non privilégié et de ne
devenir l'utilisateur <systemitem class='username'>root</systemitem> que
lors de l'installation du logiciel. On suit cette philosophie dans tous les
paquets de ce livre. Sauf spécifications contraires, toutes les instructions
devraient être exécutées en tant qu'utilisateur non privilégié. Le livre
vous conseillera sur les instructions qui ont besoin des privilèges
<systemitem class='username'>root</systemitem>.</para>

  </sect2>

  <sect2>
    <title>Décompresser le logiciel</title>

    <para>S'il y a un fichier compressé au format <filename
class='extension'>.tar</filename>, on le décompresse en utilisant une des
commandes suivantes&nbsp;:</para>

<screen><userinput>tar -xvf filename.tar.gz
tar -xvf filename.tgz
tar -xvf filename.tar.Z
tar -xvf filename.tar.bz2</userinput></screen>

    <note>
      <para>Vous pouvez ne pas utiliser le paramètre <option>v</option> dans les
commandes décrites ci-dessus et ci-dessous si vous souhaitez supprimer le
listage verbeux de tous les fichiers de l'archive au fur et à mesure qu'ils
sont extraits. Cela peut aider à accélérer l'extraction mais aussi rendre
plus évidentes les erreurs produites durant le processus.</para>
    </note>

    <para>Vous pouvez aussi utiliser une méthode légèrement différente&nbsp;:</para>

<screen><userinput>bzcat filename.tar.bz2 | tar -xv</userinput></screen>

    <para>Enfin, vous avez parfois besoin de décompresser des correctifs qui ne sont
généralement pas au format <filename class='extension'>.tar</filename>. La
meilleure manière de le faire est de copier le fichier correctif dans le
parent du répertoire de «&nbsp;construction&nbsp;» puis d'exécuter une des
commandes suivantes selon que le fichier est un <filename
class='extension'>.gz</filename> ou un <filename
class='extension'>.bz2</filename>&nbsp;:</para>

<screen><userinput>gunzip -v patchname.gz
bunzip2 -v patchname.bz2</userinput></screen>

  </sect2>

  <sect2>
    <title>Vérifier l'intégrité des fichiers</title>

    <para>En général, pour vérifier que le fichier téléchargé est complet, de nombreux
mainteneurs de paquets distribuent aussi les sommes md5 des fichiers. Pour
vérifier la somme md5 des fichiers téléchargés, téléchargez à la fois le
fichier et le fichier md5sum correspondant dans le même répertoire (de
préférence à partir d'emplacements différents en ligne)  et (en supposant
que <filename>file.md5sum</filename> est le fichier md5sum téléchargé),
lancez la commande suivante&nbsp;:</para>

<screen><userinput>md5sum -c file.md5sum</userinput></screen>

    <para>S'il y a une erreur, elle sera signalée. Remarquez que le livre BLFS
contient aussi les sommes md5 de tous les fichiers sources. Pour utiliser
les sommes md5 fournies par BLFS, vous pouvez créer un
<filename>file.md5sum</filename> (mettez les données md5sum et le nom exact
du fichier téléchargé sur la même ligne d'un fichier, séparés par un espace
blanc), et lancez la commande montrée ci-dessus. Sinon, lancez simplement la
commande décrite ci-dessus et comparez la sortie avec les données de somme
md5 inscrites dans le livre BLFS.</para>

<screen><userinput>md5sum <replaceable>&lt;name_of_downloaded_file&gt;</replaceable></userinput></screen>

    <para>Le MD5 n'est pas cryptographiquement sûr, donc les sommes md5 ne sont
fournies que pour détecter des changements non intentionnels au contenu du
fichier. Par exemple, une erreur ou troncation introduite pendant le
transfert réseau, ou une mise à jour <quote>furtive</quote> du paquet en
amont (mise à jour du contenu d'une archive publiée au lieu de créer
directement une nouvelle version).</para>

    <para>Il n'y a pas de manière sure à <quote>100 %</quote> pour s'assurer de
l'authenticité des fichiers sources. En supposant que les développeurs en
amont gèrent leur site correctement (la clé privée n'est pas communiquée et
le domaine n'est pas usurpé), et que les ancres de confiance ont été
correctement configurées avec <xref linkend="make-ca"/> sur le système BLFS,
on peut raisonnablement faire confiance aux URL des site web officiels
<emphasis role="bold">avec le protocole https</emphasis>. Remarquez que le
livre BLFS lui-même est publié sur un site avec https, donc vous devez déjà
avoir un peu confiance en le protocole https ou vous ne pourriez pas faire
confiance au contenu de ce livre.</para>

    <para>Si le paquet est téléchargé à partir d'un emplacement non officiel (par
exemple un miroir local), vous pouvez utiliser des sommes de contrôles
générées par un algorithme cryptographiquement sûr (par exemple SHA256) pour
vérifier l'authenticité du paquet. Téléchargez le fichier de somme de
contrôle depuis le site <emphasis role="bold">officiel</emphasis> des
développeurs en amont (ou depuis un endroit <emphasis role="bold">auquel
vous faites confiance</emphasis>) et comparez la somme de contrôle du paquet
de l'emplacement non officiel. Par exemple, vous pouvez vérifier une somme
de contrôle SHA256 avec la commande&nbsp;:</para>

    <note>
      <para>Si la somme de contrôle et le paquet sont téléchargés à partir de la même
source non fiable, vous ne gagnerez rien à vérifier le paquet avec la somme
de contrôle. L'attaquant peut présenter une fausse somme de contrôle en plus
de compromettre le paquet en lui-même.</para>
    </note>

<screen><userinput>sha256sum -c <replaceable>file</replaceable>.sha256sum</userinput></screen>

    <para>Si <xref linkend="gnupg2"/> est installé, vous pouvez aussi vérifier
l'authenticité du paquet avec une signature GPG. Importez la clé publique
GPG amont avec&nbsp;:</para>

<screen><userinput>gpg --recv-key <replaceable>keyID</replaceable></userinput></screen>

    <para><replaceable>keyID</replaceable> devrait être remplacée par l'identifiant de
la clé fournie par un site <emphasis role="bold">fiable</emphasis> (par
exemple, copiez-la depuis le site officiel en utilisant https). Maintenant
vous pouvez vérifier la signature avec&nbsp;:</para>

<screen><userinput>gpg --recv-key <replaceable>file</replaceable>.sig <replaceable>file</replaceable></userinput></screen>

    <para>L'avantage de la signature <application>GnuPG</application> est que, une
fois une clé publique de confiance importée, vous pouvez télécharger à la
fois le paquet et sa signature à partir du même emplacement non officiel et
les vérifier avec la clé publique. Donc vous n'avez pas besoin de vous
connecter au site officiel en amont pour récupérer une somme de contrôle
pour chaque nouvelle version. Vous n'aurez besoin de mettre à jour la clé
publique que si elle est révoquée ou expirée.
    </para>

  </sect2>

  <sect2>
    <title>Créer des fichiers journaux pendant l'installation</title>

    <para>Pour les gros paquets, il est commode de créer des fichiers journaux plutôt
que de fixer indéfiniment l'écran en espérant trouver une erreur ou un
avertissement particulier. Les fichiers journaux sont aussi utiles pour
déboguer et garder des enregistrements. La commande suivante vous permet de
créer un journal d'installation. Remplacez
<replaceable>&lt;commande&gt;</replaceable> par la commande que vous
cherchez à exécuter.</para>

<screen><userinput>( <replaceable>&lt;command&gt;</replaceable> 2&gt;&amp;1 | tee compile.log &amp;&amp; exit $PIPESTATUS )</userinput></screen>

    <para><option>2&gt;&amp;1</option> redirige les messages d'erreur vers le même
endroit que la sortie standard. La commande <command>tee</command> vous
permet de voir la sortie en journalisant les résultats dans un fichier. Les
parenthèses autour de la commande exécutent toute la commande dans un
sous-shell. Enfin, la commande <command>exit $PIPESTATUS</command> s'assure
que c'est bien le résultat de <replaceable>&lt;commande&gt;</replaceable>
qui est retourné et pas le résultat de la commande <command>tee</command>.</para>

  </sect2>

  <sect2 id="parallel-builds" xreflabel="Utilisation de processeurs multiples">
    <title>Utilisation de processeurs multiples</title>

    <para>Pour la plupart des systèmes modernes avec des processeurs multiples (ou
cœurs) le temps de compilation pour un paquet peut être réduit en effectuant
une «&nbsp;construction parallèle&nbsp;» soit en initialisant une variable
d'environnement, soit en disant au programme make combien de processeurs
sont disponibles. Par exemple, un Core2Duo peut supporter deux processus
simultanés avec&nbsp;: </para>

    <screen><userinput>export MAKEFLAGS='-j2'</userinput></screen>

    <para>ou en compilant simplement avec&nbsp;:</para>

    <screen><userinput>make -j2</userinput></screen>

    <para>
      Si vous avez appliqué le <command>sed</command> facultatif pendant la
construction de <application>ninja</application> dans LFS, vous pouvez
utiliser&nbsp;:
    </para>

    <screen><userinput>export NINJAJOBS=2</userinput></screen>

    <para>
      quand un paquet utilise <command>ninja</command>, ou simplement&nbsp;:
    </para>

    <screen><userinput>ninja -j2</userinput></screen>

    <para>
      mais pour ninja, le nombre de processus par défaut est &lt;N&gt;+2, où
&lt;N&gt; est le nombre de processeurs disponibles, de telle sorte que la
commande précédente sert plutôt à limiter le nombre de tâches (voir plus bas
pour comprendre pourquoi).
    </para>

    <para>Généralement le nombre de processus ne doit pas dépasser le nombre de cœurs
supportés par le CPU. Pour lister les processeurs de votre système,
tapez&nbsp;: <userinput>grep processor /proc/cpuinfo</userinput>.
    </para>

    <para>Dans certains cas, l'utilisation de processeurs multiples peut amener dans
une situation de «&nbsp;compétition&nbsp;» où le succès de la construction
dépend de l'ordre des commandes lancées par le programme
<command>make</command>. Par exemple, si un exécutable demande un fichier A
et un fichier B, essayer de lier le programme avant qu'un des composants
dépendants ne soit disponible aboutira à un échec.  Cela arrive en général
quand les développeurs n'ont pas correctement désigné tous les prérequis
utiles pour accomplir une étape du Makefile.</para>

    <para>Si cela arrive, la meilleure chose à faire est de recommencer la
construction avec un seul processeur. En ajoutant «&nbsp;-j1&nbsp;» à une
commande make, cela écrasera l'initialisation similaire dans une variable
d'environnement <envar>MAKEFLAGS</envar>.</para>

    <note><para>Lorsque vous lancez les tests du paquet ou l'installation du paquet, nous ne
recommandons pas d'utiliser une option plus grande que «&nbsp;-j1&nbsp;» à
moins que cela ne soit spécifiquement indiqué. Les procédures d'installation
et les tests n'ont pas été validés avec des processus en parallèle et
peuvent échouer avec des problème difficiles à déboguer.</para></note>

    <important>
      <para>
        Un autre problème peut survenir avec les CPU modernes avec beaucoup de
cœurs. Chaque tâche démarrée consomme de la mémoire, et si la somme de la
mémoire requise par chaque tâche dépasse la quantité de mémoire disponible,
vous aurez soit une interruption noyau OOM (plus de mémoire) ou une
utilisation de l'espace d'échange qui ralentira excessivement la
construction.
      </para>

      <para>
        Comme certaines compilation avec <command>g++</command> peuvent consommer
jusqu'à 2,5 Go de mémoire, pour être sûr, vous devriez restreindre le nombre
de tâches à (mémoire totale en Go)/2,5, au moins pour les gros paquets comme
LLVM, WebKitGtk, QtWebEngine ou libreoffice.
      </para>
    </important>
  </sect2>

  <sect2 id="automating-builds" xreflabel="Procédures de construction automatique">
    <title>Procédures de construction automatique</title>

    <para>Automatiser la construction d'un paquet peut parfois s'avérer utile. On a
tous des raisons différentes pour automatiser la construction, et on le fait
par nos propres moyens. Soit en créant des <filename>Makefile</filename>s,
des scripts <application>Bash</application>, des scripts
<application>Perl</application> ou simplement une liste de commandes
utilisées à copier-coller. Ce sont toutes des méthodes que vous pouvez
utiliser pour automatiser la construction de paquets BLFS. Détailler et
donner des exemples sur les nombreuses manières d'automatiser la
construction de paquets va au-delà des objectifs de cette section. Cette
section vous présentera l'utilisation de la redirection de fichiers et de la
commande <command>yes</command> pour vous donner des idées sur la façon
d'automatiser vos constructions.</para>

    <bridgehead renderas="sect3">Redirection de fichier pour automatiser l'entrée</bridgehead>

    <para>Il y aura des moments, tout au long de votre aventure BLFS, où vous tomberez
sur un paquet ayant une invite de commande vous demandant des
informations. Ces informations peuvent être des détails de configuration, un
chemin de répertoire ou une réponse à un accord de licence. Cela peut être
un challenge pour automatiser la construction de ce paquet. On vous
demandera occasionnellement différentes informations via une série de
questions. Une méthode pour automatiser ce type de scénario est de mettre
les réponses désirées dans un fichier et d'utiliser la redirection pour que
le programme utilise les données du fichier comme réponses aux questions.</para>

    <para>La construction du paquet <application>CUPS</application> est un bon exemple
de la façon de rediriger un fichier comme entrée aux invites, cela peut vous
aider à automatiser la construction. Si vous lancez la suite de test, on
vous demande de répondre à une série de questions concernant le type de test
à exécuter et si vous avez des programmes auxiliaires que le test peut
utiliser. Vous pouvez créer un fichier avec vos réponses, une par ligne, et
utiliser une commande ressemblant à celle indiquée ci-dessous pour
automatiser l'exécution de la suite de tests&nbsp;:</para>

<screen><userinput>make check &lt; ../cups-1.1.23-testsuite_parms</userinput></screen>

    <para>Cela fait logiquement utilise les réponses du fichier comme entrée pour les
questions de la suite de tests. Vous aurez parfois à faire des séries
d'essais et erreurs pour déterminer le format exact de votre fichier
d'entrée pour certaines choses, mais une fois expérimenté et documenté, vous
pouvez utiliser cela pour automatiser la construction du paquet.</para>

    <bridgehead renderas="sect3">Utiliser <command>yes</command> pour automatiser l'entrée</bridgehead>

    <para>Vous n'aurez parfois besoin de ne fournir qu'une réponse ou alors la même
réponse à de nombreuses invites. Dans ces cas-là, la commande
<command>yes</command> fonctionne vraiment bien.  On peut utiliser la
commande <command>yes</command> pour fournir une réponse (la même) à une ou
plusieurs questions. On peut l'utiliser pour simuler un simple appui sur la
touche <keycap>Entrée</keycap>, l'entrée de la touche <keycap>Y</keycap> ou
l'entrée d'une chaîne de texte. La manière la plus facile de montrer son
utilisation est peut-être de prendre un exemple.</para>

    <para>Créez tout d'abord un petit script <application>Bash</application> en
entrant les commandes suivantes&nbsp;:</para>

<screen><userinput>cat &gt; blfs-yes-test1 &lt;&lt; "EOF"
<literal>#!/bin/bash

echo -n -e "\n\nPlease type something (or nothing) and press Enter ---> "

read A_STRING

if test "$A_STRING" = ""; then A_STRING="Just the Enter key was pressed"
else A_STRING="You entered '$A_STRING'"
fi

echo -e "\n\n$A_STRING\n\n"</literal>
EOF
chmod 755 blfs-yes-test1</userinput></screen>

    <para>Maintenant, lancez le script en exécutant
<command>./blfs-yes-test1</command> depuis la ligne de commande. Il attendra
une réponse, qui peut être n'importe quoi (ou rien) suivi de la touche
<keycap>Entrée</keycap>. Après avoir entré quelque chose, le résultat sera
affiché à l'écran. Utilisez maintenant la commande <command>yes</command>
pour automatiser l'entrée d'une réponse&nbsp;:</para>

<screen><userinput>yes | ./blfs-yes-test1</userinput></screen>

    <para>Remarquez que la redirection (le piping) de <command>yes</command> en
lui-même vers le script aboutit à ce que <keycap>y</keycap> est passé au
script. Essayez-la maintenant avec une chaîne de texte&nbsp;:</para>

<screen><userinput>yes 'This is some text' | ./blfs-yes-test1</userinput></screen>

    <para>La chaîne exacte était utilisée comme réponse au script. Enfin, essayez-la
en utilisant une chaîne vide (null)&nbsp;:</para>

<screen><userinput>yes '' | ./blfs-yes-test1</userinput></screen>

    <para>Remarquez que cela aboutit à ne passer au script que l'appui sur la touche
<keycap>Entrée</keycap>. C'est utile parfois quand la réponse par défaut à
l'invite est suffisante. Cette syntaxe est utilisée dans les instructions de
<xref linkend="net-tools-automate-example"/> pour accepter tous les réglages
par défaut à toutes les invites lors de l'étape de configuration.  Vous
pouvez maintenant supprimer le script de test si vous le désirez.</para>

    <bridgehead renderas="sect3">Redirection de fichiers pour automatiser la sortie</bridgehead>

    <para>Pour automatiser la construction de certains paquets, surtout ceux qui vous
demandent de lire un accord de licence page après page, il faut utiliser une
méthode qui évite de devoir appuyer sur une touche pour afficher chaque
page. On peut utiliser la redirection de sortie vers un fichier dans ce
cas-là pour vous aider à automatiser. La section précédente de cette page a
visé à créer des fichiers journaux de la sortie de la construction.  La
méthode de redirection qui y est décrite utilisait la commande
<command>tee</command> pour rediriger la sortie tout en affichant aussi la
sortie à l'écran. Ici on ne verra la sortie que dans un fichier.</para>

    <para>De nouveau, la manière la plus facile de montrer la technique est de
présenter un exemple. Lancez d'abord la commande&nbsp;:</para>

<screen><userinput>ls -l /usr/bin | more</userinput></screen>

    <para>Bien entendu, vous devrez voir la sortie page par page car on a utilisé le
filtre <command>more</command>. Essayez maintenant la même commande, mais en
redirigeant cette fois la sortie vers un fichier. Le fichier spécial
<filename>/dev/null</filename> peut être utilisé à la place du fichier
indiqué, mais vous n'aurez pas de fichier journal à examiner&nbsp;:</para>

<screen><userinput>ls -l /usr/bin | more &gt; redirect_test.log 2&gt;&amp;1</userinput></screen>

    <para>Vous remarquerez que cette fois, la commande est immédiatement revenue à
l'invite du shell sans devoir parcourir la sortie page par page. Vous pouvez
maintenant supprimer le fichier journal.</para>

    <para>Le dernier exemple utilisera la commande <command>yes</command> associée à
la redirection de sortie pour éviter de naviguer page par page dans la
sortie, puis de fournir un <keycap>y</keycap> à l'invite. Cette technique
peut être utilisée dans les cas où vous devriez, sans elle, naviguer page
par page dans la sortie d'un fichier (tel qu'un accord de licence), puis
répondre à la question <quote>Acceptez-vous ce qui précède&nbsp;?</quote>.
Pour cet exemple, on a besoin d'un autre petit script
<application>Bash</application>&nbsp;:</para>

<screen><userinput>cat &gt; blfs-yes-test2 &lt;&lt; "EOF"
<literal>#!/bin/bash

ls -l /usr/bin | more

echo -n -e "\n\nDid you enjoy reading this? (y,n) "

read A_STRING

if test "$A_STRING" = "y"; then A_STRING="You entered the 'y' key"
else A_STRING="You did NOT enter the 'y' key"
fi

echo -e "\n\n$A_STRING\n\n"</literal>
EOF
chmod 755 blfs-yes-test2</userinput></screen>

    <para>On peut utiliser ce script pour simuler un programme qui demande que vous
lisiez un accord de licence et que vous acceptiez le contrat avant que le
programme n'installe quoique ce soit. Lancez d'abord le script sans
techniques d'automatisation en exécutant
<command>./blfs-yes-test2</command>.</para>

    <para>Maintenant lancez la commande suivante qui utilise deux techniques
d'automatisation, rendant l'utilisation convenable dans un script de
construction automatisé&nbsp;:</para>

<screen><userinput>yes | ./blfs-yes-test2 &gt; blfs-yes-test2.log 2&gt;&amp;1</userinput></screen>

    <para>Si vous le désirez, lancez <command>tail blfs-yes-test2.log</command> pour
voir la fin de la sortie paginée et la confirmation que <keycap>y</keycap> a
été passé au script. Une fois que cela marche comme cela devrait, vous
pouvez supprimer le script et le fichier journal.</para>

    <para>Enfin, gardez à l'esprit qu'il y a de nombreux moyens d'automatiser ou de
scripter les commandes de construction. Il n'y a pas <quote>une
seule</quote> manière de procéder. Votre imagination est la seule limite.</para>

  </sect2>

  <sect2>
    <title>Dépendances</title>

    <para>Pour chaque paquet décrit, BLFS liste les dépendances connues. Elles sont
listées sous plusieurs en-têtes, dont la signification est la
suivante&nbsp;:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>Required</emphasis> means that the target package cannot be
correctly built without the dependency having first been installed, except
if the dependency is said to be <quote>runtime</quote>, which means the
target package can be built but cannot function without it.</para>
        <para>
          Note that a target package can start to <quote>function</quote> in many
subtle ways: an installed configuration file can make the init system, cron
daemon, or bus daemon to run a program automatically; another package using
the target package as an dependency can run a program from the target
package in the building system; and the configuration sections in the BLFS
book may also run a program from a just installed package.  So if you are
installing the target package without a <emphasis>Required
(runtime)</emphasis> dependency installed, You should install the dependency
as soon as possible after the installation of the target package.
        </para>
      </listitem>
      <listitem>
        <para><emphasis>Recommended</emphasis> means that BLFS strongly suggests this
package is installed first (except if said to be <quote>runtime</quote>, see
below) for a clean and trouble-free build, that won't have issues either
during the build process, or at run-time.  The instructions in the book
assume these packages are installed.  Some changes or workarounds may be
required if these packages are not installed. If a recommended dependency is
said to be <quote>runtime</quote>, it means that BLFS strongly suggests that
this dependency is installed before using the package, for getting full
funtionality.</para>
      </listitem>
      <listitem>
        <para><emphasis>Optional</emphasis> means that this package might be installed for
added functionality. Often BLFS will describe the dependency to explain the
added functionality that will result.  An optional dependency may be
automatically pick up by the target package if the dependency is installed,
but another some optional dependency may also need additional configuration
options to enable them when the target package is built.  Such additional
options are often documented in the BLFS book.  If an optional dependency is
said to be <quote>runtime</quote>, it means you may install the dependency
after installing the target package to support some optional features of the
target package if you need these features.</para>
        <para>An optional dependency may be out of BLFS.  If you need such an
<emphasis>external</emphasis> optional dependency for some features you
need, read <xref linkend='beyond'/> for the general hint about installing an
out-of-BLFS package.</para>
      </listitem>
    </itemizedlist>

  </sect2>

  <sect2 id="package_updates">
    <title>Utilisation de paquets sources les plus récents</title>

    <para>Il peut arriver occasionnellement qu'un paquet ne se construise pas ou ne
fonctionne pas correctement dans le livre. Bien que les éditeurs tentent de
faire en sorte que chaque paquet dans le livre se construise et fonctionne
correctement, il arrive parfois qu'un paquet ait été oublié ou n'ait pas été
testé avec cette version particulière de BLFS.</para>

    <para>Si vous découvrez un paquet qui ne se construit pas ou ne fonctionne pas
correctement, vous pouvez regarder s'il s'agit de la version la plus récente
du paquet. En général, cela signifie que vous devez vous rendre sur le site
web du responsable, télécharger l'archive la plus récente et tenter de
construire le paquet. Si vous ne pouvez pas déterminer le site web du
responsable en regardant l'URL de chargement, utilisez Google et cherchez le
nom du paquet. Par exemple, dans la barre de recherche de Google
tapez&nbsp;: «&nbsp;nom_du_paquet download&nbsp;» (sans les guillemets) ou
quelque chose de similaire. Parfois en tapant&nbsp;: «&nbsp;nom_du_paquet
home page&nbsp;» vous trouverez le site web du responsable.</para>

  </sect2>

  <sect2 id="stripping">
    <title>Nettoyage une fois de plus</title>

    <para>
      Dans LFS, le nettoyage des symboles de débogage et des entrées de la table
des symboles inutiles a été abordé plusieurs fois.  Pour la construction des
paquets BLFS, il n'y a généralement pas d'instructions qui abordent de
nouveau le nettoyage. Le nettoyage peut avoir lieu après l'installation d'un
paquet, ou plus tard.
    </para>

    <bridgehead renderas="sect3" id="stripping-install">Nettoyage à l'installation d'un paquet</bridgehead>

    <para>
      Il y a plusieurs manières de nettoyer les exécutables installés par un
paquet. Elles dépendent du système de construction utilisé (voir plus bas
<link linkend="buildsystems">la section sur les systèmes de
construction</link>), c'est pourquoi nous ne listons que quelques
généralités ici&nbsp;:
    </para>

    <note>
      <para>
        Les méthodes suivantes qui utilisent la fonctionnalité d'un système de
construction (autotools, meson ou cmake) ne nettoieront pas les
bibliothèques statiques si elles sont installées. Heureusement il n'y a pas
tant de bibliothèques statiques dans BLFS et une bibliothèque statique peut
toujours être nettoyée sans problème en exécutant <command>strip
--strip-unneeded</command> dessus manuellement.
      </para>
    </note>

    <itemizedlist>
      <listitem>
        <para>
          Les paquets qui utilisent les autotools ont habituellement une cible
<parameter>install-strip</parameter> dans leur fichier
<filename>Makefile</filename> généré. Donc installer des exécutables
nettoyer est aussi simple qu'utiliser <command>make install-strip</command>
au lieu de <command>make install</command>.
        </para>
      </listitem>
      <listitem>
        <para>
          Les paquets qui utilisent le système de construction meson acceptent
<parameter>-Dstrip=true</parameter> au lancement de
<command>meson</command>. Si vous avez oublié d'ajouter cette option en
lançant <command>meson</command>, vous pouvez aussi lancer <command>meson
install --strip</command> au lieu de <command>ninja install</command>.
        </para>
      </listitem>
      <listitem>
        <para>
          <command>cmake</command> génère des cibles
<parameter>install/strip</parameter> aussi bien pour le générateur de
<parameter>Makefiles Unix</parameter> que pour le générateur
<parameter>Ninja</parameter> (par défaut c'est le générateur de
<parameter>Makefiles Unix</parameter> qui sera utilisé sur linux). Lancez
simplement <command>make install/strip</command> ou <command>ninja
install/strip</command> au lieu de l'équivalent avec
<command>install</command>.
        </para>
      </listitem>
      <listitem>
        <para>
          Supprimer (ou éviter de générer) les symboles de débogage peut aussi se
faire en supprimant les options <parameter>-g&lt;quelque
chose&gt;</parameter> dans les appels au compilateur C/C++. La manière de
procéder est spécifique à chaque paquet. En plus, cela ne supprime pas les
entrées inutiles de la table des symboles. Nous ne l'expliquons donc pas
ici. Voir plus bas les paragraphes sur l'optimisation.
        </para>
      </listitem>
    </itemizedlist>

    <bridgehead renderas="sect3" id="stripping-installed">Nettoyer les exécutables installés</bridgehead>

    <para>
      The <command>strip</command> utility changes files in place, which may break
anything using it if it is loaded in memory. Note that if a file is in use
but just removed from the disk (i.e. not overwritten nor modified), this is
not a problem since the kernel can use <quote>deleted</quote> files.  Look
at <filename>/proc/*/maps</filename> and it is likely that you'll see some
<emphasis>(deleted)</emphasis> entries. The <command>mv</command> just
removes the destination file from the directory but does not touch its
content, so that it satisfies the condition for the kernel to use the old
(deleted) file.  But this approach can detach hard links into duplicated
copies, causing a bloat which is obviously unwanted as we are stripping to
reduce system size.  If two files in a same file system share the same inode
number, they are hard links to each other and we should reconstruct the
link.  The script below is just an example.  It should be run as the &root;
user:
    </para>

<screen><userinput>cat &gt; /usr/sbin/strip-all.sh &lt;&lt; "EOF"
<literal>#!/usr/bin/bash

if [ $EUID -ne 0 ]; then
  echo "Need to be root"
  exit 1
fi

last_fs_inode=
last_file=

{ find /usr/lib -type f -name '*.so*' ! -name '*dbg'
  find /usr/lib -type f -name '*.a'
  find /usr/{bin,sbin,libexec} -type f
} | xargs stat -c '%m %i %n' | sort | while read file; do
       if ! readelf -h $file >/dev/null 2>&amp;1; then continue; fi
       if file $file | grep --quiet --invert-match 'not stripped'; then continue; fi

       if [ "$fs $inode" = "$last_fs_inode" ]; then
         ln -f $last_file $file;
         continue;
       fi

       cp --preserve $file    ${file}.tmp
       strip --strip-unneeded ${file}.tmp
       mv ${file}.tmp $file

       last_fs_inode="$fs $inode"
       last_file=$file
done</literal>
EOF
chmod 744 /usr/sbin/strip-all.sh</userinput></screen>

    <para>
      Si vous installez des programmes dans d'autres répertoires tels que
<filename class="directory">/opt</filename> ou <filename
class="directory">/usr/local</filename>, vous pouvez vouloir nettoyer les
fichiers ici aussi. Ajoutez simplement d'autres répertoires à scanner dans
la liste des commandes <command>find</command> entre accolades.
    </para>

    <para>
      Pour plus d'information sur le nettoyage, regardez <ulink
url="https://www.technovelty.org/linux/stripping-shared-libraries.html"/>.
    </para>

  </sect2>


  <!--
  <sect2 id="libtool">

    <title>Libtool files</title>

    <para>
      One of the side effects of packages that use Autotools, including
      libtool, is that they create many files with an .la extension.  These
      files are not needed in an LFS environment.  If there are conflicts with
      pkgconfig entries, they can actually prevent successful builds.  You
      may want to consider removing these files periodically:
    </para>

<screen><userinput>find /lib /usr/lib -not -path "*Image*" -a -name \*.la -delete</userinput></screen>

    <para>
      The above command removes all .la files with the exception of those that
      have <quote>Image</quote> or <quote>openldap</quote> as a part of the
      path.  These .la files are used by the ImageMagick and openldap programs,
      respectively.  There may be other exceptions by packages not in BLFS.
    </para>

  </sect2>
-->
<sect2 id="buildsystems">
    <title>Travailler avec différents systèmes de construction</title>

    <para>
      Il y a maintenant trois systèmes de construction différents utilisés
régulièrement pour convertir du code source C ou C++ en un programme compilé
ou en une bibliothèque et leur fonctionnement (en particulier, comment
trouver les options disponibles et leurs valeurs par défaut) est
différent. Il peut être plus facile de comprendre les problèmes causés par
certains choix (typiquement une exécution lente ou l'utilisation inattendue,
ou l'omission, des optimisations en commençant par les variables
d'environnement CFLAGS et CXXFLAGS. Certains programmes utilisent aussi
rust.
    </para>

    <para>
      La plupart des lecteurs de LFS et de BLFS connaissent probablement déjà les
bases de l'utilisation de CFLAGS et CXXFLAGS pour altérer la compilation
d'un programme. En général, certaines formes d'optimisations sont utilisées
par les développeurs en amont (-O2 ou -O3), parfois avec la création de
symboles de débogage (-g) par défaut.
    </para>

    <para>
      S'il y a des drapeaux contradictoires (p. ex. plusieurs valeurs différentes
de -O), la <emphasis>dernière</emphasis> valeur sera utilisée. Parfois les
drapeaux spécifiés dans les variables d'environnement sont insérés avant les
valeurs en dur dans le Makefile, ce qui signifie qu'ils sont ignorés. Par
exemple, si un utilisateur spécifie «&nbsp;-O2&nbsp;» et qu'il est suivi de
«&nbsp;-O3&nbsp;», la construction utilisera «&nbsp;-O3&nbsp;».
    </para>

    <para>
      On peut passer divers autres drapeaux dans CFLAGS et CXXFLAGS, comme forcer
la compilation pour une microarchitecture spécifique
(p. ex. -march=amdfam10, -march=native) ou pour spécifier un standard C ou
C++ particulier (-std=c++17 par exemple). Mais ce qui commence à apparaître,
c'est l'inclusion par les développeurs d'assertions de débogage dans leur
code qui sont généralement désactivés dans les versions publiées avec
-DNDEBUG. Plus spécifiquement, si <xref linkend="mesa"/> est construit avec
ces assertions, certaines activités comme le chargement de niveaux dans les
jeux peuvent prendre très longtemps, même sur des cartes vidéo haut de
gamme.
    </para>

    <bridgehead renderas="sect3" id="autotools-info">Autotools avec Make</bridgehead>

      <para>
       Cette combinaison est souvent décrite comme «&nbsp;CMMI&nbsp;» (configure,
make, make install) et est utilisée ici pour couvrir aussi certains paquets
dont le script configure n'a pas été généré par les autotools.
      </para>

      <para>
        Parfois lancer <command>./configure --help</command> affichera les options
utiles des paramètres qui peuvent être utilisés. D'autres fois, après avoir
regardé la sortie de configure vous pourriez avoir besoin de regarder les
détails du script pour comprendre ce qu'il cherchait vraiment.
      </para>

      <para>
       De nombreux scripts configure récupéreront les CFLAGS et CXXFLAGS de
l'environnement, mais les paquets CMMI varient dans la manière dont ils
seront insérés avec les drapeaux qui sinon seraient utilisés (<emphasis>au
choix</emphasis>&nbsp;: ignorés, utilisés à la place de la suggestion des
programmeurs, utilisés avant la suggestion des programmeurs ou utilisés
après la suggestion des programmeurs).
      </para>

      <para>
       Dans la plupart des paquets CMMI, «&nbsp;make&nbsp;» listera les commandes
lancées, séparées par des avertissements éventuels. Mais certains paquets
essayent d'être «&nbsp;silencieux&nbsp;» et ne montrent que les fichiers
qu'ils compilent ou dont ils éditent les liens au lieu de montrer la ligne
de commande. Si vous devez inspecter la commande, soit à cause d'une erreur,
ou juste pour voir les options et les drapeaux utilisés, ajouter
«&nbsp;V=1&nbsp;» à l'invocation make peut aider.
     </para>

    <bridgehead renderas="sect3" id="cmake-info">CMake</bridgehead>

      <para>
        CMake fonctionne de manière différente et il a deux moteurs qui peuvent être
utilisés sur BLFS&nbsp;: «&nbsp;make&nbsp;» et «&nbsp;ninja&nbsp;». Le
moteur par défaut est make, mais ninja est plus rapide sur les paquets plus
gros avec plusieurs processeurs. Pour utiliser ninja, spécifiez «&nbsp;-G
Ninja&nbsp;» dans la commande cmake. Cependant, certains paquets peuvent
avoir des erreurs fatales dans leurs fichiers ninja tout en pouvant être
construits sans problème avec les Makefile Unix par défaut.
      </para>

      <para>
        La partie la plus dure de l'utilisation de CMake est de connaître les
options que vous voudrez spécifier. La seule manière de récupérer une liste
de ce que le paquet connaît est de lancer <command>cmake -LAH</command> et
de regarder la sortie pour cette configuration par défaut.
      </para>

      <para>
        Peut-être que la chose la plus importante à propos de CMake est qu'il a
plusieurs valeurs de CMAKE_BUILD_TYPE et qu'elles affectent les drapeaux. La
valeur par défaut est vide et aucun drapeau n'est généré. Les CFLAGS et
CXXFLAGS dans l'environnement seront utilisés. Si le programmeur a codé des
assertions de débogage, elles seront activées à moins que vous n'utilisiez
-DNDEBUG. Les valeurs CMAKE_BUILD_TYPE suivantes généreront les drapeaux
associés et ils seront ajoutés <emphasis>après</emphasis> les drapeaux dans
l'environnement et prennent donc le pas dessus.
      </para>

      <informaltable align="center">
        <tgroup cols="2">
          <colspec colnum="1" align="center"/>
          <colspec colnum="2" align="center"/>
          <thead>
            <row><entry>Value</entry><entry>Flags</entry></row>
          </thead>
          <tbody>
            <row>
              <entry>Debug</entry><entry><option>-g</option></entry>
            </row>
            <row>
              <entry>Release</entry><entry><option>-O3 -DNDEBUG</option></entry>
            </row>
            <row>
              <entry>RelWithDebInfo</entry><entry><option>-O2 -g -DNDEBUG</option></entry>
            </row>
            <row>
              <entry>MinSizeRel</entry><entry><option>-Os -DNDEBUG</option></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>
        CMake essaye de produire des constructions silencieuses. Pour voir les
détails des commandes lancées, utilisez <command>make VERBOSE=1</command> ou
<command>ninja -v</command>.
      </para>

      <para>
        Par défaut, CMake traite l'installation des fichiers différemment des autres
systèmes de construction&nbsp;: si un fichier existe déjà et n'est pas plus
récent qu'un fichier qui le remplacerait, alors le fichier n'est pas
installé. cela peut être un problème si vous voulez enregistrer quels
fichiers appartiennent à quel paquet, soit avec <envar>LD_PRELOAD</envar>,
soit en listant les fichiers plus récents qu'un certain horodatage. Ce
comportement par défaut peut être modifié en paramétrant la variable
<envar>CMAKE_INSTALL_ALWAYS</envar> à 1 dans
l'<emphasis>environnement</emphasis>, par exemple en
l'<command>export</command>ant.
      </para>

    <bridgehead renderas="sect3" id="meson-info">Meson</bridgehead>

      <para>
        Meson ressemble un peu à CMake, mais avec beaucoup de différences. Pour
trouver les détails des définitions que vous pourriez avoir besoin de
modifier, vous pouvez regarder dans <filename>meson_options.txt</filename>
qui est généralement dans le répertoire de plus haut niveau.
      </para>

      <para>
        Si vous avez déjà configuré le paquet en lançant <command>meson</command> et
que vous souhaitez maintenant changer un ou plusieurs paramètres, vous
pouvez soit supprimer le répertoire de construction, le recréer et utiliser
les options modifiées, soit lancer <command>meson configure</command> dans
le répertoire de construction, p. ex. pour ajouter une option&nbsp;:
      </para>

<screen><userinput>meson configure -D&lt;some_option&gt;=true</userinput></screen>

      <para>
        Si vous faites cela, le fichier
<filename>meson-private/cmd_line.txt</filename> contiendra les
<emphasis>dernières</emphasis> commandes qui ont été utilisées.
      </para>

      <para>
        Meson fournit les valeurs buildtype suivantes, et les drapeaux qu'elles
activent viennent <emphasis>après</emphasis> les drapeaux fournis dans
l'environnement et prennent donc le pas.
      </para>

      <itemizedlist>
        <listitem>
          <para>plain&nbsp;: pas de drapeau supplémentaire. Cela est utilisé pour spécifier
ses propres CFLAGS, CXXFLAGS et LDFLAGS. Il n'y a pas de raison évidente
pour utiliser cela dans BLFS.</para>
        </listitem>
        <listitem>
          <para>debug&nbsp;: «&nbsp;-g&nbsp;» - c'est la valeur par défaut si rien n'est
spécifié dans <filename>meson.build</filename> ni sur la ligne de
command. Cependant, cela crée des binaires gros et lents, donc vous devez le
remplacer dans BLFS.</para>
        </listitem>
        <listitem>
           <para>debugoptimized&nbsp;: «&nbsp;-O2 -g&nbsp;»&nbsp;: c'est la valeur par défaut
spécifiée dans <filename>meson.build</filename> pour certains paquets.</para>
        </listitem>
        <listitem>
           <para>release&nbsp;: «&nbsp;-O3 -DNDEBUG&nbsp;» (mais parfois un paquet forcera
-O2)</para>
        </listitem>
      </itemizedlist>

      <para>
        Bien que le type «&nbsp;release&nbsp;» soit décrit comme activant -DNDEBUG
et que toutes les constructions CMake en Release le passent, cela n'a été
observé jusque là (sur les constructions verbeuses) que pour <xref
linkend="mesa"/>. Cela suggère qu'il ne serait utilisé que s'il y a des
assertions de débogage.
      </para>

      <para>
        Le drapeau -DNDEBUG peut aussi être fournit en passant
<command>-Db_ndebug=true</command>.
      </para>

      <para>
        Pour voir les détails des commandes qui sont lancées dans un paquet qui
utilise meson, utilisez «&nbsp;ninja -v&nbsp;».
      </para>

    <bridgehead renderas="sect3" id="rust-info">Rustc et Cargo</bridgehead>

      <para>
        La plupart des programmes rustc publiés sont fournis dans des archives (ou
«&nbsp;crates&nbsp;») qui demanderont à un serveur de vérifier les versions
actuelles des dépendances et les téléchargera au besoin. Ces paquets sont
construits avec <command>cargo --release</command>. En théorie, on peut
manipuler les RUSTFLAGS pour changer le niveau d'optimisation (par défaut 3,
come -O3, p. ex. <literal>-Copt-level=3</literal>) ou pour forcer la
construction pour la machine sur laquelle il est compilé, avec
<literal>-Ctarget-cpu=native</literal> mais en pratique cela ne semble pas
faire de réelle différence.
      </para>

      <para>
        Si vous trouvez un programme rustc intéressant qui n'est fournit que sous
forme de sources sans paquet, vous devez au moins spécifier
<literal>RUSTFLAGS=-Copt-level=2</literal> sans quoi rustc effectuera une
compilation sans optimisation et avec les informations de débogage et le
résultat sera <emphasis>beaucoup</emphasis> plus lent.
      </para>

      <para>
        Les développeurs de rust ont l'air de supposer que tout le monde compile sur
une machine dédiée aux constructions de production, donc par défaut tous les
CPU sont utilisés. Cela peut souvent être changé, soit en exportant
CARGO_BUILD_JOBS=&lt;N&gt; ou en passant --jobs &lt;N&gt; à cargo. Pour
compiler rustc lui-même, spécifiez --jobs &lt;N&gt; lors de l'invocation de
x.py (avec la variable d'environnement <envar>CARGO_BUILD_JOBS</envar>, ce
qui ressemble à une approche «&nbsp;ceinture et bretelle&nbsp;» mais a l'air
nécessaire). L'exception est le lancement des tests à la construction de
rustc, où certains d'entre eux utiliseront tout de même tous les CPU en
ligne, au moins à partir de rustc-1.42.0.
      </para>

  </sect2>

  <sect2 id="optimizations">
    <title>Optimisation de la construction</title>

      <para>
        De nombreuses personnes préfèrent optimiser la compilation à leur goût, en
fournissant CFLAGS ou CXXFLAGS. Vous trouverez une introduction aux options
disponibles avec gcc et g++ sur <ulink
url="https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html"/>, <ulink
url="https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html"/> et
dans <command>info gcc</command>.

      </para>

      <para>
        Certains paquets utilisent par défaut «&nbsp;-O2 -g&nbsp;», d'autres
«&nbsp;-O3 -g&nbsp;» et si les CFLAGS ou CXXFLAGS sont fournis ils peuvent
être ajoutés aux valeurs par défaut du paquet, remplacer les valeurs par
défaut ou même être ignorés. Il y a des détails sur les dernières versions
(en avril 2019) de certains paquets graphiques sur <ulink
url="https://www.linuxfromscratch.org/~ken/tuning/"/> — en particulier,
README.txt, tuning-1-packages-and-notes.txt et tuning-notes-2B.txt. Ce dont
il faut se souvenir, c'est que si vous voulez essayer certains des drapeaux
les plus intéressants vous devez forcer les constructions à être plus
verbeuses pour confirmer qu'elles sont utilisées.
      </para>

      <para>
        Clairement, si vous optimisez votre propre programme vous pouvez passer du
temps à effectuer des mesures et peut-être recoder certaines parties plutôt
lentes. Mais pour construire un système complet cette approche est
impossible. En général, -O3 produit des programmes plus rapides que
-O2. Spécifier -march=native est aussi bénéfique, mais cela signifie que
vous ne pouvez pas utiliser les binaires sur une machine incompatible — cela
s'applique aussi à des machines plus récentes, pas seulement à des machines
plus vieilles. Par exemple les programmes compilés pour
«&nbsp;amdfam10&nbsp;» peuvent tourner sur les vieux Phenoms, Kaveris et
Ryzens&nbsp;; mais les programmes compilés pour un Kaveri ne tourneront pas
sur un Ryzen parce que certains opcodes ne sont pas présents. De même, si
vous construisez pour un Haswell tout ne tournera pas sur un SandyBridge.
      </para>

      <para>
        Il y a aussi diverses autres options que certains pensent bénéfiques. Au
pire, vous devez recompiler et tester, pour découvrir que pour votre
utilisation ces options ne font rien de spécial.
      </para>

      <para>
        Si vous construisez des modules Perl ou Python, ou des paquets Qt qui
utilisent qmake, en général les CFLAGS et CXXFLAGS utilisés sont ceux
utilisés pour construire ces paquets «&nbsp;parents&nbsp;».
      </para>

  </sect2>

  <sect2 id="hardening">
    <title>Options pour durcir la construction</title>

      <para>
        Même sur un système de bureau, il y a des vulnérabilités exploitables. Pour
beaucoup, l'attaque vient de javascript dans un navigateur. Souvent, une
série de vulnérabilités sont utilisées pour récupérer un accès aux données
(ou parfois pour powner, c.-à-d. cracker la machine et installer des
rootkits). La plupart des distributions commerciales appliqueront diverses
mesures de durcissement.
      </para>

      <para>
        Par le passé, il existait un Hardened LFS (LFS durci) où gcc (une version
beaucoup plus vieille) était forcé à utiliser le durcissement (avec des
options pour les désactiver au cas par cas). Les livres LFS et BLFS actuels
portent encore une partie de cet esprit en activant PIE (<option>-fPIE
-pie</option>) et SSP (<option>-fstack-protector-strong</option>) dans les
options par défaut de GCC et de clang. Ce dont on parle ici est différent —
vous devrez déjà vous assurer que le paquet utilise bien vos options
supplémentaires et qu'il ne les écrase pas.
      </para>

      <para>
        Pour les options de durcissement qui sont raisonnablement peu coûteuses, on
en parle un peu dans le lien sur les expériences de peaufinage précédent
(parfois une ou plus de ces options peuvent être inappropriées pour un
paquet). Ces options sont <option>-D_FORTIFY_SOURCE=2</option> et (pour C++)
<option>-D_GLIBCXX_ASSERTIONS</option>. Sur les machines modernes elles ne
devraient avoir qu'un très faible impact sur la vitesse des programmes et
souvent ne seront même pas perceptibles.
      </para>

      <para>
        Les distros principales utilisent bien plus, comme RELRO (Relocation Read
Only) et parfois <option>-fstack-clash-protection</option>. Vous pouvez
aussi rencontrer les <quote>retpolines en espace utilisateur</quote>
(<option>-mindirect-branch=thunk</option> etc) qui sont équivalents aux
atténuations de spectre appliquées au noyau Linux fin 2018. Les atténuations
du noyau ont causé de nombreuses plaintes à propos d'une perte de
performance, donc si vous avez un serveur en production vous devriez
peut-être tester ça ainsi que d'autres options disponibles, pour voir si les
performances sont toujours satisfaisantes.
      </para>

      <para>
        Tandis que gcc a de nombreuses options de durcissement, la force de
clang/LLVM se trouve ailleurs. Certaines options fournies par gcc sont dites
moins efficaces dans clang/LLVM.
      </para>

  </sect2>

</sect1>
