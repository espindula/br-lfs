<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../../general.ent">
  %general-entities;
]>

<sect1 id="unpacking">
  <?dbhtml filename="notes-on-building.html"?>


  <title>Remarques sur la construction de logiciels</title>

  <para>Celles et ceux qui ont construit un système LFS connaissent sans doute les
principes généraux du téléchargement et de l'extraction de
logiciel. Certaines de ces informations sont répétées ici pour les nouveaux
qui construisent leurs propres logiciels.</para>

  <para>Chaque ensemble d'instructions d'installation contient une URL sur laquelle
laquelle vous pouvez télécharger le paquet. Cependant, les correctifs sont
enregistrés sur les serveurs LFS et disponibles via HTTP. Ces derniers sont
référencés, si besoin, dans les instructions d'installation.</para>

  <para>Même si vous pouvez placer les fichiers sources où vous voulez, nous
supposons que vous avez extrait le paquet et êtes allé dans le répertoire
créé par le processus de décompression (le répertoire des sources). Nous
supposons aussi que vous avez décompressé les correctifs requis et qu'ils
sont dans le répertoire directement au-dessus du répertoire des sources.</para>

  <para>Nous ne saurions que trop vous recommander de démarrer à partir d'une
<emphasis>arborescence de sources propre</emphasis> à chaque fois.  Cela
veut dire que si vous avez eu une erreur lors de la configuration ou de la
compilation, il est généralement préférable de supprimer l'arborescence des
sources et de l'extraire de nouveau <emphasis>avant</emphasis> de
réessayer. Cela ne s'applique évidemment pas si vous êtes un utilisateur
avancé habitué à modifier les <filename>Makefile</filename>s et le code
C. Si vous avez un doute cependant, commencez à partir d'une arborescence
propre.</para>

  <sect2>
    <title>Construction de logiciels en tant qu'utilisateur non privilégié (non root)</title>

    <para>La règle d'or de l'administration d'un système Unix est de n'utiliser vos
super-pouvoirs que si nécessaire. D'où la recommandation de BLFS de
construire les logiciels en tant qu'utilisateur non privilégié et de ne
devenir l'utilisateur <systemitem class='username'>root</systemitem> que
lors de l'installation du logiciel. On suit cette philosophie dans tous les
paquets de ce livre. Sauf spécifications contraires, toutes les instructions
devraient être exécutées en tant qu'utilisateur non privilégié. Le livre
vous conseillera sur les instructions qui ont besoin des privilèges
<systemitem class='username'>root</systemitem>.</para>

  </sect2>

  <sect2>
    <title>Décompresser le logiciel</title>

    <para>S'il y a un fichier compressé au format <filename
class='extension'>.tar</filename>, on le décompresse en utilisant une des
commandes suivantes&nbsp;:</para>

<screen><userinput>tar -xvf filename.tar.gz
tar -xvf filename.tgz
tar -xvf filename.tar.Z
tar -xvf filename.tar.bz2</userinput></screen>

    <note>
      <para>Vous pouvez ne pas utiliser le paramètre <option>v</option> dans les
commandes décrites ci-dessus et ci-dessous si vous souhaitez supprimer le
listage verbeux de tous les fichiers de l'archive au fur et à mesure qu'ils
sont extraits. Cela peut aider à accélérer l'extraction mais aussi rendre
plus évidentes les erreurs produites durant le processus.</para>
    </note>

    <para>Vous pouvez aussi utiliser une méthode légèrement différente&nbsp;:</para>

<screen><userinput>bzcat filename.tar.bz2 | tar -xv</userinput></screen>

    <para>
      Enfin, nous avons parfois un fichier de correctif compressé au format
<filename class='extension'>.patch.gz</filename> ou <filename
class='extension'>.patch.bz2</filename>. La meilleure manière d'applique le
correctif est de passer la sortie du décompresseur à l'utilitaire
<command>patch</command> via un pipe. Par exemple&nbsp;:
    </para>

    <screen><userinput>gzip -cd ../patchname.patch.gz | patch -p1</userinput></screen>

    <para>
      Ou pour un correctif compressé avec <command>bzip2</command>&nbsp;:
    </para>

    <screen><userinput>bzcat ../patchname.patch.bz2 | patch -p1</userinput></screen>

  </sect2>

  <sect2>
    <title>Vérifier l'intégrité des fichiers</title>

    <para>En général, pour vérifier que le fichier téléchargé est complet, de nombreux
mainteneurs de paquets distribuent aussi les sommes md5 des fichiers. Pour
vérifier la somme md5 des fichiers téléchargés, téléchargez à la fois le
fichier et le fichier md5sum correspondant dans le même répertoire (de
préférence à partir d'emplacements différents en ligne)  et (en supposant
que <filename>file.md5sum</filename> est le fichier md5sum téléchargé),
lancez la commande suivante&nbsp;:</para>

<screen><userinput>md5sum -c file.md5sum</userinput></screen>

    <para>S'il y a une erreur, elle sera signalée. Remarquez que le livre BLFS
contient aussi les sommes md5 de tous les fichiers sources. Pour utiliser
les sommes md5 fournies par BLFS, vous pouvez créer un
<filename>file.md5sum</filename> (mettez les données md5sum et le nom exact
du fichier téléchargé sur la même ligne d'un fichier, séparés par un espace
blanc), et lancez la commande montrée ci-dessus. Sinon, lancez simplement la
commande décrite ci-dessus et comparez la sortie avec les données de somme
md5 inscrites dans le livre BLFS.</para>

<screen><userinput>md5sum <replaceable>&lt;name_of_downloaded_file&gt;</replaceable></userinput></screen>

    <para>Le MD5 n'est pas cryptographiquement sûr, donc les sommes md5 ne sont
fournies que pour détecter des changements non intentionnels au contenu du
fichier. Par exemple, une erreur ou troncation introduite pendant le
transfert réseau, ou une mise à jour <quote>furtive</quote> du paquet en
amont (mise à jour du contenu d'une archive publiée au lieu de créer
directement une nouvelle version).</para>

    <para>Il n'y a pas de manière sure à <quote>100 %</quote> pour s'assurer de
l'authenticité des fichiers sources. En supposant que les développeurs en
amont gèrent leur site correctement (la clé privée n'est pas communiquée et
le domaine n'est pas usurpé), et que les ancres de confiance ont été
correctement configurées avec <xref linkend="make-ca"/> sur le système BLFS,
on peut raisonnablement faire confiance aux URL des site web officiels
<emphasis role="bold">avec le protocole https</emphasis>. Remarquez que le
livre BLFS lui-même est publié sur un site avec https, donc vous devez déjà
avoir un peu confiance en le protocole https ou vous ne pourriez pas faire
confiance au contenu de ce livre.</para>

    <para>Si le paquet est téléchargé à partir d'un emplacement non officiel (par
exemple un miroir local), vous pouvez utiliser des sommes de contrôles
générées par un algorithme cryptographiquement sûr (par exemple SHA256) pour
vérifier l'authenticité du paquet. Téléchargez le fichier de somme de
contrôle depuis le site <emphasis role="bold">officiel</emphasis> des
développeurs en amont (ou depuis un endroit <emphasis role="bold">auquel
vous faites confiance</emphasis>) et comparez la somme de contrôle du paquet
de l'emplacement non officiel. Par exemple, vous pouvez vérifier une somme
de contrôle SHA256 avec la commande&nbsp;:</para>

    <note>
      <para>Si la somme de contrôle et le paquet sont téléchargés à partir de la même
source non fiable, vous ne gagnerez rien à vérifier le paquet avec la somme
de contrôle. L'attaquant peut présenter une fausse somme de contrôle en plus
de compromettre le paquet en lui-même.</para>
    </note>

<screen><userinput>sha256sum -c <replaceable>file</replaceable>.sha256sum</userinput></screen>

    <para>Si <xref linkend="gnupg2"/> est installé, vous pouvez aussi vérifier
l'authenticité du paquet avec une signature GPG. Importez la clé publique
GPG amont avec&nbsp;:</para>

<screen><userinput>gpg --recv-key <replaceable>keyID</replaceable></userinput></screen>

    <para><replaceable>keyID</replaceable> devrait être remplacée par l'identifiant de
la clé fournie par un site <emphasis role="bold">fiable</emphasis> (par
exemple, copiez-la depuis le site officiel en utilisant https). Maintenant
vous pouvez vérifier la signature avec&nbsp;:</para>

<screen><userinput>gpg --recv-key <replaceable>file</replaceable>.sig <replaceable>file</replaceable></userinput></screen>

    <para>L'avantage de la signature <application>GnuPG</application> est que, une
fois une clé publique de confiance importée, vous pouvez télécharger à la
fois le paquet et sa signature à partir du même emplacement non officiel et
les vérifier avec la clé publique. Donc vous n'avez pas besoin de vous
connecter au site officiel en amont pour récupérer une somme de contrôle
pour chaque nouvelle version. Vous n'aurez besoin de mettre à jour la clé
publique que si elle est révoquée ou expirée.
    </para>

  </sect2>

  <sect2>
    <title>Créer des fichiers journaux pendant l'installation</title>

    <para>Pour les gros paquets, il est commode de créer des fichiers journaux plutôt
que de fixer indéfiniment l'écran en espérant trouver une erreur ou un
avertissement particulier. Les fichiers journaux sont aussi utiles pour
déboguer et garder des enregistrements. La commande suivante vous permet de
créer un journal d'installation. Remplacez
<replaceable>&lt;commande&gt;</replaceable> par la commande que vous
cherchez à exécuter.</para>

<screen><userinput>( <replaceable>&lt;command&gt;</replaceable> 2&gt;&amp;1 | tee compile.log &amp;&amp; exit $PIPESTATUS )</userinput></screen>

    <para><option>2&gt;&amp;1</option> redirige les messages d'erreur vers le même
endroit que la sortie standard. La commande <command>tee</command> vous
permet de voir la sortie en journalisant les résultats dans un fichier. Les
parenthèses autour de la commande exécutent toute la commande dans un
sous-shell. Enfin, la commande <command>exit $PIPESTATUS</command> s'assure
que c'est bien le résultat de <replaceable>&lt;commande&gt;</replaceable>
qui est retourné et pas le résultat de la commande <command>tee</command>.</para>

  </sect2>

  <sect2 id="parallel-builds" xreflabel="Utilisation de processeurs multiples">
    <title>Utilisation de processeurs multiples</title>

    <para>Pour la plupart des systèmes modernes avec des processeurs multiples (ou
cœurs) le temps de compilation pour un paquet peut être réduit en effectuant
une «&nbsp;construction parallèle&nbsp;» soit en initialisant une variable
d'environnement, soit en disant au programme make combien de processeurs
sont disponibles. Par exemple, un Core2Duo peut supporter deux processus
simultanés avec&nbsp;: </para>

    <screen><userinput>export MAKEFLAGS='-j2'</userinput></screen>

    <para>ou en compilant simplement avec&nbsp;:</para>

    <screen><userinput>make -j2</userinput></screen>

    <para>
      Si vous avez appliqué le <command>sed</command> facultatif pendant la
construction de <application>ninja</application> dans LFS, vous pouvez
utiliser&nbsp;:
    </para>

    <screen><userinput>export NINJAJOBS=2</userinput></screen>

    <para>
      quand un paquet utilise <command>ninja</command>, ou simplement&nbsp;:
    </para>

    <screen><userinput>ninja -j2</userinput></screen>

    <para>
      but for ninja, the default number of jobs is N + 2, if the number of logical
processors N is greater than 2; or N + 1 if N is 1 or 2.  The reason to use
a number of jobs slightly greater than the number of logical processors is
keeping all logical processors busy even if some jobs are performing I/O
operations.
    </para>

    <para>Généralement le nombre de processus ne doit pas trop dépasser le nombre de
cœurs supportés par le CPU. Pour lister les processeurs de votre système,
tapez&nbsp;: <userinput>grep processor /proc/cpuinfo</userinput>.
    </para>

    <para>Dans certains cas, l'utilisation de processeurs multiples peut amener dans
une situation de compétition où le succès de la construction dépend de
l'ordre des commandes lancées par le programme <command>make</command>. Par
exemple, si un exécutable demande un fichier A et un fichier B, essayer de
lier le programme avant qu'un des composants dépendants ne soit disponible
aboutira à un échec.  Cela arrive en général quand les développeurs n'ont
pas correctement désigné tous les prérequis utiles pour accomplir une étape
du Makefile.</para>

    <para>Si cela arrive, la meilleure chose à faire est de recommencer la
construction avec un seul processeur. En ajoutant <option>-j1</option> à une
commande make, cela écrasera l'initialisation similaire dans une variable
d'environnement <envar>MAKEFLAGS</envar>.</para>

    <!-- outdated
    <note>
<para>When running the package tests or the install portion of the
    package build process, we do not recommend using an option greater than
    '-j1' unless specified otherwise.  The installation procedures or checks
    have not been validated using parallel procedures and may fail with issues
    that are difficult to debug.</para></note>
-->
<important>
      <para>
        Un autre problème peut survenir avec les CPU modernes avec beaucoup de
cœurs. Chaque tâche démarrée consomme de la mémoire, et si la somme de la
mémoire requise par chaque tâche dépasse la quantité de mémoire disponible,
vous aurez soit une interruption noyau OOM (plus de mémoire) ou une
utilisation de l'espace d'échange qui ralentira excessivement la
construction.
      </para>

      <para>
        Comme certaines compilation avec <command>g++</command> peuvent consommer
jusqu'à 2,5 Go de mémoire, pour être sûr, vous devriez restreindre le nombre
de tâches à (mémoire totale en Go)/2,5, au moins pour les gros paquets comme
LLVM, WebKitGtk, QtWebEngine ou libreoffice.
      </para>
    </important>
  </sect2>

  <sect2 id="automating-builds" xreflabel="Procédures de construction automatique">
    <title>Procédures de construction automatique</title>

    <para>Automatiser la construction d'un paquet peut parfois s'avérer utile. On a
tous des raisons différentes pour automatiser la construction, et on le fait
par nos propres moyens. Soit en créant des <filename>Makefile</filename>s,
des scripts <application>Bash</application>, des scripts
<application>Perl</application> ou simplement une liste de commandes
utilisées à copier-coller. Ce sont toutes des méthodes que vous pouvez
utiliser pour automatiser la construction de paquets BLFS. Détailler et
donner des exemples sur les nombreuses manières d'automatiser la
construction de paquets va au-delà des objectifs de cette section. Cette
section vous présentera l'utilisation de la redirection de fichiers et de la
commande <command>yes</command> pour vous donner des idées sur la façon
d'automatiser vos constructions.</para>

    <bridgehead renderas="sect3">Redirection de fichier pour automatiser l'entrée</bridgehead>

    <para>Il y aura des moments, tout au long de votre aventure BLFS, où vous tomberez
sur un paquet ayant une invite de commande vous demandant des
informations. Ces informations peuvent être des détails de configuration, un
chemin de répertoire ou une réponse à un accord de licence. Cela peut être
un challenge pour automatiser la construction de ce paquet. On vous
demandera occasionnellement différentes informations via une série de
questions. Une méthode pour automatiser ce type de scénario est de mettre
les réponses désirées dans un fichier et d'utiliser la redirection pour que
le programme utilise les données du fichier comme réponses aux questions.</para>

    <!-- outdated
    <para>
Building the <application>CUPS</application> package is a good
    example of how redirecting a file as input to prompts can help you automate
    the build. If you run the test suite, you are asked to respond to a series
    of questions regarding the type of test to run and if you have any
    auxiliary programs the test can use. You can create a file with your
    responses, one response per line, and use a command similar to the
    one shown below to automate running the test suite:</para>

<screen><userinput>make check &lt; ../cups-1.1.23-testsuite_parms</userinput></screen>
-->
<para>Cela fait logiquement utilise les réponses du fichier comme entrée pour les
questions de la suite de tests. Vous aurez parfois à faire des séries
d'essais et erreurs pour déterminer le format exact de votre fichier
d'entrée pour certaines choses, mais une fois expérimenté et documenté, vous
pouvez utiliser cela pour automatiser la construction du paquet.</para>

    <bridgehead renderas="sect3">Utiliser <command>yes</command> pour automatiser l'entrée</bridgehead>

    <para>Vous n'aurez parfois besoin de ne fournir qu'une réponse ou alors la même
réponse à de nombreuses invites. Dans ces cas-là, la commande
<command>yes</command> fonctionne vraiment bien.  On peut utiliser la
commande <command>yes</command> pour fournir une réponse (la même) à une ou
plusieurs questions. On peut l'utiliser pour simuler un simple appui sur la
touche <keycap>Entrée</keycap>, l'entrée de la touche <keycap>Y</keycap> ou
l'entrée d'une chaîne de texte. La manière la plus facile de montrer son
utilisation est peut-être de prendre un exemple.</para>

    <para>Créez tout d'abord un petit script <application>Bash</application> en
entrant les commandes suivantes&nbsp;:</para>

<screen><userinput>cat &gt; blfs-yes-test1 &lt;&lt; "EOF"
<literal>#!/bin/bash

echo -n -e "\n\nPlease type something (or nothing) and press Enter ---> "

read A_STRING

if test "$A_STRING" = ""; then A_STRING="Just the Enter key was pressed"
else A_STRING="You entered '$A_STRING'"
fi

echo -e "\n\n$A_STRING\n\n"</literal>
EOF
chmod 755 blfs-yes-test1</userinput></screen>

    <para>Maintenant, lancez le script en exécutant
<command>./blfs-yes-test1</command> depuis la ligne de commande. Il attendra
une réponse, qui peut être n'importe quoi (ou rien) suivi de la touche
<keycap>Entrée</keycap>. Après avoir entré quelque chose, le résultat sera
affiché à l'écran. Utilisez maintenant la commande <command>yes</command>
pour automatiser l'entrée d'une réponse&nbsp;:</para>

<screen><userinput>yes | ./blfs-yes-test1</userinput></screen>

    <para>Remarquez que la redirection (le piping) de <command>yes</command> en
lui-même vers le script aboutit à ce que <keycap>y</keycap> est passé au
script. Essayez-la maintenant avec une chaîne de texte&nbsp;:</para>

<screen><userinput>yes 'This is some text' | ./blfs-yes-test1</userinput></screen>

    <para>La chaîne exacte était utilisée comme réponse au script. Enfin, essayez-la
en utilisant une chaîne vide (null)&nbsp;:</para>

<screen><userinput>yes '' | ./blfs-yes-test1</userinput></screen>

    <para>Remarquez que cela aboutit à ne passer au script que l'appui sur la touche
<keycap>Entrée</keycap>. C'est utile parfois quand la réponse par défaut à
l'invite est suffisante. Cette syntaxe est utilisée dans les instructions de
<xref linkend="net-tools-automate-example"/> pour accepter tous les réglages
par défaut à toutes les invites lors de l'étape de configuration.  Vous
pouvez maintenant supprimer le script de test si vous le désirez.</para>

    <bridgehead renderas="sect3">Redirection de fichiers pour automatiser la sortie</bridgehead>

    <para>Pour automatiser la construction de certains paquets, surtout ceux qui vous
demandent de lire un accord de licence page après page, il faut utiliser une
méthode qui évite de devoir appuyer sur une touche pour afficher chaque
page. On peut utiliser la redirection de sortie vers un fichier dans ce
cas-là pour vous aider à automatiser. La section précédente de cette page a
visé à créer des fichiers journaux de la sortie de la construction.  La
méthode de redirection qui y est décrite utilisait la commande
<command>tee</command> pour rediriger la sortie tout en affichant aussi la
sortie à l'écran. Ici on ne verra la sortie que dans un fichier.</para>

    <para>De nouveau, la manière la plus facile de montrer la technique est de
présenter un exemple. Lancez d'abord la commande&nbsp;:</para>

<screen><userinput>ls -l /usr/bin | less</userinput></screen>

    <para>Bien entendu, vous devrez voir la sortie page par page car on a utilisé le
filtre <command>less</command>. Essayez maintenant la même commande, mais en
redirigeant cette fois la sortie vers un fichier. Le fichier spécial
<filename>/dev/null</filename> peut être utilisé à la place du fichier
indiqué, mais vous n'aurez pas de fichier journal à examiner&nbsp;:</para>

<screen><userinput>ls -l /usr/bin | less &gt; redirect_test.log 2&gt;&amp;1</userinput></screen>

    <para>Vous remarquerez que cette fois, la commande est immédiatement revenue à
l'invite du shell sans devoir parcourir la sortie page par page. Vous pouvez
maintenant supprimer le fichier journal.</para>

    <para>Le dernier exemple utilisera la commande <command>yes</command> associée à
la redirection de sortie pour éviter de naviguer page par page dans la
sortie, puis de fournir un <keycap>y</keycap> à l'invite. Cette technique
peut être utilisée dans les cas où vous devriez, sans elle, naviguer page
par page dans la sortie d'un fichier (tel qu'un accord de licence), puis
répondre à la question <quote>Acceptez-vous ce qui précède&nbsp;?</quote>.
Pour cet exemple, on a besoin d'un autre petit script
<application>Bash</application>&nbsp;:</para>

<screen><userinput>cat &gt; blfs-yes-test2 &lt;&lt; "EOF"
<literal>#!/bin/bash

ls -l /usr/bin | less

echo -n -e "\n\nDid you enjoy reading this? (y,n) "

read A_STRING

if test "$A_STRING" = "y"; then A_STRING="You entered the 'y' key"
else A_STRING="You did NOT enter the 'y' key"
fi

echo -e "\n\n$A_STRING\n\n"</literal>
EOF
chmod 755 blfs-yes-test2</userinput></screen>

    <para>On peut utiliser ce script pour simuler un programme qui demande que vous
lisiez un accord de licence et que vous acceptiez le contrat avant que le
programme n'installe quoique ce soit. Lancez d'abord le script sans
techniques d'automatisation en exécutant
<command>./blfs-yes-test2</command>.</para>

    <para>Maintenant lancez la commande suivante qui utilise deux techniques
d'automatisation, rendant l'utilisation convenable dans un script de
construction automatisé&nbsp;:</para>

<screen><userinput>yes | ./blfs-yes-test2 &gt; blfs-yes-test2.log 2&gt;&amp;1</userinput></screen>

    <para>Si vous le désirez, lancez <command>tail blfs-yes-test2.log</command> pour
voir la fin de la sortie paginée et la confirmation que <keycap>y</keycap> a
été passé au script. Une fois que cela marche comme cela devrait, vous
pouvez supprimer le script et le fichier journal.</para>

    <para>Enfin, gardez à l'esprit qu'il y a de nombreux moyens d'automatiser ou de
scripter les commandes de construction. Il n'y a pas <quote>une
seule</quote> manière de procéder. Votre imagination est la seule limite.</para>

  </sect2>

  <sect2>
    <title>Dépendances</title>

    <para>Pour chaque paquet décrit, BLFS liste les dépendances connues. Elles sont
listées sous plusieurs en-têtes, dont la signification est la
suivante&nbsp;:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>Requis</emphasis> signifie que le paquet cible ne peut pas se
construire correctement sans avoir d'abord installé la dépendance, sauf si
la dépendance est dite <quote>à l'exécution</quote>, ce qui signifie que le
paquet cible peut être construit mais ne peut pas fonctionner sans elle.</para>
        <para>
          Remarquez qu'un paquet cible peut commencer à <quote>fonctionner</quote> de
plusieurs manières subtiles&nbsp;: un fichier de configuration installé peut
le faire exécuter au système d'initialisation, au démon cron ou au démon de
bus automatiquement. Ou bien un autre paquet qui utilise le paquet cible en
dépendance peut exécuter le programme du paquet cible dans son système de
construction. Ou encore, les sections de configuration du livre BLFS peuvent
également exécuter un problème du paquet tout juste installé. Si vous
installez le paquet cible sans un dépendance <emphasis>Requise (à
l'exécution)</emphasis>, vous devriez installer la dépendance aussi vite que
possible après l'installation du paquet cible.
        </para>
      </listitem>
      <listitem>
        <para><emphasis>Recommended</emphasis> means that BLFS strongly suggests this
package is installed first (except if said to be <quote>runtime</quote>, see
below) for a clean and trouble-free build, that won't have issues either
during the build process, or at run-time.  The instructions in the book
assume these packages are installed.  Some changes or workarounds may be
required if these packages are not installed. If a recommended dependency is
said to be <quote>runtime</quote>, it means that BLFS strongly suggests that
this dependency is installed before using the package, for getting full
functionality.</para>
      </listitem>
      <listitem>
        <para><emphasis>Facultatives</emphasis> signifie que ce paquet peut être installé
pour ajouter une fonctionnalité. Souvent BLFS décrira la dépendance pour
expliquer la fonctionnalité ajoutée. Une dépendance facultative peut être
automatiquement trouvée par le paquet cible si la dépendance est installée,
mais d'autres dépendances facultatives peuvent également nécessiter des
options de configuration supplémentaires pour les activer à la construction
du paquet cible. Ces options seront documentées dans le livre BLFS. Si un
dépendance facultative est dite <quote>à l'exécution</quote>, cela signifie
que vous pouvez installer la dépendance après l'installation du paquet cible
pour prendre en charge des fonctionnalités facultatives du paquet cible si
vous en avez besoin.</para>
        <para>Une dépendance facultative peut se trouver en dehors de BLFS. Si vous avez
besoin d'une dépendance facultative <emphasis>externe</emphasis> pour des
fonctionnalités, consultez <xref linkend='beyond'/> pour trouver l'aide
générique sur l'installation des paquets en dehors de BLFS.</para>
      </listitem>
    </itemizedlist>

  </sect2>

  <sect2 id="package_updates">
    <title>Utilisation de paquets sources les plus récents</title>

    <para>Il peut arriver occasionnellement qu'un paquet ne se construise pas ou ne
fonctionne pas correctement dans le livre. Bien que les éditeurs tentent de
faire en sorte que chaque paquet dans le livre se construise et fonctionne
correctement, il arrive parfois qu'un paquet ait été oublié ou n'ait pas été
testé avec cette version particulière de BLFS.</para>

    <para>Si vous découvrez un paquet qui ne se construit pas ou ne fonctionne pas
correctement, vous pouvez regarder s'il s'agit de la version la plus récente
du paquet. En général, cela signifie que vous devez vous rendre sur le site
web du responsable, télécharger l'archive la plus récente et tenter de
construire le paquet. Si vous ne pouvez pas déterminer le site web du
responsable en regardant l'URL de chargement, utilisez Google et cherchez le
nom du paquet. Par exemple, dans la barre de recherche de Google
tapez&nbsp;: «&nbsp;nom_du_paquet download&nbsp;» (sans les guillemets) ou
quelque chose de similaire. Parfois en tapant&nbsp;: «&nbsp;nom_du_paquet
home page&nbsp;» vous trouverez le site web du responsable.</para>

  </sect2>

  <sect2 id="stripping">
    <title>Nettoyage une fois de plus</title>

    <para>
      Dans LFS, le nettoyage des symboles de débogage et des entrées de la table
des symboles inutiles a été abordé plusieurs fois.  Pour la construction des
paquets BLFS, il n'y a généralement pas d'instructions qui abordent de
nouveau le nettoyage. Le nettoyage peut avoir lieu après l'installation d'un
paquet, ou plus tard.
    </para>

    <bridgehead renderas="sect3" id="stripping-install">Nettoyage à l'installation d'un paquet</bridgehead>

    <para>
      Il y a plusieurs manières de nettoyer les exécutables installés par un
paquet. Elles dépendent du système de construction utilisé (voir plus bas
<link linkend="buildsystems">la section sur les systèmes de
construction</link>), c'est pourquoi nous ne listons que quelques
généralités ici&nbsp;:
    </para>

    <note>
      <para>
        Les méthodes suivantes qui utilisent la fonctionnalité d'un système de
construction (autotools, meson ou cmake) ne nettoieront pas les
bibliothèques statiques si elles sont installées. Heureusement il n'y a pas
tant de bibliothèques statiques dans BLFS et une bibliothèque statique peut
toujours être nettoyée sans problème en exécutant <command>strip
--strip-unneeded</command> dessus manuellement.
      </para>
    </note>

    <itemizedlist>
      <listitem>
        <para>
          Les paquets qui utilisent les autotools ont habituellement une cible
<parameter>install-strip</parameter> dans leur fichier
<filename>Makefile</filename> généré. Donc installer des exécutables
nettoyer est aussi simple qu'utiliser <command>make install-strip</command>
au lieu de <command>make install</command>.
        </para>
      </listitem>
      <listitem>
        <para>
          Les paquets qui utilisent le système de construction meson acceptent
<parameter>-Dstrip=true</parameter> au lancement de
<command>meson</command>. Si vous avez oublié d'ajouter cette option en
lançant <command>meson</command>, vous pouvez aussi lancer <command>meson
install --strip</command> au lieu de <command>ninja install</command>.
        </para>
      </listitem>
      <listitem>
        <para>
          <command>cmake</command> génère des cibles
<parameter>install/strip</parameter> aussi bien pour le générateur de
<parameter>Makefiles Unix</parameter> que pour le générateur
<parameter>Ninja</parameter> (par défaut c'est le générateur de
<parameter>Makefiles Unix</parameter> qui sera utilisé sur linux). Lancez
simplement <command>make install/strip</command> ou <command>ninja
install/strip</command> au lieu de l'équivalent avec
<command>install</command>.
        </para>
      </listitem>
      <listitem>
        <para>
          Supprimer (ou éviter de générer) les symboles de débogage peut aussi se
faire en supprimant les options <parameter>-g&lt;quelque
chose&gt;</parameter> dans les appels au compilateur C/C++. La manière de
procéder est spécifique à chaque paquet. En plus, cela ne supprime pas les
entrées inutiles de la table des symboles. Nous ne l'expliquons donc pas
ici. Voir plus bas les paragraphes sur l'optimisation.
        </para>
      </listitem>
    </itemizedlist>

    <bridgehead renderas="sect3" id="stripping-installed">Nettoyer les exécutables installés</bridgehead>

    <para>
      L'utilitaire <command>strip</command> modifie les fichiers en place, ce qui
peut casser tout ce qui l'utilise s'il est chargé en mémoire. Remarquez que
si un fichier est utilisé mais simplement supprimé du disque (c.-à-d. pas
écrasé ou modifié), ce n'est pas un problème car le noyau peut utiliser des
fichiers <quote>supprimés</quote>. Regardez dans
<filename>/proc/*/maps</filename>, et il est probable que vous verrez des
entrées <emphasis>(deleted)</emphasis>. La commande <command>mv</command>
supprime seulement le fichier de destination du répertoire mais ne change
pas son contenu, donc elle satisfait aux conditions pour que le noyau
utilise l'ancien fichier supprimé. Mais cette approche peut détacher des
liens en dur et créer des copies dupliquées, causant une plus forte
utilisation du disque, ce qui n'est évidemment pas souhaitable quand nous
nettoyons pour réduire la taille du système. Si deux fichiers du même
système de fichiers partage le même numéro d'inœud, ils sont liés en dur et
nous devrions reconstruire le lien. Le script ci-dessous est juste un
exemple. Il devrait être lancé en &root;&nbsp;:
    </para>

<screen><userinput>cat &gt; /usr/sbin/strip-all.sh &lt;&lt; "EOF"
<literal>#!/usr/bin/bash

if [ $EUID -ne 0 ]; then
  echo "Need to be root"
  exit 1
fi

last_fs_inode=
last_file=

{ find /usr/lib -type f -name '*.so*' ! -name '*dbg'
  find /usr/lib -type f -name '*.a'
  find /usr/{bin,sbin,libexec} -type f
} | xargs stat -c '%m %i %n' | sort | while read fs inode file; do
       if ! readelf -h $file >/dev/null 2>&amp;1; then continue; fi
       if file $file | grep --quiet --invert-match 'not stripped'; then continue; fi

       if [ "$fs $inode" = "$last_fs_inode" ]; then
         ln -f $last_file $file;
         continue;
       fi

       cp --preserve $file    ${file}.tmp
       strip --strip-unneeded ${file}.tmp
       mv ${file}.tmp $file

       last_fs_inode="$fs $inode"
       last_file=$file
done</literal>
EOF
chmod 744 /usr/sbin/strip-all.sh</userinput></screen>

    <para>
      Si vous installez des programmes dans d'autres répertoires tels que
<filename class="directory">/opt</filename> ou <filename
class="directory">/usr/local</filename>, vous pouvez vouloir nettoyer les
fichiers ici aussi. Ajoutez simplement d'autres répertoires à scanner dans
la liste des commandes <command>find</command> entre accolades.
    </para>

    <para>
      Pour plus d'information sur le nettoyage, regardez <ulink
url="https://www.technovelty.org/linux/stripping-shared-libraries.html"/>.
    </para>

  </sect2>


  <!--
  <sect2 id="libtool">

    <title>Libtool files</title>

    <para>
      One of the side effects of packages that use Autotools, including
      libtool, is that they create many files with an .la extension.  These
      files are not needed in an LFS environment.  If there are conflicts with
      pkgconfig entries, they can actually prevent successful builds.  You
      may want to consider removing these files periodically:
    </para>

<screen><userinput>find /lib /usr/lib -not -path "*Image*" -a -name \*.la -delete</userinput></screen>

    <para>
      The above command removes all .la files with the exception of those that
      have <quote>Image</quote> or <quote>openldap</quote> as a part of the
      path.  These .la files are used by the ImageMagick and openldap programs,
      respectively.  There may be other exceptions by packages not in BLFS.
    </para>

  </sect2>
-->
<sect2 id="buildsystems">
    <title>Travailler avec différents systèmes de construction</title>

    <para>
      There are now three different build systems in common use for converting C
or C++ source code into compiled programs or libraries and their details
(particularly, finding out about available options and their default values)
differ. It may be easiest to understand the issues caused by some choices
(typically slow execution or unexpected use of, or omission of,
optimizations) by starting with the <envar>CFLAGS</envar>,
<envar>CXXFLAGS</envar>, and <envar>LDFLAGS</envar> environment variables.
There are also some programs which use Rust.
    </para>

    <para>
      La plupart des lecteurs de LFS et de BLFS connaissent probablement déjà les
bases de l'utilisation de <envar>CFLAGS</envar> et <envar>CXXFLAGS</envar>
pour altérer la compilation d'un programme. En général, certaines formes
d'optimisations sont utilisées par les développeurs en amont
(<option>-O2</option> ou <option>-O3</option>), parfois avec la création de
symboles de débogage (<option>-g</option>) par défaut.
    </para>

    <para>
      S'il y a des drapeaux contradictoires (p. ex. plusieurs valeurs différentes
de <option>-O</option>), la <emphasis>dernière</emphasis> valeur sera
utilisée. Parfois les drapeaux spécifiés dans les variables d'environnement
sont insérés avant les valeurs en dur dans le Makefile, ce qui signifie
qu'ils sont ignorés. Par exemple, si un utilisateur spécifie
<option>-O2</option>et qu'il est suivi de <option>-O3</option>, la
construction utilisera <option>-O3</option>.
    </para>

    <para>
      There are various other things which can be passed in CFLAGS or CXXFLAGS,
such as allowing using the instruction set extensions available with a
specific microarchitecture (e.g.  <option>-march=amdfam10</option> or
<option>-march=native</option>), tune the generated code for a specific
microarchitecture (e. g.  <option>-mtune=tigerlake</option> or
<option>-mtune=native</option>, if <option>-mtune=</option> is not used, the
microarchitecture from <option>-march=</option> setting will be used), or
specifying a specific standard for C or C++ (<option>-std=c++17</option> for
example).  But one thing which has now come to light is that programmers
might include debug assertions in their code, expecting them to be disabled
in releases by using <option>-DNDEBUG</option>.  Specifically, if <xref
linkend="mesa"/> is built with these assertions enabled, some activities
such as loading levels of games can take extremely long times, even on
high-class video cards.
    </para>

    <bridgehead renderas="sect3" id="autotools-info">Autotools avec Make</bridgehead>

      <para>
        Cette combinaison est souvent décrite comme <quote>CMMI</quote> (configure,
make, make install) et est utilisée ici pour couvrir aussi certains paquets
dont le script configure n'a pas été généré par les autotools.
      </para>

      <para>
        Parfois lancer <command>./configure --help</command> affichera les options
utiles des paramètres qui peuvent être utilisés. D'autres fois, après avoir
regardé la sortie de configure vous pourriez avoir besoin de regarder les
détails du script pour comprendre ce qu'il cherchait vraiment.
      </para>

      <para>
       De nombreux scripts configure récupéreront les CFLAGS et CXXFLAGS de
l'environnement, mais les paquets CMMI varient dans la manière dont ils
seront insérés avec les drapeaux qui sinon seraient utilisés (<emphasis>au
choix</emphasis>&nbsp;: ignorés, utilisés à la place de la suggestion des
programmeurs, utilisés avant la suggestion des programmeurs ou utilisés
après la suggestion des programmeurs).
      </para>

      <para>
        Dans la plupart des paquets CMMI, <command>make</command> listera les
commandes lancées, séparées par des avertissements éventuels. Mais certains
paquets essayent d'être <quote>silencieux</quote> et ne montrent que les
fichiers qu'ils compilent ou dont ils éditent les liens au lieu de montrer
la ligne de commande. Si vous devez inspecter la commande, soit à cause
d'une erreur, ou juste pour voir les options et les drapeaux utilisés,
ajouter<option>V=1</option> à l'invocation make peut aider.
      </para>

    <bridgehead renderas="sect3" id="cmake-info">CMake</bridgehead>

      <para>
        CMake fonctionne de manière différente et il a deux moteurs qui peuvent être
utilisés sur BLFS&nbsp;: <command>make</command> et
<command>ninja</command>. Le moteur par défaut est make, mais ninja est plus
rapide sur les paquets plus gros avec plusieurs processeurs. Pour utiliser
ninja, spécifiez <option>-G Ninja</option> dans la commande
cmake. Cependant, certains paquets peuvent avoir des erreurs fatales dans
leurs fichiers ninja tout en pouvant être construits sans problème avec les
Makefile Unix par défaut.
      </para>

      <para>
        La partie la plus dure de l'utilisation de CMake est de connaître les
options que vous voudrez spécifier. La seule manière de récupérer une liste
de ce que le paquet connaît est de lancer <command>cmake -LAH</command> et
de regarder la sortie pour cette configuration par défaut.
      </para>

      <para>
        Peut-être que la chose la plus importante à propos de CMake est qu'il a
plusieurs valeurs de CMAKE_BUILD_TYPE et qu'elles affectent les drapeaux. La
valeur par défaut est vide et aucun drapeau n'est généré. Les
<envar>CFLAGS</envar> et <envar>CXXFLAGS</envar> dans l'environnement seront
utilisés. Si le programmeur a codé des assertions de débogage, elles seront
activées à moins que vous n'utilisiez -DNDEBUG. Les valeurs CMAKE_BUILD_TYPE
suivantes généreront les drapeaux associés et ils seront ajoutés
<emphasis>après</emphasis> les drapeaux dans l'environnement et prennent
donc le pas dessus.
      </para>

      <informaltable align="center">
        <tgroup cols="2">
          <colspec colnum="1" align="center"/>
          <colspec colnum="2" align="center"/>
          <thead>
            <row><entry>Value</entry><entry>Flags</entry></row>
          </thead>
          <tbody>
            <row>
              <entry>Debug</entry><entry><option>-g</option></entry>
            </row>
            <row>
              <entry>Release</entry><entry><option>-O3 -DNDEBUG</option></entry>
            </row>
            <row>
              <entry>RelWithDebInfo</entry><entry><option>-O2 -g -DNDEBUG</option></entry>
            </row>
            <row>
              <entry>MinSizeRel</entry><entry><option>-Os -DNDEBUG</option></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>
        CMake essaye de produire des constructions silencieuses. Pour voir les
détails des commandes lancées, utilisez <command>make VERBOSE=1</command> ou
<command>ninja -v</command>.
      </para>

      <para>
        Par défaut, CMake traite l'installation des fichiers différemment des autres
systèmes de construction&nbsp;: si un fichier existe déjà et n'est pas plus
récent qu'un fichier qui le remplacerait, alors le fichier n'est pas
installé. cela peut être un problème si vous voulez enregistrer quels
fichiers appartiennent à quel paquet, soit avec <envar>LD_PRELOAD</envar>,
soit en listant les fichiers plus récents qu'un certain horodatage. Ce
comportement par défaut peut être modifié en paramétrant la variable
<envar>CMAKE_INSTALL_ALWAYS</envar> à 1 dans
l'<emphasis>environnement</emphasis>, par exemple en
l'<command>export</command>ant.
      </para>

    <bridgehead renderas="sect3" id="meson-info">Meson</bridgehead>

      <para>
        Meson ressemble un peu à CMake, mais avec beaucoup de différences. Pour
trouver les détails des définitions que vous pourriez avoir besoin de
modifier, vous pouvez regarder dans <filename>meson_options.txt</filename>
qui est généralement dans le répertoire de plus haut niveau.
      </para>

      <para>
        Si vous avez déjà configuré le paquet en lançant <command>meson</command> et
que vous souhaitez maintenant changer un ou plusieurs paramètres, vous
pouvez soit supprimer le répertoire de construction, le recréer et utiliser
les options modifiées, soit lancer <command>meson configure</command> dans
le répertoire de construction, p. ex. pour ajouter une option&nbsp;:
      </para>

<screen><userinput>meson configure -D&lt;some_option&gt;=true</userinput></screen>

      <para>
        Si vous faites cela, le fichier
<filename>meson-private/cmd_line.txt</filename> contiendra les
<emphasis>dernières</emphasis> commandes qui ont été utilisées.
      </para>

      <para>
        Meson fournit les valeurs buildtype suivantes, et les drapeaux qu'elles
activent viennent <emphasis>après</emphasis> les drapeaux fournis dans
l'environnement et prennent donc le pas.
      </para>

      <itemizedlist>
        <listitem>
          <para>plain&nbsp;: pas de drapeau supplémentaire. Cela est utilisé pour spécifier
ses propres <envar>CFLAGS</envar>, <envar>CXXFLAGS</envar> et
<envar>LDFLAGS</envar>. Il n'y a pas de raison évidente pour utiliser cela
dans BLFS.</para>
        </listitem>
        <listitem>
          <para>debug&nbsp;: <option>-g</option> — c'est la valeur par défaut si rien n'est
spécifié dans <filename>meson.build</filename> ni sur la ligne de
commande. Cependant, cela crée des binaires gros et lents, donc vous devez
le remplacer dans BLFS.</para>
        </listitem>
        <listitem>
          <para>debugoptimized&nbsp;: <option>-O2 -g</option>&nbsp;: c'est la valeur par
défaut spécifiée dans <filename>meson.build</filename> pour certains
paquets.</para>
        </listitem>
        <listitem>
          <para>release&nbsp;: <option>-O3</option> (parfois un paquet forcera
<option>-O2</option>) — c'est le type de construction utilisé pour la
plupart des paquets avec le système de construction Meson dans BLFS.</para>
        </listitem>
      </itemizedlist>

      
      <!-- From https://mesonbuild.com/Builtin-options.html#core-options:
           b_ndebug: Default value = false, Possible values are
           true, false, if-release.  Some packages sets it to if-release
           so we mistakenly believed if-release had been the default.  -->
<para>
        Le drapeau <option>-DNDEBUG</option> est sous-entendu par le type de
construction release pour certains paquets (par exemple <xref
linkend='mesa'/>). Il peut également être fournit en passant
<option>-Db_ndebug=true</option>.
      </para>

      <para>
        Pour voir les détails des commandes qui sont lancées dans un paquet qui
utilise meson, utilisez <command>ninja -v</command>.
      </para>

    <bridgehead renderas="sect3" id="rust-info">Rustc et Cargo</bridgehead>

      <para>
        La plupart des programmes rustc publiés sont fournis dans des archives (ou
«&nbsp;crates&nbsp;») qui demanderont à un serveur de vérifier les versions
actuelles des dépendances et les téléchargera au besoin. Ces paquets sont
construits avec <command>cargo --release</command>. En théorie, on peut
manipuler les RUSTFLAGS pour changer le niveau d'optimisation (la valeur par
défaut pour <option>--release</option> est 3,
c.-à-d. <option>-Copt-level=3</option>, comme <option>-O3</option>) ou pour
forcer la construction pour la machine sur laquelle il est compilé, avec
<literal>-Ctarget-cpu=native</literal> mais en pratique cela ne semble pas
faire de réelle différence.
      </para>

      <para>
        Si vous compilez un programme Rust autonome (en tant que fichier <filename
class='extension'>.rs</filename> sans paquet) en exécutant directement
<command>rustc</command>, vous devriez spécifier <option>-O</option>
(abbreviation de <option>-Copt-level=2</option>) ou
<option>-Copt-level=3</option> sinon il effectuera une compilation non
optimisée et s'exécutera <emphasis>bien plus</emphasis> lentement. Si vous
compilez un programme pour le déboguer, remplacez les options
<option>-O</option> ou <option>-Copt-level=</option> par <option>-g</option>
pour produire un programme non optimisé avec des informations de débogage.
      </para>

      <para>
        Like <command>ninja</command>, by default <command>cargo</command> uses all
logical processors.  This can often be worked around, either by exporting
<envar>CARGO_BUILD_JOBS=<replaceable>&lt;N&gt;</replaceable></envar> or
passing <option>--jobs <replaceable>&lt;N&gt;</replaceable></option> to
<command>cargo</command>.  For compiling rustc itself, specifying
<option>--jobs <replaceable>&lt;N&gt;</replaceable></option> for invocations
of <command>x.py</command> (together with the
<envar>CARGO_BUILD_JOBS</envar> environment variable, which looks like a
<quote>belt and braces</quote> approach but seems to be necessary) mostly
works. The exception is running the tests when building rustc, some of them
will nevertheless use all online CPUs, at least as of rustc-1.42.0.
      </para>

  </sect2>

  <sect2 id="optimizations">
    <title>Optimisation de la construction</title>

      <para>
        Many people will prefer to optimize compiles as they see fit, by providing
<envar>CFLAGS</envar> or <envar>CXXFLAGS</envar>. For an introduction to the
options available with gcc and g++ see <ulink
url="https://gcc.gnu.org/onlinedocs/gcc-&gcc-version;/gcc/Optimize-Options.html"/>.
The same content can be also found in <command>info gcc</command>.
      </para>

      <para>
        Some packages default to <option>-O2 -g</option>, others to <option>-O3
-g</option>, and if <envar>CFLAGS</envar> or <envar>CXXFLAGS</envar> are
supplied they might be added to the package's defaults, replace the
package's defaults, or even be ignored.  There are details on some desktop
packages which were mostly current in April 2019 at <ulink
url="https://www.linuxfromscratch.org/~ken/tuning/"/> - in particular,
<filename>README.txt</filename>,
<filename>tuning-1-packages-and-notes.txt</filename>, and
<filename>tuning-notes-2B.txt</filename>. The particular thing to remember
is that if you want to try some of the more interesting flags you may need
to force verbose builds to confirm what is being used.
      </para>

      <para>
        Clearly, if you are optimizing your own program you can spend time to
profile it and perhaps recode some of it if it is too slow. But for building
a whole system that approach is impractical. In general,
<option>-O3</option> usually produces faster programs than
<option>-O2</option>.  Specifying <option>-march=native</option> is also
beneficial, but means that you cannot move the binaries to an incompatible
machine - this can also apply to newer machines, not just to older
machines. For example programs compiled for <literal>amdfam10</literal> run
on old Phenoms, Kaveris, and Ryzens : but programs compiled for a Kaveri
will not run on a Ryzen because certain op-codes are not present.
Similarly, if you build for a Haswell not everything will run on a
SandyBridge.
      </para>

      <note>
        <para>
          Be careful that the name of a <option>-march</option> setting does not
always match the baseline of the microarchitecture with the same name.  For
example, the Skylake-based Intel Celeron processors do not support AVX at
all, but <option>-march=skylake</option> assumes AVX and even AVX2.
        </para>
      </note>

      <para>
        When a shared library is built by GCC, a feature named <quote>semantic
interposition</quote> is enabled by default.  When the shared library refers
to a symbol name with external linkage and default visibility, if the symbol
exists in both the shared library and the main executable, semantic
interposition guarantees the symbol in the main executable is always used.
This feature was invented in an attempt to make the behavior of linking a
shared library and linking a static library as similar as possible.  Today
only a small number of packages still depend on semantic interposition, but
the feature is still on by the default of GCC, causing many optimizations
disabled for shared libraries because they conflict with semantic
interposition.  The <option>-fno-semantic-interposition</option> option can
be passed to <command>gcc</command> or <command>g++</command> to disable
semantic interposition and enable more optimizations for shared libraries.
This option is used as the default of some packages (for example <xref
linkend='python3'/>), and it's also the default of Clang.
      </para>

      <para>
        Il y a aussi diverses autres options que certains pensent bénéfiques. Au
pire, vous devez recompiler et tester, pour découvrir que pour votre
utilisation ces options ne font rien de spécial.
      </para>

      <para>
        If building Perl or Python modules, in general the <envar>CFLAGS</envar> and
<envar>CXXFLAGS</envar> used are those which were used by those
<quote>parent</quote> packages.
      </para>

      <para>
        For <envar>LDFLAGS</envar>, there are three options can be used for
optimization.  They are quite safe to use and the building system of some
packages use some of these options as the default.
      </para>

      <para>
        With <option>-Wl,-O1</option>, the linker will optimize the hash table to
speed up the dynamic linking.  Note that <option>-Wl,-O1</option> is
completely unrelated to the compiler optimization flag <option>-O1</option>.
      </para>

      <para>
        With <option>-Wl,--as-needed</option>, the linker will disregard unnecessary
<option>-l<replaceable>foo</replaceable></option> options from the command
line, i. e. the shared library <systemitem
class='library'>lib<replaceable>foo</replaceable></systemitem> will only be
linked if a symbol in <systemitem
class='library'>lib<replaceable>foo</replaceable></systemitem> is really
referred from the executable or shared library being linked.  This can
sometimes mitigate the <quote>excessive dependencies to shared
libraries</quote> issues caused by <application>libtool</application>.
      </para>

      <para>
        With <option>-Wl,-z,pack-relative-relocs</option>, the linker generates a
more compacted form of the relative relocation entries for PIEs and shared
libraries.  It reduces the size of the linked PIE or shared library, and
speeds up the loading of the PIE or shared library.
      </para>

      <para>
        The <option>-Wl,</option> prefix is necessary because despite the variable
is named <envar>LDFLAGS</envar>, its content is actually passed to
<command>gcc</command> (or <command>g++</command>, <command>clang</command>,
etc.) during the link stage, not directly passed to <command>ld</command>.
      </para>

  </sect2>

  <sect2 id="hardening">
    <title>Options pour durcir la construction</title>

      <para>
        Même sur un système de bureau, il y a des vulnérabilités exploitables. Pour
beaucoup, l'attaque vient de javascript dans un navigateur. Souvent, une
série de vulnérabilités sont utilisées pour récupérer un accès aux données
(ou parfois pour powner, c.-à-d. cracker la machine et installer des
rootkits). La plupart des distributions commerciales appliqueront diverses
mesures de durcissement.
      </para>

      <para>
        Par le passé, il existait un Hardened LFS (LFS durci) où gcc (une version
beaucoup plus vieille) était forcé à utiliser le durcissement (avec des
options pour les désactiver au cas par cas). Les livres LFS et BLFS actuels
portent encore une partie de cet esprit en activant PIE (<option>-fPIE
-pie</option>) et SSP (<option>-fstack-protector-strong</option>) dans les
options par défaut de GCC et de clang. Ce dont on parle ici est différent —
vous devrez déjà vous assurer que le paquet utilise bien vos options
supplémentaires et qu'il ne les écrase pas.
      </para>

      <para>
        Pour les options de durcissement qui sont raisonnablement peu coûteuses, on
en parle un peu dans le lien sur les expériences de peaufinage précédent
(parfois une ou plus de ces options peuvent être inappropriées pour un
paquet). Ces options sont <option>-D_FORTIFY_SOURCE=2</option> et (pour C++)
<option>-D_GLIBCXX_ASSERTIONS</option>. Sur les machines modernes elles ne
devraient avoir qu'un très faible impact sur la vitesse des programmes et
souvent ne seront même pas perceptibles.
      </para>

      <para>
        Les distros principales utilisent bien plus, comme RELRO (Relocation Read
Only) et parfois <option>-fstack-clash-protection</option>. Vous pouvez
aussi rencontrer les <quote>retpolines en espace utilisateur</quote>
(<option>-mindirect-branch=thunk</option> etc) qui sont équivalents aux
atténuations de spectre appliquées au noyau Linux fin 2018. Les atténuations
du noyau ont causé de nombreuses plaintes à propos d'une perte de
performance, donc si vous avez un serveur en production vous devriez
peut-être tester ça ainsi que d'autres options disponibles, pour voir si les
performances sont toujours satisfaisantes.
      </para>

      <para>
        Tandis que gcc a de nombreuses options de durcissement, la force de
clang/LLVM se trouve ailleurs. Certaines options fournies par gcc sont dites
moins efficaces dans clang/LLVM.
      </para>

  </sect2>

</sect1>
