<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../../general.ent">
  %general-entities;
]>

<sect1 id="unpacking">
  <?dbhtml filename="notes-on-building.html"?>

  <sect1info>
<date>$Date$</date></sect1info>

  <title>Remarques sur la construction de logiciels</title>

  <para>Il se peut que les gens qui ont construit un système LFS connaissent les
principes généraux du téléchargement et du déballage de logiciel. Certaines
de ces informations sont répétées ici pour les nouveaux qui construisent
leurs propres logiciels.</para>

  <para>Chaque groupe d'instructions d'installation contient une adresse Web depuis
laquelle vous pouvez télécharger le paquet. Les correctifs cependant, sont
enregistrés sur les serveurs LFS et sont disponibles via HTTP. Ils sont
référencés comme nécessaires dans les instructions d'installation.</para>

  <para>Si vous pouvez mettre les fichiers sources là où vous voulez, nous supposons
que vous avez déballé le paquet et êtes allé dans le répertoire créé par le
processus de déballage (le répertoire de 'construction'). Nous supposons
aussi que vous avez décompressé les correctifs requis et qu'ils sont dans le
répertoire de niveau immédiatement supérieur au répertoire de
'construction'.</para>

  <para>Nous ne saurions que trop vous recommander de démarrer àpartir d'une
<emphasis>arborescence de sources propre</emphasis> à chaque fois.  Cela
veut dire que si vous avez eu une erreur lors de la configuration ou de la
compilation, il est généralement préférable d'effacer l'arborescence des
sources et de la redéballer <emphasis>avant</emphasis> de réessayer. Cela ne
s'applique évidemment pas si vous êtes un utilisateur avancé habitué à
modifier les <filename>Makefile</filename>s et le code C, mais si vous avez
un doute, commencez à partir d'une arborescence propre.</para>

  <sect2>
    <title>Construction de logiciels en tant qu'utilisateur non privilégié (non root)</title>

    <para>La règle d'or de l'administration d'un système Unix est de n'utiliser vos
super-pouvoirs que si nécessaire. D'où la recommandation de BLFS de
construire les logiciels en tant qu'utilisateur non privilégié et de ne
devenir l'utilisateur <systemitem class='username'>root</systemitem> que
lors de l'installation du logiciel. On suit cette philosophie dans tous les
paquets du livre. Sauf spécifications contraires, toutes les instructions
devraient être exécutées en tant qu'utilisateur non privilégié. Le livre
vous conseillera sur les instructions qui ont besoin des privilèges
<systemitem class='username'>root</systemitem>.</para>

  </sect2>

  <sect2>
    <title>Déballer le logiciel</title>

    <para>S'il y a un fichier compressé au format <filename
class='extension'>.tar</filename>, on le déballe en utilisant une des
commandes suivantes&nbsp;:</para>

<screen><userinput>tar -xvf filename.tar.gz
tar -xvf filename.tgz
tar -xvf filename.tar.Z
tar -xvf filename.tar.bz2</userinput></screen>

    <note>
      <para>Vous pouvez ne pas utiliser le paramètre <option>v</option> dans les
commandes décrites ci-dessus et ci-dessous si vous souhaitez supprimer le
listage verbeux de tous les fichiers de l'archive au fur et à mesure qu'ils
sont extraits. Cela peut aider à accélérer l'extraction mais aussi rendre la
compréhension des erreurs produites pendant l'extraction moins évidentes.</para>
    </note>

    <para>Vous pouvez utiliser aussi une méthode légèrement différente&nbsp;:</para>

<screen><userinput>bzcat filename.tar.bz2 | tar -xv</userinput></screen>

    <para>Enfin, vous avez parfois besoin de déballer des correctifs qui ne sont
généralement pas au format <filename class='extension'>.tar</filename>.  La
meilleure manière de faire cela est de copier le chemin du fichier dans le
parent du répertoire de 'construction' puis d'exécuter une des commandes
suivantes selon que le fichier est un <filename
class='extension'>.gz</filename> ou un <filename
class='extension'>.bz2</filename>&nbsp;:</para>

<screen><userinput>gunzip -v patchname.gz
bunzip2 -v patchname.bz2</userinput></screen>

  </sect2>

  <sect2>
    <title>Vérifier l'intégrité des fichiers en utilisant 'md5sum'</title>

    <para>En général, pour vérifier que le fichier téléchargé est authentique et
complet, de nombreux mainteneurs de paquets distribuent aussi des sommes md5
des fichiers. Pour vérifier la somme md5 des fichiers téléchargés,
téléchargez à la fois le fichier et le fichier md5sum correspondant dans le
même répertoire (de préférence à partir d'emplacements différents en ligne)
et (en supposant que <filename>file.md5sum</filename> est le fichier md5sum
téléchargé), lancez la commande suivante&nbsp;:</para>

<screen><userinput>md5sum -c file.md5sum</userinput></screen>

    <para>S'il y a une erreur, elle sera signalée. Remarquez que le livre BLFS
comprend les sommes md5 de tous les fichiers sources. Pour utiliser les
sommes md5 fournies par BLFS, vous pouvez créer un
<filename>file.md5sum</filename> (mettez les données md5sum et le nom exact
du fichier téléchargé sur la même ligne d'un fichier, séparés par un espace
blanc), et lancez la commande montrée ci-dessus. Sinon, lancez simplement la
commande décrite ci-dessus et comparez la sortie avec les données de somme
md5 inscrites dans le livre BLFS.</para>

<screen><userinput>md5sum <replaceable>&lt;name_of_downloaded_file&gt;</replaceable></userinput></screen>

  </sect2>

  <sect2>
    <title>Créer des fichiers journaux pendant l'installation</title>

    <para>Pour les gros paquets, il est commode de créer des fichiers journaux plutôt
que de dévisager l'écran en espérant récupérer une erreur ou un
avertissement particulier. Les fichiers journaux sont aussi utiles pour
déboguer et garder des enregistrements. La commande suivante vous permet de
créer un journal d'installation. Remplacez
<replaceable>&lt;commande&gt;</replaceable> par la commande que vous
cherchez à exécuter.</para>

<screen><userinput>( <replaceable>&lt;command&gt;</replaceable> 2&gt;&amp;1 | tee compile.log &amp;&amp; exit $PIPESTATUS )</userinput></screen>

    <para><option>2&gt;&amp;1</option> redirige les messages d'erreur vers le même
endroit que la sortie standard. La commande <command>tee</command> vous
permet de voir la sortie en journalisant les résultats dans un fichier. Les
parenthèses autour de la commande exécutent toute la commande dans un
sous-shell et, enfin, la commande <command>exit $PIPESTATUS</command>
s'assure que c'est bien le résultat de
<replaceable>&lt;commande&gt;</replaceable> qui est retourné et pas le
résultat de la commande <command>tee</command>.</para>

  </sect2>

  <sect2 id="parallel-builds" xreflabel="Utilisation de processeurs multiples">
    <title>Utilisation de processeurs multiples</title>

    <para>Pour la plupart des systèmes modernes avec des processeurs multiples (ou
cœurs) le temps de compilation pour un paquet peut être réduit en effectuant
une «&nbsp;construction parallèle&nbsp;» soit en initialisant une variable
d'environnement, soit en disant au programme make combien de processeurs
sont disponibles. Par exemple, un Core2Duo peut supporter deux processus
simultanés avec&nbsp;: </para>

    <screen><userinput>export MAKEFLAGS='-j2'</userinput></screen>

    <para>ou en compilant simplement avec&nbsp;:</para>

    <screen><userinput>make -j2</userinput></screen>

    <para>Généralement le nombre de processus ne doit pas dépasser le nombre de cœurs
supportés par le CPU. Pour lister les processeurs de votre système, tapez :
<userinput>grep processor /proc/cpuinfo</userinput>.
    </para>

    <para>Dans certains cas, l'utilisation de processeurs multiples peut amener dans
une sorte de «&nbsp;course&nbsp;» où le succès de la construction dépend de
l'ordre des commandes lancées par le programme <command>make</command>. Par
exemple, si un exécutable demande un fichier A et un fichier B, essayer de
lier le programme avant qu'un des composants dépendants ne soit disponible
aboutira à un échec.  Cela arrive en général quand les développeurs n'ont
pas correctement désigné tous les prérequis utiles pour accomplir une étape
du Makefile.</para>

    <para>Si cela arrive, la meilleure chose à faire est de recommencer la
construction avec un seul processeur. En ajoutant «&nbsp;-j1&nbsp;» à une
commande make, cela écrasera l'initialisation similaire dans une variable
d'environnement MAKEFLAGS.</para>

    <note><para>Lorsque vous lancez les tests du paquet ou l'installation du paquet, nous ne
recommandons pas d'utiliser une option plus grande que «&nbsp;-j1&nbsp;» à
moins que cela ne soit indiqué. La procédure d'installation et les tests
n'ont pas été validés avec des processus en parallèle et peuvent échouer
avec des problème difficiles à déboguer.</para></note>

  </sect2>

  <sect2 id="automating-builds" xreflabel="Procédures de construction automatique">
    <title>Procédures de construction automatique</title>

    <para>Il y a des fois où automatiser la construction d'un paquet peut s'avérer
utile. Chacun a ses raisons de vouloir automatiser la construction, et
chacun le fait par ses propres moyens. Soit en créant des
<filename>Makefile</filename>s, des scripts <application>Bash</application>,
des scripts <application>Perl</application> ou simplement une liste de
commandes utilisées à copier-coller, sont des méthodes que vous pouvez
utiliser pour automatiser la construction de paquets BLFS. Détailler et
donner des exemples sur les nombreuses manières d'automatiser la
construction de paquets va au-delà des objectifs de cette section. Cette
section vous présentera l'utilisation de la redirection de fichiers et de la
commande <command>yes</command> pour vous donner des idées sur la façon
d'automatiser vos constructions.</para>

    <bridgehead renderas="sect3">Redirection de fichier pour automatiser l'entrée</bridgehead>

    <para>Il y aura des moments, pendant votre aventure BLFS, où vous tomberez sur un
paquet ayant une invite de commande vous demandant des informations.  Ces
informations peuvent être des détails de configuration, un chemin de
répertoire ou une réponse à un accord de licence. Il peut être un challenge
d'automatiser la construction de ce paquet. On vous demandera
occasionnellement des informations via une série de questions. Une méthode
pour automatiser ce type de scénario est de mettre les réponses désirées
dans un fichier et d'utiliser la redirection pour que le programme utilise
les données du fichier comme réponses aux questions.</para>

    <para>La construction du paquet <application>CUPS</application> est un bon exemple
de la façon de rediriger un fichier comme entrée aux invites, cela peut vous
aider à automatiser la construction. Si vous lancez la suite de test, on
vous demande de répondre à une série de questions concernant le type de test
à exécuter et si vous avez un programme auxiliaire que le test peut
utiliser. Vous pouvez créer un fichier avec vos réponses, une par ligne, et
utiliser une commande ressemblant à celle indiquée ci-dessous pour
automatiser l'exécution de la suite de tests&nbsp;:</para>

<screen><userinput>make check &lt; ../cups-1.1.23-testsuite_parms</userinput></screen>

    <para>Cela fait que la suite de tests utilise les réponses du fichier comme entrée
pour les questions. Vous pouvez finir par faire des essais et des erreurs
pour déterminer le format exact de votre fichier d'entrée pour certaines
choses, mais une fois expérimenté et documenté, vous pouvez utiliser cela
pour automatiser la construction du paquet.</para>

    <bridgehead renderas="sect3">Utiliser <command>yes</command> pour automatiser l'entrée</bridgehead>

    <para>Vous n'aurez parfois besoin que de fournir une réponse ou une même réponse à
de nombreuses invites. Dans ces cas-là, la commande <command>yes</command>
fonctionne vraiment bien.  On peut utiliser la commande
<command>yes</command> pour fournir une réponse (la même) à une ou plusieurs
questions. On peut l'utiliser pour simuler un simple appui sur la touche
<keycap>Entrée</keycap>, l'entrée de la touche <keycap>Y</keycap> ou
l'entrée d'une chaîne de texte. La manière la plus facile de montrer son
utilisation est peut-être de prendre un exemple.</para>

    <para>Créez tout d'abord un petit script <application>Bash</application> en
entrant les commandes suivantes&nbsp;:</para>

<screen><userinput>cat &gt; blfs-yes-test1 &lt;&lt; "EOF"
<literal>#!/bin/bash

echo -n -e "\n\nPlease type something (or nothing) and press Enter ---> "

read A_STRING

if test "$A_STRING" = ""; then A_STRING="Just the Enter key was pressed"
else A_STRING="You entered '$A_STRING'"
fi

echo -e "\n\n$A_STRING\n\n"</literal>
EOF
chmod 755 blfs-yes-test1</userinput></screen>

    <para>Maintenant, lancez le script en lançant <command>./blfs-yes-test1</command>
depuis la ligne de commande. Il attendra une réponse, qui peut être
n'importe quoi (ou rien) suivi de la touche <keycap>Entrée</keycap>. Après
avoir entré quelque chose, le résultat sera affiché à l'écran. Utilisez
maintenant la commande <command>yes</command> pour automatiser l'entrée
d'une réponse&nbsp;:</para>

<screen><userinput>yes | ./blfs-yes-test1</userinput></screen>

    <para>Remarquez que la redirection (le piping) de <command>yes</command> en
lui-même vers le script aboutit à ce que <keycap>y</keycap> est passé au
script. Essayez-la maintenant avec une chaîne de texte&nbsp;:</para>

<screen><userinput>yes 'This is some text' | ./blfs-yes-test1</userinput></screen>

    <para>La chaîne exacte était utilisée comme réponse au script. Enfin, essayez-la
en utilisant une chaîne vide (null)&nbsp;:</para>

<screen><userinput>yes '' | ./blfs-yes-test1</userinput></screen>

    <para>Remarquez que cela aboutit à ne passer au script que l'appui sur la touche
<keycap>Entrée</keycap>. C'est utile parfois quand la réponse par défaut à
l'invite est suffisante. Cette syntaxe est utilisée dans les instructions de
<xref linkend="net-tools-automate-example"/> pour accepter tous les réglages
par défaut à toutes les invites lors de l'étape de configuration.  Vous
pouvez maintenant supprimer le script de test si vous le désirez.</para>

    <bridgehead renderas="sect3">Redirection de fichiers pour automatiser la sortie</bridgehead>

    <para>Pour automatiser la construction de certains paquets, surtout ceux qui vous
demandent de lire un accord de licence page après page, il faut utiliser une
méthode qui évite de devoir appuyer sur une touche pour afficher chaque
page. On peut utiliser la redirection de sortie vers un fichier dans ce
cas-là pour vous aider à automatiser. La section précédente de cette page a
visé à créer des fichiers journaux de la sortie de la construction.  La
méthode de redirection qui y est décrite utilisait la commande
<command>tee</command> pour rediriger la sortie tout en affichant aussi la
sortie à l'écran. Ici on ne verra la sortie que dans un fichier.</para>

    <para>De nouveau, la manière la plus facile de montrer la technique est de
présenter un exemple. Lancez d'abord la commande&nbsp;:</para>

<screen><userinput>ls -l /usr/bin | more</userinput></screen>

    <para>Bien entendu, vous devrez voir la sortie page par page car on a utilisé le
filtre <command>more</command>. Essayez maintenant la même commande, mais en
redirigeant cette fois la sortie vers un fichier. Le fichier spécial
<filename>/dev/null</filename> peut être utilisé à la place du fichier
indiqué, mais vous n'aurez pas de fichier journal à examiner&nbsp;:</para>

<screen><userinput>ls -l /usr/bin | more &gt; redirect_test.log 2&gt;&amp;1</userinput></screen>

    <para>Remarquez que cette fois, la commande est immédiatement revenue à l'invite
du shell sans devoir parcourir la sortie page par page. Vous pouvez
supprimer maintenant le fichier journal.</para>

    <para>Le dernier exemple utilisera la commande <command>yes</command> associée à
la redirection de sortie pour éviter de naviguer page par page dans la
sortie, puis de fournir un <keycap>y</keycap> à l'invite. Cette technique
peut être utilisée dans les cas où vous devriez, sans elle, naviguer page
par page dans la sortie d'un fichier (tel qu'un accord de licence), puis
répondre à la question <quote>Acceptez-vous ce qui précède&nbsp;?</quote>.
Pour cet exemple, on a besoin d'un autre petit script
<application>Bash</application>&nbsp;:</para>

<screen><userinput>cat &gt; blfs-yes-test2 &lt;&lt; "EOF"
<literal>#!/bin/bash

ls -l /usr/bin | more

echo -n -e "\n\nDid you enjoy reading this? (y,n) "

read A_STRING

if test "$A_STRING" = "y"; then A_STRING="You entered the 'y' key"
else A_STRING="You did NOT enter the 'y' key"
fi

echo -e "\n\n$A_STRING\n\n"</literal>
EOF
chmod 755 blfs-yes-test2</userinput></screen>

    <para>On peut utiliser ce script pour simuler un programme qui demande que vous
lisiez un accord de licence et que vous acceptiez le contrat avant que le
programme n'installe quoique ce soit. Lancez d'abord le script sans
techniques d'automatisation en exécutant
<command>./blfs-yes-test2</command>.</para>

    <para>Maintenant lancez la commande suivante qui utilise les techniques
d'automatisation, rendant l'utilisation convenable dans un script de
construction automatisé&nbsp;:</para>

<screen><userinput>yes | ./blfs-yes-test2 &gt; blfs-yes-test2.log 2&gt;&amp;1</userinput></screen>

    <para>Si vous le désirez, lancez <command>tail blfs-yes-test2.log</command> pour
voir la fin de la sortie paginée et la confirmation que <keycap>y</keycap> a
été passé au script. Une fois que cela marche comme cela devrait, vous
pouvez supprimer le script et le fichier journal.</para>

    <para>Enfin, gardez à l'esprit qu'il y a de nombreux moyens d'automatiser ou de
scripter les commandes de construction. Il n'y a pas <quote>une
seule</quote> manière de procéder. Votre imagination est la seule limite.</para>

  </sect2>

  <sect2>
    <title>Dépendances</title>

    <para>Pour chaque paquet décrit, BLFS liste les dépendances connues. Elles sont
listées sous plusieurs en-têtes, dont la signification est la
suivante&nbsp;:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>Requis</emphasis> signifie que le paquet cible ne peut pas se
construire correctement sans avoir d'abord installé la dépendance.</para>
      </listitem>
      <listitem>
        <para><emphasis>Recommandées</emphasis> signifie que BLFS suggère fortement
d'installer préalablement ce paquet pour une construction propre et sans
problème, ni pendant le processus de construction ni au moment de
l'exécution. Les instructions dans le livre considèrent que ses paquets sont
installés. Des modifications ou contournements peuvent être requis si ces
paquets ne sont pas installés.</para>
      </listitem>
      <listitem>
        <para><emphasis>Facultatives</emphasis> signifie que ce paquet pourrait être
installé pour ajouter des fonctions. BLFS décrira souvent la dépendance pour
expliquer la fonctionnalité supplémentaire résultante.</para>
      </listitem>
    </itemizedlist>

  </sect2>

  <sect2 id="package_updates">
    <title>Utilisation de paquets sources plus récents</title>

    <para>Occasionnellement, dans le livre, vous pourrez être dans la situation ou un
paquet ne se construit pas ou ne fonctionne pas correctement. Bien que les
éditeurs tentent de faire en sorte que chaque paquet dans le livre se
construise et fonctionne correctement, parfois un paquet a été oublié ou n'a
pas été testé avec cette version particulière de BLFS.</para>

    <para>Si vous découvrez un paquet qui ne se construit pas ou ne fonctionne pas
correctement, vous pouvez regarder s'il s'agit de la version la plus récente
du paquet. Typiquement, cela signifie que vous irez sur le site web du
mainteneur et téléchargerez l'archive la plus récente et tenterez de
construire le paquet.  Si vous ne pouvez pas déterminer le site web du
mainteneur en regardant l'URL de chargement, utilisez Google et cherchez le
nom du paquet. Par exemple, dans la barre de recherche de Google tapez:
'nom_du_paquet download' (sans les guillemets)  ou quelque chose de
similaire. Parfois en tapant&nbsp;: 'nom_du_paquet home page' vous trouverez
le site web du mainteneur.</para>

  </sect2>

  <sect2 id="stripping">
    <title>Nettoyage une fois de plus</title>

    <para>
      Dans LFS, le nettoyage des symboles de déboguage a été discuté de nombreuses
fois.  Pour la construction des paquets BLFS, il n'y a généralement pas
d'instructions qui discute de nouveau du nettoyage. Ce n'est probablement
pas une bonne idée de nettoyer un exécutable ou une bibliothèque tant qu'ils
sont utilisés, alors sortir des environnements de fenêtrage est une bonne
idée. Ensuite vous pouvez faire&nbsp;:
    </para>

<screen><userinput>find /{,usr/}{bin,lib,sbin} \
    -type f \( -name \*.so* -a ! -name \*dbg \) \
    -exec strip --strip-unneeded {} \;</userinput></screen>

    <para>
      Si vous installez des programmes dans d'autres répertoires tels que
<filename class="directory">/opt</filename> ou <filename
class="directory">/usr/local</filename>, vous pouvez vouloir nettoyer les
fichiers ici aussi.
    </para>

    <para>
      Pour plus d'information sur le nettoyage, regardez <ulink
url="http://www.technovelty.org/linux/stripping-shared-libraries.html"/>.
    </para>

  </sect2>

  <!--
  <sect2 id="libtool">

    <title>Libtool files</title>

    <para>
      One of the side effects of packages that use Autotools, including
      libtool, is that they create many files with an .la extension.  These
      files are not needed in an LFS environment.  If there are conflicts with
      pkgconfig entries, they can actually prevent successful builds.  You
      may want to consider removing these files periodically:
    </para>

<screen><userinput>find /lib /usr/lib -not -path "*Image*" -a -name \*.la -delete</userinput></screen>

    <para>
      The above command removes all .la files with the exception of those that
      have <quote>Image</quote> or <quote>openldap</quote> as a part of the
      path.  These .la files are used by the ImageMagick and openldap programs,
      respectively.  There may be other exceptions by packages not in BLFS.
    </para>

  </sect2>
-->
<sect2 id="buildsystems">
    <title>Travailler avec différents systèmes de construction</title>

    <para>
      Il y a maintenant trois systèmes de construction différents utilisés
régulièrement pour convertir du code source C ou C++ en un programme compilé
ou en une bibliothèque et leur fonctionnement (en particulier, comment
trouver les options disponibles et leurs valeurs par défaut) est
différent. Il peut être plus facile de comprendre les problèmes causés par
certains choix (typiquement une exécution lente ou l'utilisation (ou
l'omission) inattendue des optimisations) en commençant par les variable
d'environnement CFLAGS et CXXFLAGS. Certains programmes utilisent aussi
rust.
    </para>

    <para>
      La plupart des lecteurs de LFS et de BLFS connaissent probablement déjà les
bases de l'utilisation de CFLAGS et CXXFLAGS pour altérer la compilation
d'un programme. Typiquement, certaines formes d'optimisations sont utilisés
par les développeurs en amont (-O2 ou -O3), parfois avec la création de
symboles de débogage (-g) par défaut.
    </para>

    <para>
      S'il y a des drapeaux contradictoires (p. ex. plusieurs valeurs différentes
de -O), la <emphasis>dernière</emphasis> valeur sera utilisée. Parfois les
drapeaux spécifiés dans les variables d'environnement sont insérés avant les
valeurs en dur dans le Makefile, ce qui signifie qu'ils sont ignorés. Par
exemple, si un utilisateur spécifie «&nbsp;-O2&nbsp;» et qu'il est suivi de
«&nbsp;-O3&nbsp;», la construction utilisera «&nbsp;-O3&nbsp;».
    </para>

    <para>
      On peut passer divers autres drapeaux dans CFLAGS et CXXFLAGS, comme pour
forcer la compilation pour une microarchitecture spécifique
(p. ex. -march=amdfam10, -march=native) ou pour spécifier un standard C ou
C++ particulier (-std=c++17 par exemple). Mais ce qui commence à apparaître,
c'est l'inclusion par les développeurs d'assertions de débogage dans leur
code qui sont généralement désactivés dans les versions publiées avec
-DNDEBUG. Plus spécifiquement, si <xref linkend="mesa"/> est construit avec
ces assertions, certaines activités comme le chargement de niveaux dans les
jeux peuvent prendre très longtemps, même sur des cartes vidéo haut de
gamme.
    </para>

    <bridgehead renderas="sect3" id="autotools-info">Autotools avec Make</bridgehead>

      <para>
       Cette combinaison est souvent décrite comme «&nbsp;CMMI&nbsp;» (configure,
make, make install) et est utilisée ici pour couvrir aussi certains paquets
dont le script configure n'a pas été généré par les autotools.
      </para>

      <para>
        Parfois lancer <command>./configure --help</command> affichera les options
utiles des paramètres qui peuvent être utilisés. D'autres fois, après avoir
regardé la sortie de configure vous pourriez avoir besoin de regarder les
détails du script pour comprendre ce qu'il cherchait vraiment.
      </para>

      <para>
       De nombreux scripts configure récupéreront les CFLAGS et CXXFLAGS de
l'environnement, mais les paquets CMMI varient dans la manière dont ils
seront insérés avec les drapeaux qui seraient sinon utilisés (<emphasis>au
choix</emphasis>&nbsp;: ignorés, utilisés à la place de la suggestion des
programmeurs, utilisés avant la suggestion des programmeurs ou utilisés
après la suggestion des programmeurs).
      </para>

      <para>
       Dans la plupart des paquets CMMI, «&nbsp;make&nbsp;» listera les commande
lancées, séparées par des avertissements éventuels. Mais certains paquets
essayent d'être «&nbsp;silencieux&nbsp;» et ne montrent que les fichiers
qu'ils compilent ou dont ils éditent les liens au lieu de montrer la ligne
de commande. Si vous devez inspecter la commande, soit à cause d'une erreur,
ou juste pour voir les options et les drapeaux utilisés, ajouter
«&nbsp;V=1&nbsp;» à l'invocation make peut aider.
     </para>

    <bridgehead renderas="sect3" id="cmake-info">CMake</bridgehead>

      <para>
        CMake fonctionne de manière différente, et il a deux moteurs qui peuvent
être utilisés sur BLFS&nbsp;: «&nbsp;make&nbsp;» et «&nbsp;ninja&nbsp;». Le
moteur par défaut est make, mais ninja est plus rapide sur les paquets plus
gros avec plusieurs processeurs. Pour utiliser ninja, spécifiez «&nbsp;-G
Ninja&nbsp;» dans la commande cmake. Cependant, certains paquets peuvent
avoir des erreurs fatales dans leurs fichiers ninja tout en pouvant être
construits sans problème avec les Makefile Unix par défaut.
      </para>

      <para>
        La partie la plus dure de l'utilisation de CMake est de connaître les
options que vous voudrez spécifier. La seule manière de récupérer une liste
de ce que le paquet connait est de lancer <command>cmake -LAH</command> et
de regarder la sortie pour cette configuration par défaut.
      </para>

      <para>
        Peut-être que la chose la plus importante à propos de CMake est qu'il a
plusieurs valeurs de CMAKE_BUILD_TYPE, et qu'elles affectent les
drapeaux. La valeur par défaut est vide et aucun drapeau n'est généré. Les
CFLAGS et CXXFLAGS dans l'environnement seront utilisés. Si le programmeur a
codé des assertions de débogage, elles seront activées à moins que vous
n'utilisiez -DNDEBUG. Les valeurs CMAKE_BUILD_TYPE suivantes généreront les
drapeaux associés, et ils seront ajoutés <emphasis>après</emphasis> les
drapeaux dans l'environnement et prennent donc le pas dessus.
      </para>

      <itemizedlist>
        <listitem>
          <para>Debug&nbsp;: «&nbsp;-g&nbsp;»</para>
        </listitem>
        <listitem>
          <para>Release&nbsp;: «&nbsp;-O3 -DNDEBUG&nbsp;»</para>
        </listitem>
        <listitem>
           <para>RelWithDebInfo&nbsp;: «&nbsp;-O2 -g -DNDEBUG&nbsp;»</para>
        </listitem>
        <listitem>
           <para>MinSizeRel&nbsp;: «&nbsp;-Os -DNDEBUG&nbsp;»</para>
        </listitem>
      </itemizedlist>

      <para>
        CMake essaye de produire des constructions silencieuses. Pour voir les
détails des commandes lancées, utilisez «&nbsp;make VERBOSE=1&nbsp;» ou
«&nbsp;ninja -v&nbsp;».
      </para>

    <bridgehead renderas="sect3" id="meson-info">Meson</bridgehead>

      <para>
        Meson ressemble un peu à CMake, mais avec beaucoup de différences. Pour
trouver les détails des définitions que vous pourriez avoir besoin de
modifier vous pouvez regarder dans <filename>meson_options.txt</filename>
qui est généralement dans le répertoire de plus haut niveau.
      </para>

      <para>
        Si vous avez déjà configuré le paquet en lançant <command>meson</command> et
que vous souhaitez maintenant changer un ou plusieurs paramètres, vous
pouvez soit supprimer le répertoire de construction, le recréer et utiliser
les options modifiées, soit lancer <command>meson configure</command> dans
le répertoire de construction, p. ex. pour ajouter une option&nbsp;:
      </para>

<screen><userinput>meson configure -D&lt;some_option&gt;=true</userinput></screen>

      <para>
        Si vous faîtes cela, le fichier
<filename>meson-private/cmd_line.txt</filename> contiendra les
<emphasis>dernières</emphasis> commandes qui ont été utilisées.
      </para>

      <para>
        Meson fournit les valeurs buildtype suivantes, et les drapeaux qu'elles
activent viennent <emphasis>après</emphasis> les drapeaux fournis dans
l'environnement et prennent donc le pas.
      </para>

      <itemizedlist>
        <listitem>
          <para>plain&nbsp;: pas de drapeau supplémentaire. Cela est utilisé pour spécifier
ses propres CFLAGS, CXXFLAGS et LDFLAGS. Il n'y a pas de raison évidente
pour utiliser cela dans BLFS.</para>
        </listitem>
        <listitem>
          <para>debug&nbsp;: «&nbsp;-g&nbsp;»</para>
        </listitem>
        <listitem>
           <para>debugoptimized&nbsp;: «&nbsp;-O2 -g&nbsp;» - c'est la valeur par défaut si
rien n'est spécifié, elle laisse les assertions activées.</para>
        </listitem>
        <listitem>
           <para>release&nbsp;: «&nbsp;-O3 -DNDEBUG&nbsp;» (mais parfois un paquet forcera
-O2)</para>
        </listitem>
      </itemizedlist>

      <para>
        Bien que le type «&nbsp;release&nbsp;» soit décrit comme activant -DNDEBUG
et que toutes les constructions CMake en Release le passent, cela n'a été
observé jusque là (sur les constructions verbeuses) que pour <xref
linkend="mesa"/>. Cela suggère qu'il ne serait utilisé que s'il y a des
assertions de débogage.
      </para>

      <para>
        Le drapeau -DNDEBUG peut aussi être fournit en passant
<command>-Db_ndebug=true</command>.
      </para>

      <para>
        Pour voir les détails des commandes qui sont lancés dans un paquet qui
utilise meson, utilisez «&nbsp;ninja -v&nbsp;».
      </para>

    <bridgehead renderas="sect3" id="rust-info">Rustc et Cargo</bridgehead>

      <para>
        La plupart des programmes rustc publiés sont fournis dans des archives (ou
«&nbsp;crates&nbsp;») qui demanderont à un serveur de vérifier les versions
actuelles des dépendances et les téléchargera au besoin. Ces paquet sont
construits avec <command>cargo --release</command>. En théorie, on peut
manipuler les RUSTFLAGS pour changer le niveau d'optimisation (par défaut 3,
come -O3, p. ex. <literal>-Copt-level=3</literal>) ou pour forcer la
construction pour la machine sur laquelle il est compilé, avec
<literal>-Ctarget-cpu=native</literal> mais en pratique cela ne semble pas
faire de réelle différence.
      </para>

      <para>
        Si vous trouvez un programme rustc intéressant qui n'est fournit que sous
forme de sources sans paquet, vous devriez au moins spécifier
<literal>RUSTFLAGS=-Copt-level=2</literal> sans quoi rustc effectuera une
compilation sans optimisation et et avec les informations de débogage et le
résultat sera <emphasis>beaucoup</emphasis> plus lent.
      </para>

      <para>
        Les développeurs de rust ont l'air de supposer que tout le monde compile sur
une machine dédiées aux constructions de production, donc par défaut tous
les CPU sont utilisés. Cela peut souvent être changé, soit en exportant
CARGO_BUILD_JOBS=&lt;N&gt; ou en passant --jobs &lt;N&gt; à cargo. Pour
compiler rustc lui-même, spécifiez --jobs &lt;N&gt; lors de l'invocation de
x.py (avec la variable d'environnement <envar>CARGO_BUILD_JOBS</envar>, ce
qui ressemble à une approche «&nbsp;ceinture et bretelle&nbsp;» mais a l'air
nécessaire). L'exception est le lancement des tests à la construction de
rustc, où certains d'entre eux utiliseront tout de même tous les CPU en
ligne, aux moins à partir de rustc-1.42.0.
      </para>

  </sect2>

  <sect2 id="optimizations">
    <title>Optimisation de la construction</title>

      <para>
        De nombreuses personnes préfèrent optimiser la compilation à leur goût, en
fournissant CFLAGS ou CXXFLAGS. Vous trouverez une introduction aux options
disponibles avec gcc et g++ sur <ulink
url="https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html"/>, <ulink
url="https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html"/> et
dans <command>info gcc</command>.

      </para>

      <para>
        Some packages default to '-O2 -g', others to '-O3 -g', and if CFLAGS or
CXXFLAGS are supplied they might be added to the package's defaults, replace
the package's defaults, or even be ignored.  There are details on some
desktop packages which were mostly current in April 2019 at <ulink
url="https://www.linuxfromscratch.org/~ken/tuning/"/> - in particular,
README.txt, tuning-1-packages-and-notes.txt, and tuning-notes-2B.txt. The
particular thing to remember is that if you want to try some of the more
interesting flags you may need to force verbose builds to confirm what is
being used.
      </para>

      <para>
        Clairement, si vous optimisez votre propre programme vous pouvez passer du
temps à effectuer des mesures et peut-être recoder certaines parties plutôt
lentes. Mais pour construire un système complet cette approche est
impossible. En général, -O3 produit des programmes plus rapides que
-O2. Spécifier -march=native est aussi bénéfique, mais cela signifie que
vous ne pouvez pas utiliser les binaires sur une machine incompatible — cela
s'applique aussi à des machines plus récentes, pas seulement à des machines
plus vieilles. Par exemple les programmes compilés pour
«&nbsp;amdfam10&nbsp;» peuvent tourner sur les vieux Phenoms, Kaveris et
Ryzens&nbsp;; mais les programmes compilés pour un Kaveri ne tourneront pas
sur un Ryzen parce que certains opcodes ne sont pas présents. De manière
identique, si vous construisez pour un Haswell tout ne tournera pas sur un
SandyBridge.
      </para>

      <para>
        Il y a aussi diverses autres options que certains pensent bénéfiques. Au
pire, vous devrez recompiler et tester, pour découvrir que pour votre
utilisation ces options font rien de spécial.
      </para>

      <para>
        Si vous construisez des modules Perl ou Python, ou des paquets Qt qui
utilisent qmake, en général les CFLAGS et CXXFLAGS utilisés sont ceux
utilisés pour construire ces paquets «&nbsp;parents&nbsp;».
      </para>

  </sect2>

  <sect2 id="hardening">
    <title>Options pour durcir la construction</title>

      <para>
        Même sur un système de bureau, il y a des vulnérabilités exploitables. Pour
beaucoup, l'attaque vient de javascript dans un navigateur. Souvent, une
série de vulnérabilités sont utilisées pour récupérer un accès aux données
(ou parfois pour powner, c.-à-d. cracker la machine et installer des
rootkits). La plupart des distributions commerciales appliqueront diverses
mesures de durcissement.
      </para>

      <para>
        Pour les options de durcissement qui sont raisonnablement peu coûteuses, on
en parle un peu dans le lien sur les expériences de peaufinage précédent
(parfois une ou plus de ces options peuvent être inappropriées pour un
paquet). Ces options sont -D_FORTIFY_SOURCE=2, -fstack-protector=strong et
(pour C++) -D_GLIBCXX_ASSERTIONS. Sur les machines modernes elles ne
devraient avoir qu'un très faible impact sur la vitesse des programmes et
souvent ne seront même pas perceptibles.
      </para>

      <para>
        Par le passé, il existait un Hardened LFS (LFS durci) où gcc (une version
beaucoup plus vieille) était forcé à utiliser le durcissement (avec des
options pour les désactiver au cas par cas). Ce dont on parle ici est
différent — vous devrez déjà vous assurer que le paquet utilise bien vos
options supplémentaires et qu'il ne les écrase pas.
      </para>

      <para>
        Les distros principales utilisent bien plus, comme RELRO (Relocation Read
Only) et parfois -fstack-clash-protection. Vous pouvez aussi rencontrer les
«&nbsp;retpolines en espace utilisateur&nbsp;» (-mindirect-branch=thunk etc)
qui sont équivalents aux atténuations de spectre appliqués au noyau linux
fin 2018. Les atténuations du noyau ont causés de nombreuses plaintes à
propos d'une perte de performances donc si vous avez un serveur en
production vous devriez peut-être tester ça ainsi que d'autres options
disponibles, pour voir si les performances sont toujours satisfaisantes.
      </para>

      <para>
        Tandis que gcc a de nombreuses options de durcissement, la force de
clang/LLVM se trouve ailleurs. Certaines options fournies par gcc sont dite
moins efficaces dans clang/LLVM.
      </para>

  </sect2>

</sect1>
