<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../../general.ent">
  %general-entities;
]>

<sect1 id="pkgmgt">
  <?dbhtml filename="pkgmgt.html"?>

  <sect1info>
<date>$Date$</date></sect1info>

  <title>Gestion de paquets</title>

  <para>La gestion de paquets est un ajout souvent demandé au livre LFS. Un
gestionnaire de paquets permet de conserver une trace des fichiers
installés, simplifiant ainsi la suppression ou la mise à jour des
paquets. Avant toute chose, NON, cette section ne parle pas d'un
gestionnaire de paquets particulier ni n'en recommande un. Elle fait une
analyse des techniques les plus populaires et leur fonctionnement. Le
gestionnaire de paquets parfait pourrait faire partie de ces techniques ou
pourrait être une combinaison d'une ou plusieurs techniques. Cette section
mentionne brièvement les problèmes pouvant survenir lors de la mise à jour
des paquets.</para>

  <para>Quelques raisons de l'absence de mention d'un gestionnaire de paquets dans
LFS ou BLFS&nbsp;:</para>

  <itemizedlist>
    <listitem>
      <para>S'occuper de la gestion de paquets détourne l’attention des objectifs de ces
livres qui est l’enseignement de la construction d’un système Linux.</para>
    </listitem>
    <listitem>
      <para>Il existe de nombreuses solutions pour la gestion de paquets. Chacune ayant
ses forces et ses faiblesses, en inclure une qui satisfera tout le monde est
difficile.</para>
    </listitem>
  </itemizedlist>

  <para>Des astuces ont été rédigées sur le thème de la gestion de paquets. Visitez
le <ulink url="&hints-root;">sous-projet des astuces</ulink> et voyez celui
qui satisfait vos besoins.</para>

  <sect2>
    <title>Problèmes de mise à jour</title>

    <para>Un gestionnaire de paquets facilite les mises à jour vers les nouvelles
versions au moment de leur sortie. Généralement, les instructions dans les
livres LFS et BLFS peuvent être utilisées pour mettre à jour vers les
nouvelles versions. Voici quelques points à connaître lors d’une mise à jour
de paquets, spécialement sur un système en cours d’exécution.</para>

    <itemizedlist>
      <listitem>
        <para>Si un des paquets de l'ensemble d'outils (<application>Glibc</application>,
<application>GCC</application> ou <application>Binutils</application>) doit
être mis à jour avec une nouvelle version mineure, il est plus sûr de
reconstruire LFS. Bien que vous <emphasis>pourriez</emphasis> être capable
de reconstruire tous les paquets dans leur ordre de dépendances, nous ne le
recommandons pas. Par exemple, si glibc-2.2.x a besoin d'être mis à jour
vers glibc-2.3.x, il est préférable de reconstruire. Pour les mises à jour
encore plus mineures, une simple réinstallation fonctionne généralement mais
cela n'est pas garanti. Par exemple, mettre à jour de glibc-2.3.4 à
glibc-2.3.5 ne causera en général aucun problème.</para>
      </listitem>
      <listitem>
        <para>Si un paquet contenant une bibliothèque partagée est mis à jour et si le nom
de cette dernière est modifié, alors tous les paquets liés dynamiquement à
la bibliothèque devront être recompilés pour être liés à la nouvelle
bibliothèque. (Remarquez qu'il n'y a aucune corrélation entre la version du
paquet et le nom de la bibliothèque.) Par exemple, imaginez un paquet
foo-1.2.3 qui installe une bibliothèque partagée de nom <filename
class='libraryfile'>libfoo.so.1</filename>. Disons que vous mettez à jour le
paquet avec une nouvelle version foo-1.2.4 qui installe une bibliothèque
partagée de nom <filename class='libraryfile'>libfoo.so.2</filename>. Dans
ce cas, tous les paquets liés dynamiquement à <filename
class='libraryfile'>libfoo.so.1</filename> doivent être recompilés pour être
liés à <filename class='libraryfile'>libfoo.so.2</filename>. Remarquez que
vous ne devriez pas supprimer les anciennes bibliothèques jusqu'à ce que les
paquets dépendants soient recompilés.</para>
      </listitem>
      <listitem>
        <para>Si vous mettez à jour un système en cours d’exécution, cherchez des paquets
qui utilisent <command>cp</command> à la place de <command>install</command>
pour installer des fichiers. La dernière commande est en général plus sûre
si l'exécutable ou la bibliothèque est déjà chargé en mémoire.</para>
      </listitem>
    </itemizedlist>

  </sect2>

  <sect2>
    <title>Techniques de gestion de paquets</title>

    <para>Voici une liste de techniques habituelles de gestion de paquets. Avant de
vous décider sur un gestionnaire de paquets, faites une recherche sur les
différentes techniques et notamment leurs faiblesses.</para>

    <sect3>
      <title>Tout est dans ma tête&nbsp;!</title>

      <para>Oui, c'est une technique de gestion de paquets. Certains n'éprouvent pas le
besoin d'utiliser un gestionnaire de paquets parce qu'ils connaissent très
bien les paquets et connaissent les fichiers installés par chaque
paquet. Certains utilisateurs n'en ont pas besoin parce qu'ils prévoient de
reconstruire entièrement LFS lorsqu'un paquet est modifié.</para>

    </sect3>

    <sect3>
      <title>Installer dans des répertoires séparés</title>

      <para>C'est une gestion des paquets simple qui ne nécessite aucun paquet
supplémentaire pour gérer les installations. Chaque paquet est installé dans
un répertoire séparé. Par exemple, le paquet foo-1.1 est installé dans
<filename class='directory'>/usr/pkg/foo-1.1</filename> et un lien
symbolique est créé de <filename>/usr/pkg/foo</filename> vers <filename
class='directory'>/usr/pkg/foo-1.1</filename>. Lors de l'installation de la
nouvelle version foo-1.2, elle est installée dans <filename
class='directory'>/usr/pkg/foo-1.2</filename> et l'ancien lien symbolique
est remplacé par un lien symbolique vers la nouvelle version.</para>

      <para>Les variables d'environnement telles que celles indiquées dans <quote><xref
linkend="beyond"/></quote> ont besoin d'être étendues pour inclure
<filename>/usr/pkg/foo</filename>. Ce schéma devient ingérable dans le cas
d’un trop gros nombre de paquets.</para>

    </sect3>

    <sect3>
      <title>Gestion de paquet par lien symbolique</title>

      <para>C'est une variante de la technique précédente. Chaque paquet est installé de
façon similaire au schéma précédent. Mais au lieu de réaliser le lien
symbolique, chaque fichier dispose d'un lien symbolique vers son équivalent
dans la hiérarchie <filename class='directory'>/usr</filename>. Ceci
supprime le besoin d'étendre les variables d'environnement. Bien que les
liens symboliques puissent être créés par l'utilisateur, pour en automatiser
la création, certains gestionnaires de paquets ont été écrits avec cette
approche. Parmi les plus populaires se trouvent Stow, Epkg, Graft et Depot.</para>

      <para>L'installation doit être faussée, de façon à ce que chaque paquet pense
qu'il est installé dans <filename class="directory">/usr</filename> alors
qu'en réalité il est installé dans la hiérarchie <filename
class="directory">/usr/pkg</filename>. Installer de cette manière n'est
généralement pas une tâche aisée. Par exemple, imaginez que vous installez
un paquet libfoo-1.1. Les instructions suivantes pourraient ne pas installer
correctement le paquet&nbsp;:</para>

<screen><userinput>./configure --prefix=/usr/pkg/libfoo/1.1
make
make install</userinput></screen>

      <para>L'installation fonctionnera mais les paquets dépendants pourraient ne pas
lier libfoo comme vous vous y attendriez. Si vous compilez un paquet qui se
lie à libfoo, vous pourrez remarquer qu'il se lie à <filename
class='libraryfile'>/usr/pkg/libfoo/1.1/lib/libfoo.so.1</filename> au lieu
de <filename class='libraryfile'>/usr/lib/libfoo.so.1</filename> comme vous
le prévoyiez. La bonne approche est d'utiliser la stratégie
<envar>DESTDIR</envar> pour fausser l'installation du paquet. Cette approche
fonctionne ainsi&nbsp;:</para>

<screen><userinput>./configure --prefix=/usr
make
make DESTDIR=/usr/pkg/libfoo/1.1 install</userinput></screen>

      <para>La plupart des paquets prennent en charge cette approche mais elle pose
problème à certains. Pour les paquets non compatibles, vous devrez les
installer manuellement, ou alors vous pouvez trouver plus simple d'installer
les paquets problématiques dans <filename class='directory'>/opt</filename>.</para>

    </sect3>

    <sect3>
      <title>Basé sur l'horodatage</title>

      <para>Avec cette technique, un fichier est horodaté avant l'installation du
paquet. Après l'installation, une simple utilisation de la commande
<command>find</command> avec les options appropriées peut générer un journal
de tous les fichiers installés après la création du fichier
horodaté. install-log est un gestionnaire de paquets écrit avec cette
approche.</para>

      <para>Bien que ce schéma a l'avantage d'être simple, il a deux inconvénients. Si à
l'installation, les fichiers sont installés avec un horodatage autre que
celui de l'heure actuelle, ces fichiers ne seront pas suivis par le
gestionnaire de paquets. De plus, ce schéma peut seulement être utilisé
lorsqu'un seul paquet est installé à la fois. Les registres ne sont pas
fiables si deux paquets sont installés dans deux consoles différentes.</para>

    </sect3>

    <sect3>
      <title>Basé sur LD_PRELOAD</title>

      <para>Avec cette approche, une bibliothèque est préchargée avant
l'installation. Pendant l'installation, cette bibliothèque suit les paquets
qui sont installés en s'attachant à divers exécutables tels que
<command>cp</command>, <command>install</command>, <command>mv</command> et
en suivant les appels système qui modifient le système de fichiers. Pour que
cette approche fonctionne, tous les exécutables doivent être liés de façon
dynamique sans le bit suid ou sgid (id super utilisateur ou super
groupe). Le préchargement de la bibliothèque peut provoquer des effets
indésirables pendant l'installation. Effectuez donc des tests pour vous
assurer que le gestionnaire de paquets ne casse rien et journalise tous les
fichiers adéquats.</para>

    </sect3>

    <sect3>
      <title>Créer des archives de paquets</title>

      <para>Dans ce schéma, l'installation d'un paquet est faussée dans un répertoire
séparé comme précédemment décrit dans la gestion de paquet par lien
symbolique. Après l'installation, une archive du paquet est créée en
utilisant les fichiers installés. L'archive est ensuite utilisée pour
installer le paquet sur la machine locale voire même sur d'autres machines.</para>

      <para>Cette approche est utilisée par la plupart des gestionnaires de paquets
trouvés dans les distributions commerciales. Les exemples de gestionnaires
qui suivent cette approche sont RPM, pkg-utils, apt de Debian et le système
Portage de Gentoo.</para>

    </sect3>

    <sect3>
      <title>Gestion basée sur les utilisateurs</title>

      <para>Ce schéma, unique à LFS, a été décrit par Matthias Benkmann et est
disponible sur le <ulink url="&hints-root;">Projet des astuces</ulink>. Dans
ce schéma, chaque paquet est installé en tant qu'utilisateur séparé dans les
emplacements standards. Les fichiers appartenant à un paquet sont facilement
identifiés grâce à l'identifiant de l'utilisateur. Les fonctionnalités et
avantages de cette approche sont trop complexes pour les décrire dans cette
section. Pour plus de détails, voir l'astuce sur <ulink
url="&hints-root;/downloads/files/more_control_and_pkg_man.txt"/>.</para>

    </sect3>

  </sect2>

</sect1>
