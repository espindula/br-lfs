<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../../general.ent">
  %general-entities;

  <!ENTITY rust-download-http "https://static.rust-lang.org/dist/rustc-&rust-version;-src.tar.gz">
  <!ENTITY rust-download-ftp  "">
  <!ENTITY rust-md5sum        "275744c77bf07fd07abe0fd829e6dafb">
  <!ENTITY rust-size          "176&nbsp;Mo">
  <!-- Gentle Reminder: buildsize is how much the user requires for the real
       install, i.e. the source with its DESTDIR *plus* the DESTDIR.  You
       can 'mkdir /tmp/RUST ; cp -a install/* /tmp/RUST' and then run 'du -sch'
       to measure it, or du -sm to look at the size of the build tree before and
       after the tests. -->
	
  <!ENTITY rust-buildsize     "8,7 Go (417 Mo installés), dont 296 Mo de fichiers ~/.cargo pour
l'utilisateur qui le construit. Plus 6,5 Go si vous lancez les tests, dont
281 Mo supplémentaires de fichiers ~/.cargo.">
  <!ENTITY rust-time          "25 SBU (en comptant le temps de téléchargement, plus 13 SBU pour les tests,
dans les deux cas avec 4 processeurs)">
]>

<sect1 id="rust" xreflabel="rustc-&rust-version;">
  <?dbhtml filename="rust.html"?>

  <sect1info>
<date>$Date$</date></sect1info>

  <title>Rustc-&rust-version;</title>

  <indexterm zone="rust">
    <primary sortas="a-rust">Rust</primary>
  </indexterm>

  <sect2 role="package">
    <title>Introduction à Rust</title>

    <para>
      Le langage de programmation <application>Rust</application> est conçu pour
être un langage sûr, concurrent et pratique.
    </para>

    <para>
      Ce paquet est mis à jour sur un cycle de publication de six semaines. Comme
c'est un gros paquet long à construire et qu'il n'est actuellement utilisé
que par quelques paquets dans le livre, les éditeurs de BLFS pensent qu'il
ne devrait être mis à jour que lorsque cela est nécessaire (soit pour
corriger des problèmes, soit pour permettre à une nouvelle version d'un
paquet d'être construite).
    </para>

    <para>
      Comme avec tous les langages de programmation, rustc (le compilateur rust)
requiert un binaire à partir duquel bootstraper. Il téléchargera un binaire
stage0, et plusieurs fichier cargo (ce sont en fait des archives de source
en .tar.gz) au début de la construction, donc vous ne pouvez pas le compiler
sans connexion internet.
    </para>

    <para>
      Ces recettes resteront éternellement dans divers formats (caches, répertoire
des sources) dans <filename class="directory">~/.cargo</filename>. Les gros
paquets <application>rust</application> utilisent régulièrement plusieurs
versions de certaines recettes. Si vous supprimez les fichiers avant de
mettre à jour ce paquet, très peut de recettes devront être mises à jour par
les paquets dans ce livre (et elles seront téléchargé au besoin). Mais si
vous gardez une ancienne version comme option de secours puis l'utilisez (il
ne faudrait alors <emphasis>pas</emphasis> construire dans <filename
class="directory">/usr</filename>), il est fort probable qu'elle
re-téléchargera certaines recettes. Pour un téléchargement complet
(c.-à-d.&nbsp;à partir d'un répertoire <filename
class="directory">~/.cargo</filename> vide ou manquant), le téléchargement
des fichiers cargo externes pour cette version ne prend qu'une minute ou
deux sur un réseau rapide.
    </para>

    <note>
      <para>
        Bien que BLFS installe généralement ses logiciels dans <filename
class="directory">/usr</filename>, lorsque vous mettez à jour vers une
nouvelle version de <application>rust</application> les anciennes
bibliothèques de <filename class="directory">/usr/lib/rustlib</filename>
resteront présentes, avec divers condensats dans leur nom, mais seront
inutiles et gaspilleront de l'espace disque. Les éditeurs recommandent de
placer ces fichiers dans le répertoire <filename
class="directory">/opt</filename>. En particulier, si vous avez une raison
pour reconstruire avec une configuration différente (p. ex. pour utiliser le
LLVM interne après avoir construit avec un LLVM partagé, peut-être pour
compiler des crates pour des architectures non prises en charge par le LLVM
de BLFS) il est possible que l'installation laisse un programme
<command>cargo</command> cassé. Dans une telle situation, vous pouvez soit
supprimer l'installation existante avant, soit utiliser un préfixe
différent, comme /opt/rust-&rust-version;-build2.
      </para>

      <para>
        Si vous préférez, vous pouvez évidemment changer le préfixe en <filename
class="directory">/usr</filename> et omettre le lancement de
<command>ldconfig</command> et les actions pour ajouter rustc au PATH.
      </para>
    </note>

    <para>
      Le système de construction <application>rustbuild</application> actuel
utilisera tous les processeurs, bien qu'il ne passe pas bien à l'échelle et
utilise souvent un seul cœur en attendant la compilation d'une
bibliothèque. Cependant, il peut presque être limité à un nombre de cœurs
donné en combinant l'option <literal>--jobs &lt;N&gt;</literal>
(p. ex. «&nbsp;--jobs 4&nbsp;» pour limiter à 4 processeurs) à chaque
invocation de <command>python3 ./x.py</command> <emphasis>et</emphasis> en
utilisant la variable d'environnement
<envar>CARGO_BUILD_JOBS=&lt;N&gt;</envar>. Pour l'instant cela n'est pas
efficace lors du lancement de certains tests de rustc.
    </para>

    <para>
      La version actuelle du paquet rust num_cpus peut désormais utiliser les
cgroups pour restreindre les processeurs qui peuvent être utilisés. Donc si
votre machine manque de DRAM (typiquement moins de 2Go de DRAM par cœur),
cela peut être une bonne alternative à passer vos CPU hors-ligne. <phrase
revision="sysv">Pour les systèmes sysv, les cgroups nécessitent <ulink
url="https://sourceforge.net/projects/libcg/">libcgroup</ulink>.</phrase>
<phrase revision="systemd">Cela peut apparemment se faire en écrivant des
fichiers d'unité systemd personnalisés.</phrase>
    </para>

    <para>
      Pour l'instant <application>Rust</application> ne donne aucune garantie de
stabilité de son ABI.
    </para>

    <note>
      <para>
        Rustc construit par défaut pour TOUTES les architectures supportées, avec
une copie embarquée de LLVM. Dans BLFS la construction n'est utile que pour
l'architecture X86. Si vous voulez développer des crates rust, cette
construction peut ne pas vous satisfaire.
      </para>
      <para>
        Les temps de construction de cette version lorsqu'elle est répétée sur la
même machine sont souvent assez cohérents, mais comme avec toutes les
compilations qui utilisent <command>rustc</command> il peut y avoir quelques
exceptions très lentes.
      </para>
      <para>
        De manière inhabituelle, la méthode DESTDIR est utilisée pour installer ce
paquet. Cela est dû au fait que lancer l'installation en root télécharge
tous les fichiers cargo de nouveau (dans <filename>/root/.cargo</filename>)
puis passe encore beaucoup de temps à tout recompiler. Cette méthode réduit
de beaucoup le temps de construction au prix d'un espace disque plus
important.
      </para>
    </note>

    &lfs111_checked;

    <bridgehead renderas="sect3">Informations sur le paquet</bridgehead>
    <itemizedlist spacing="compact">
      <listitem>
        <para>
          Téléchargement (HTTP)&nbsp;: <ulink url="&rust-download-http;"/>
        </para>
      </listitem>
      <listitem>
        <para>
          Téléchargement (FTP)&nbsp;: <ulink url="&rust-download-ftp;"/>
        </para>
      </listitem>
      <listitem>
        <para>
          Somme de contrôle MD5&nbsp;: &rust-md5sum;
        </para>
      </listitem>
      <listitem>
        <para>
          Taille du téléchargement&nbsp;: &rust-size;
        </para>
      </listitem>
      <listitem>
        <para>
          Estimation de l'espace disque requis&nbsp;: &rust-buildsize;
        </para>
      </listitem>
      <listitem>
        <para>
          Estimation du temps de construction&nbsp;: &rust-time;
        </para>
      </listitem>
    </itemizedlist>



    <!--<bridgehead renderas="sect3">
Additional Downloads</bridgehead>
    <itemizedlist spacing="compact">
      <listitem>
        <para>
          Required patch:
          <ulink url="&patch-root;/rustc-&rust-version;-llvm9_fixes-1.patch"/>
        </para>
      </listitem>
    </itemizedlist>-->
<bridgehead renderas="sect3">Dépendances de Rust</bridgehead>

    <bridgehead renderas="sect4">Requises</bridgehead>
    <para role="required">
      <xref linkend="curl"/>, <xref linkend="cmake"/> et <xref linkend="libssh2"/>
    </para>

    <bridgehead renderas="sect4">Recommandées</bridgehead>
    <para role="recommended">
      <!-- the versions of LLVM in LFS-10.0, 10.1 and 11.0 are good enough
           to use for this version of rustc, so do not mention builds
           using shipped LLVM here, those are a lot bigger.
      If using an older version, see the config.toml file below re
      using the shipped llvm, because of rust issue 69225.-->
<package>clang</package> de <xref linkend="llvm"/> (construit avec
-DLLVM_LINK_LLVM_DYLIB=ON pour que rust puisse se lier au LLVM du système au
lieu de compiler la version intégrée)
      
    </para>

    <bridgehead renderas="sect4">Facultatives</bridgehead>
    <para role="optional">
      <xref linkend="gdb"/> (utilisé par la suite de tests s'il est présent)
    </para>

    <para condition="html" role="usernotes">
      Notes utilisateur&nbsp;: <ulink url="&blfs-wiki;/rust"/>
    </para>
  </sect2>

  <sect2 role="installation">
    <title>Installation de Rust</title>

    <para>
      Pour installer dans le répertoire <filename
class="directory">/opt</filename>, supprimez le lien symbolique et créez un
nouveau répertoire (c.-à-d. avec un nom différent si vous essayez une
construction différente). En tant qu'utilisateur <systemitem
class="username">root</systemitem>&nbsp;:
    </para>

<screen role="root"><userinput>mkdir /opt/rustc-&rust-version;             &amp;&amp;
ln -svfn rustc-&rust-version; /opt/rustc</userinput></screen>

    <note>
      <para>
        Si vous avez installé plusieurs versions de <application>Rust</application>
dans <filename class="directory">/opt</filename>, pour changer de version,
vous n'aurez besoin que de changer le lien symbolique
<filename>/opt/rustc</filename> puis de lancer <command>ldconfig</command>.
      </para>
    </note>

    <para>
      Créez un fichier <filename>config.toml</filename> correct qui configurera la
construction.
    </para>

<!--<para>

     Adapt rustc to allow it to build and function with the changes in LLVM-9:
    </para>

<screen><userinput remap="pre">patch -Np1 -i ../rustc-&rust-version;-llvm9_fixes-1.patch</userinput></screen>-->
<screen><userinput>cat &lt;&lt; EOF &gt; config.toml
<literal># see config.toml.example for more possible options
# See the 8.4 book for an example using shipped LLVM
# e.g. if not installing clang, or using a version before 10.0
[llvm]
# by default, rust will build for a myriad of architectures
targets = "X86"

# When using system llvm prefer shared libraries
link-shared = true

[build]
# omit docs to save time and space (default is to build them)
docs = false

# install cargo as well as rust
extended = true

[install]
prefix = "/opt/rustc-&rust-version;"
docdir = "share/doc/rustc-&rust-version;"

[rust]
channel = "stable"
rpath = false

# BLFS does not install the FileCheck executable from llvm,
# so disable codegen tests
codegen-tests = false

[target.x86_64-unknown-linux-gnu]
# NB the output of llvm-config (i.e. help options) may be
# dumped to the screen when config.toml is parsed.
llvm-config = "/usr/bin/llvm-config"

[target.i686-unknown-linux-gnu]
# NB the output of llvm-config (i.e. help options) may be
# dumped to the screen when config.toml is parsed.
llvm-config = "/usr/bin/llvm-config"

</literal>
EOF</userinput></screen>



    <para>
      Compilez <application>Rust</application> en exécutant les commandes
suivantes&nbsp;:
    </para>



<screen><!-- fixed in 1.58.0, retain as a reminder that fixed crates can be used
<screen>
<userinput>sed -i -e '/^curl /s/0.4.38/0.4.40/' \
       -e '/^curl-sys /s/0.4.48/0.4.50/' \
       src/tools/cargo/Cargo.toml &amp;&amp; -->
<userinput>export RUSTFLAGS="$RUSTFLAGS -C link-args=-lffi" &amp;&amp;
python3 ./x.py build --exclude src/tools/miri</userinput></screen>

    <note>
      <para>
        La suite de tests générera certains messages dans le <phrase
revision="sysv">journal système</phrase><phrase revision="systemd">journal
systemd</phrase> à propos de capture d'opcodes invalides, et d'erreurs de
segmentation. En soit il n'y a rien à craindre, ce n'est qu'une manière pour
le test de terminer.
      </para>
    </note>

    <para>
      Pour lancer les tests, lancez <command>python3 ./x.py test --verbose
--no-fail-fast | tee rustc-testlog</command>&nbsp;: comme pour la
construction, cela utilisera tous les CPU disponibles.
    </para>

    <para>
      <!--  If <command>
gdb</command> is installed,  another failure
      (debuginfo/function-names.rs) can be expected.
      # seems ok with 11.2 ken -->
Au minimum, 49 tests échoueront&nbsp;: les 48 tests de la suite
<quote>assembly</quote> qui ne sont pas passés (plusieurs options de
vérification font que les avertissements sont traités comme des erreurs) et
run-make-fulldeps/long-linker-command-lines.

    </para>

    <para>
      Comme avec toutes les grosses suites de tests, d'autres tests peuvent
échouer sur certaines machines&nbsp;: s'il y a moins d'une dizaine d'échecs
supplémentaires, cherchez le lignes commençant par «&nbsp;failures:&nbsp;»
dans le journal et regardez les lignes au-dessus, surtout les lignes
«&nbsp;stderr:&nbsp;». Toute mention de SIGSEGV ou signal 11 dans un test
échoué peut s'avérer problématique.
    </para>

    <para>
      Si vous avez un <emphasis>autre</emphasis> test qui rapporte un numéro de
problème vous devriez rechercher ce problème. Par exemple lorsque rustc
&gt;= 1.41.1 était construit avec une version de sysllvm avant 10.0 le test
pour le problème 69225 échouait <ulink
url="https://github.com/rust-lang/rust/issues/69225"/> et cela devrait être
vu comme un problème critique (ils ont publié 1.41.1 à cause de ça). La
plupart des autres problèmes ne seront pas critiques.
    </para>

    <para>
      Donc, vous devriez déterminer le nombre d'échecs.
    </para>



    <!--
 The total number
      of tests varies depending on which dependencies are present, e.g. more
      will be run if <command>
gdb</command> is available. If you wish, the
      total number which were considered can be found if you run:
    </para>

<screen remap="test"><userinput>egrep 'running [[:digit:]]+ test' rustc-testlog | awk '{ sum += $2 } END { print sum }'</userinput></screen>-->
<para>
      Le nombre de tests échoués peut être trouvé avec&nbsp;:
    </para>

<screen remap="test"><userinput>grep '^test result:' rustc-testlog | awk  '{ sum += $6 } END { print sum }'</userinput></screen>

    <para>
      Et pareil pour les tests qui ont réussi, utilisez $4, pour ceux qui sont
ignoré (c'est-à-dire passés) utilisez $8 (et $10 pour les tests mesurés, $12
pour ceux qui ont été filtrés mais ces deux-là sont probablement à 0).
    </para>

    <para>
      Toujours en tant qu'utilisateur normal, installez avec la méthode
DESTDIR&nbsp;:
    </para>

<screen><userinput>export LIBSSH2_SYS_USE_PKG_CONFIG=1 &amp;&amp;
DESTDIR=${PWD}/install python3 ./x.py install &amp;&amp;
unset LIBSSH2_SYS_USE_PKG_CONFIG</userinput></screen>

    <para>
      Maintenant, en tant qu'utilisateur <systemitem
class="username">root</systemitem> installez les fichiers du DESTDIR&nbsp;:
    </para>

<screen role="root"><userinput>chown -R root:root install &amp;&amp;
cp -a install/* /</userinput></screen>

  </sect2>

  <sect2 role="commands">
    <title>Explication des commandes</title>

    <para>
      <command>ln -svfn rustc-&rust-version; /opt/rustc</command>&nbsp;: si ce
n'est pas la première fois que vous utilisez le lien symbolique <filename
class="directory">/opt/rustc</filename>, le réécrit en forçant et utilise le
drapeau «&nbsp;-n&nbsp;» pour éviter d'avoir des résultats bizarre avec
p. ex. <command>ls -l</command>.
    </para>

    <para>
      <command>targets = "X86"</command>&nbsp;: cela évite de construire tous les
compilateurs croisés disponibles (Aarch64, MIPS, PowerPC, SystemZ,
etc). Malheureusement, rust insiste pour installer leurs fichiers sources
sous <filename class="directory">/opt/rustc/lib/src</filename>.
    </para>

    <para>
      <command>extended = true</command>&nbsp;: Cela installe Cargo avec Rust.
    </para>

    <para>
      <command>channel = "stable"</command>&nbsp;: cela s'assure que seules les
fonctionnalités stables peuvent être utilisée, la valeur par défaut dans
<filename>config.toml</filename> est d'utiliser les fonctionnalités de
développement, qui ne sont pas appropriées pour une version publique.
    </para>

    <para>
      <command>rpath = false</command>&nbsp;: par défaut, <command>rust</command>
peut être lancé depuis son emplacement de construction sans être
installé. Cela ajoute des entrées DT_RPATH à tous les fichiers ELF, ce qui
produit une sortie très chargée de la part de <command>ldd</command>,
contenant les bibliothèques à l'emplacement de leur construction, même si
elles ont été supprimées de là après l'installation.
    </para>

    
    <!-- comment while using shipped LLVM -->
<para>
      <command>[target.x86_64-unknown-linux-gnu]</command>&nbsp;: la syntaxe de
<filename>config.toml</filename> requiert une entrée
<literal>llvm-config</literal> pour chaque cible pour laquelle system-llvm
doit être utilisé. Modifiez la cible en
<literal>[target.i686-unknown-linux-gnu]</literal> si vous construisez sur
x86 32&nbsp;bits. La section complète peut être omise si vous souhaitez
construire avec la version de llvm incluse ou que vous n'avez pas clang,
mais la construction qui en résultera sera plus grande et prendra plus de
temps.
    </para>



    <!--<para>

      <command>sed -i -e '/^curl /s/0.4.38/0.4.40/' ... </command>: two crates
      normally downloaded for this release do not correctly initialise
      <application>curl</application> if using
      <application>openssl-3.0.0</application>. Upstream has fixed that for a
      future release, this sed causes the fixed versions to be used.
    </para>-->
<para>
      <command>export RUSTFLAGS="$RUSTFLAGS -C link-args=-lffi"</command>&nbsp;:
Cela ajoute un lien vers libffi dans les RUSTFLAGS que vous pourriez déjà
passer à la construction. Sur certains systèmes, l'édition de lien échoue à
inclure libffi à moins d'utiliser cela. La raison n'est pas très claire.
    </para>

    <para>
      <!-- might be unbroken in 1.36.0, if so remove broken from description
       of miri below. https://github.com/rust-lang/rust/issues/61830 -->
<command>--exclude src/tools/miri</command>&nbsp;: Depuis longtemps, la
recette de miri (un interpréteur pour la représentation intermédiaire de
mi-niveau) n'arrive pas à se construire dans les versions publiées. Il est
facultatif, mais les messages d'erreurs peuvent persuader les gens que la
construction complète a échouée. Cependant, bien qu'il ne soit pas compilé
pendant la compilation principale, avec rust-1.35.0 il est maintenant
compilé pendant l'installation, mais il était cassé dans cette
version. L'omettre devrait faire gagner un peu de temps.
    </para>

    <para>
      <command>--verbose</command>&nbsp;: ce paramètre peut parfois fournir plus
d'informations sur un test qui échoue.
    </para>

    <para>
      <command>--no-fail-fast</command>&nbsp;: ce paramètre s'assure que la suite
de tests ne s'arrêtera pas après la première erreur.
    </para>

    <para>
      <command>export LIBSSH2_SYS_USE_PKG_CONFIG=1</command>&nbsp;: Sur certains
systèmes, cairo échoue à se lier pendant l'installation parce qu'il ne
trouve pas libssh2. Cela semble corriger le problème, mais la raison en est
inconnue.
    </para>

    <para>
      <command>DESTDIR=${PWD}/install python3 ./x.py install</command>&nbsp;: Cela
fait une installation DESTDIR dans l'arborescence des sources, en créant un
répertoire <filename class="directory">install</filename>. Remarquez que les
installation DESTDIR ont besoin d'un chemin absolu. Passer
«&nbsp;install&nbsp;» ne fonctionnera pas.
    </para>

    <para>
      <command>chown -R root:root install</command>&nbsp;: l'installation DESTDIR
a été lancée par un utilsateur normal qui possède les fichiers. Par
sécurité, changez l'appartenance avant de faire une copie pour les
installer.
    </para>

  </sect2>

  <sect2 role="configuration">
    <title>Configuration de Rust</title>

    <sect3 id="rustc-config">
      <title>Informations sur la configuration</title>

      <para>
        Si vous avez installé <application>rustc</application> dans <filename
class="directory">/opt</filename>, vous devez mettre à jour les fichiers de
configuration suivants pour que <application>rustc</application> puisse être
trouvé correctement par les autres paquets et les processus du système.
      </para>

      <para>
        En tant qu'utilisateur <systemitem class="username">root</systemitem>,
mettez à jour le fichier <filename>/etc/ld.so.conf</filename> et le fichier
de cache d'exécution de l'éditeur de lien dynamique&nbsp;:
      </para>

<screen role="root"><userinput>cat &gt;&gt; /etc/ld.so.conf &lt;&lt; EOF
<literal># Begin rustc addition

/opt/rustc/lib

# End rustc addition</literal>
EOF

ldconfig</userinput></screen>

      <indexterm zone="rust rustc-config">
        <primary sortas="e-etc-ld.so.conf">/etc/ld.so.conf</primary>
      </indexterm>

      <para>
        En tant qu'utilisateur <systemitem class="username">root</systemitem>, créez
le fichier <filename>/etc/profile.d/rustc.sh</filename>&nbsp;:
      </para>

<screen role="root"><userinput>cat &gt; /etc/profile.d/rustc.sh &lt;&lt; "EOF"
<literal># Begin /etc/profile.d/rustc.sh

pathprepend /opt/rustc/bin           PATH

# Include /opt/rustc/man in the MANPATH variable to access manual pages
pathappend  /opt/rustc/share/man     MANPATH

# End /etc/profile.d/rustc.sh</literal>
EOF</userinput></screen>

      <para>
        Immédiatement après l'installation, mettez à jour le PATH actuel de votre
shell en tant qu'utilisateur normal&nbsp;:
      </para>

<screen><userinput>source /etc/profile.d/rustc.sh</userinput></screen>

    </sect3>
  </sect2>


  <sect2 role="content">
    <title>Contents</title>

    <segmentedlist>
      <segtitle>Programmes installés</segtitle>
      <segtitle>Bibliothèques installées</segtitle>
      <segtitle>Répertoires installés</segtitle>

      <seglistitem>
        <seg>
          cargo-clippy, cargo-fmt, cargo-miri (facultatif), cargo, clippy-driver, miri
(facultatif), rls, rust-demangler, rust-gdb, rust-gdbgui, rust-lldb, rustc,
rustdoc, rustfmt.
        </seg>
        <seg>
          librustc-driver-&lt;16-byte-hash&gt;.so, libstd-&lt;16-byte-hash&gt;.so et
libtest-&lt;16-byte-hash&gt;.so
        </seg>
        <seg>
          ~/.cargo, /opt/rustc, lien symbolique vers /opt/rustc-&rust-version;
        </seg>
      </seglistitem>
    </segmentedlist>

    <variablelist>
      <bridgehead renderas="sect3">Descriptions courtes</bridgehead>
      <?dbfo list-presentation="list"?>
      <?dbhtml list-presentation="table"?>

      <varlistentry id="cargo-clippy">
        <term><command>cargo-clippy</command></term>
        <listitem>
          <para>
            fournit des tests de formatage pour un paquet cargo
          </para>
          <indexterm zone="rust cargo-clippy">
            <primary sortas="b-cargo-clippy">cargo-clippy</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="cargo-fmt">
        <term><command>cargo-fmt</command></term>
        <listitem>
          <para>
            formate tous les fichiers bin et lib de la source courante avec rustfmt
          </para>
          <indexterm zone="rust cargo-fmt">
            <primary sortas="b-cargo-fmt">cargo-fmt</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="cargo-miri">
        <term><command>cargo-miri</command></term>
        <listitem>
          <para>
            
            <!-- FIXME reword to 'is used by' if Miri installed
             AND works enough to report its \-\-help -->
est utilisé par Miri pour interpréter des recettes binaires et des tests
          </para>
          <indexterm zone="rust cargo-miri">
            <primary sortas="b-cargo-miri">cargo-miri</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="cargo">
        <term><command>cargo</command></term>
        <listitem>
          <para>
            est le gestionnaire de paquets de Rust
          </para>
          <indexterm zone="rust cargo">
            <primary sortas="b-cargo">cargo</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="clippy-driver">
        <term><command>clippy-driver</command></term>
        <listitem>
          <para>
            fournit des tests de formatage pour Rust
          </para>
          <indexterm zone="rust clippy-driver">
            <primary sortas="b-clippy-driver">clippy-driver</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="miri">
        <term><command>miri</command></term>
        <listitem>
          <para>
            est un interpréteur pour la représentation intermédiaire de mi-niveau de
Rust (MIR). Il est cassé dans cette version
          </para>
          <indexterm zone="rust miri">
            <primary sortas="b-miri">miri</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="rls">
        <term><command>rls</command></term>
        <listitem>
          <para>
            est le serveur du langage Rust. Il peut être lancé en tâche de fond pour
fournir des informations sur les programmes Rust à des IDE, des éditeurs et
d'autres outils
          </para>
          <indexterm zone="rust rls">
            <primary sortas="b-rls">rls</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="rust-analyzer">
        <term><command>rust-analyzer</command></term>
        <listitem>
          <para>
            est une implémentation du protocole de serveur de langue pour le langage de
programmation Rust.
          </para>
          <indexterm zone="rust rust-analyzer">
            <primary sortas="b-rust-analyzer">rust-analyzer</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="rust-gdb">
        <term><command>rust-gdb</command></term>
        <listitem>
          <para>
            est un script enveloppe pour gdb qui récupère les modules d'affichage Python
installés dans <filename
class="directory">/opt/rustc-&rust-version;/lib/rustlib/etc</filename>
          </para>
          <indexterm zone="rust rust-gdb">
            <primary sortas="b-rust-gdb">rust-gdb</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="rust-gdbgui">
        <term><command>rust-gdbgui</command></term>
        <listitem>
          <para>
            est un script enveloppe pour une interface graphique de gdb qui se lance
dans un navigateur
          </para>
          <indexterm zone="rust rust-gdbgui">
            <primary sortas="b-rust-gdbgui">rust-gdbgui</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="rust-lldb">
        <term><command>rust-lldb</command></term>
        <listitem>
          <para>
            est un script Python enveloppe pour LLDB (le débogueur de LLVM) qui récupère
les modules d'affichage Python
          </para>
          <indexterm zone="rust rust-lldb">
            <primary sortas="b-rust-lldb">rust=lldb</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="rustc">
        <term><command>rustc</command></term>
        <listitem>
          <para>
            est le compilateur rust
          </para>
          <indexterm zone="rust rustc">
            <primary sortas="b-rustc">rustc</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="rustdoc">
        <term><command>rustdoc</command></term>
        <listitem>
          <para>
            génère de la documentation à partir de code source rust
          </para>
          <indexterm zone="rust rustdoc">
            <primary sortas="b-rustdoc">rustdoc</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="rustfmt">
        <term><command>rustfmt</command></term>
        <listitem>
          <para>
            formatte du code rust
          </para>
          <indexterm zone="rust rustfmt">
            <primary sortas="b-rustfmt">rustfmt</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="libstd">
        <term><filename class="libraryfile">libstd-&lt;16-byte-hash&gt;.so</filename></term>
        <listitem>
          <para>
            est la Bibliothèque Standard de Rust, le fondement des logiciels Rust
portables
          </para>
          <indexterm zone="rust libstd">
            <primary sortas="c-libstd">libstd-&lt;16-byte-hash&gt;.so</primary>
          </indexterm>
        </listitem>
      </varlistentry>
    </variablelist>
  </sect2>

</sect1>
