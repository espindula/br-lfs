<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../../general.ent">
  %general-entities;
]>

<sect1 id="xorg-config">
  <?dbhtml filename="xorg-config.html"?>


  <title>Xorg-&xorg-version; Test et configuration</title>

  <indexterm zone="xorg-config">
    <primary sortas="g-configuring-xorg">Configuration de Xorg</primary>
  </indexterm>

  <sect2 id='X11-testing' xreflabel="Test de Xorg">
    <title>Test de Xorg</title>

    <note>
      <para>
        Avant de démarrer Xorg pour la première fois, il est utile de reconstruire
le cache des bibliothèques en lançant <userinput>ldconfig</userinput> en
tant qu'utilisateur <systemitem class="username">root</systemitem>.
      </para>
    </note>

    <note>
      <para>
        Avant de démarrer Xorg pour la première fois, il est souvent nécessaire de
redémarrer le système pour s'assurer que les démons appropriés sont démarrés
et que les paramètres de sécurités sont correctement initialisés. Autrement,
vous déconnecter et vous reconnecter peut fonctionner mais la méthode n'a
pas été testée.
      </para>
    </note>

    <warning>
      <para>
        Si Xorg se bloque (par exemple, s'il lui manque un pilote d'entrée), le
système peut arrêter de répondre aux entrées utilisateurs. En précaution,
vous pouvez activer la touche <keycap>SysRq</keycap> magique avant de tester
Xorg. En tant qu'utilisateur <systemitem class="username">root</systemitem>,
lancez&nbsp;:
      </para>

<screen><userinput>echo 4 > /proc/sys/kernel/sysrq</userinput></screen>

      <para>
        Si Xorg freeze, vous pouvez utiliser <keycombo><keycap>Alt</keycap>
<keycap>SysRq</keycap> <keycap>R</keycap></keycombo> pour réinitialiser le
mode clavier. Maintenant vous devriez pouvoir utiliser
<keycombo><keycap>Ctrl</keycap> <keycap>Alt</keycap> <keycap>Fx</keycap>
</keycombo> (remplacez x par un numéro de terminal virtuel) pour passer à un
autre VT. Si cela fonctionne, connectez-vous et tuez Xorg via la ligne de
commande dans le nouveau VT.
      </para>
    </warning>

    <para>
      Pour tester l'installation de <application>Xorg</application>, tapez
<command>startx</command>. Cette commande lance un gestionnaire de fenêtres
très rudimentaire appelé <emphasis>twm</emphasis> avec trois terminaux X
(xterm) et une fenêtre d'horloge (xclock). Le terminal X dans le coin
supérieur gauche est un terminal de login et lancer
<emphasis>exit</emphasis> dans le terminal quittera la session
<application>X Window</application>.  Le troisième terminal X peut être
recouvert sur votre système par les deux autres terminaux X.
    </para>

    <note>
      <para>
        <!--<filename revision="sysv">

        /var/log/Xorg.0.log</filename><filename revision="systemd">-->
<!--</filename>
-->
Lorsque vous testez <application>Xorg</application> avec le gestionnaire de
fenêtres <application>twm</application>, il y aura plusieurs avertissements
dans le fichier de log de Xorg, $HOME/.local/share/xorg/Xorg.0.log à propos
de fichiers de police manquants. En plus, il y a plusieurs avertissement sur
le terminal en mode texte (habituellement tty1) à propos de polices
manquantes. Ces avertissements n'affectent pas le fonctionnement, mais
peuvent être supprimés si désiré en installant <xref
linkend="xorg7-legacy"/>.
      </para>
    </note>

    <note>
      <para>
        <!--https://gitlab.freedesktop.org/drm/nouveau/-/issues/257-->
Sur un système avec un GPU NVIDIA qui utilise le pilote noyau Nouveau, vous
pourriez parfois rencontrer des crashs du GPU et des freezes. Si ce problème
arrive, revenez à la dernière version du noyau Linux 6.1.
        
      </para>
    </note>

    <para>
      Généralement, il n'y a pas de configuration spécifique requise pour
<application>Xorg</application>, mais une personnalisation est
possible. Pour plus de détails voir <xref linkend="xconfig"/> en dessous.
    </para>

  </sect2>

  <sect2 role="configuration" id="checking-dri" xreflabel="Vérifier l'installation de la Direct Rendering Infrastructure (DRI)">
    <title>Vérifier l'installation de la Direct Rendering Infrastructure (DRI)</title>

    <para>
      DRI est un environnement permettant aux logiciels d'accéder au matériel
graphique d'une manière sûre et efficace. Elle est installée par défaut dans
<application>X</application> (en utilisant
<application>MesaLib</application>)  si vous avez une carte graphique
supportée.
    </para>

    <para>
      Pour vérifier que les pilotes DRI sont correctement installés, vérifiez que
le fichier journal <filename>$HOME/.local/share/xorg/Xorg.0.log</filename>
(ou <filename>/var/log/Xorg.0.log</filename> si vous avez construit <xref
linkend="xorg-server"/> avec le bit suid) contient des messages comme&nbsp;:
    </para>

<screen><literal>(II) modeset(0): [DRI2] Setup complete
(II) modeset(0): [DRI2]   DRI driver: crocus
(II) modeset(0): [DRI2]   VDPAU driver: va_gl</literal></screen>

    <note>
      <para>
        Il se peut que la configuration DRI diffère si vous utilisez d'autres
pilotes tels que les pilotes DDX traditionnels ou les pilotes propriétaires
de <ulink url="https://www.nvidia.com/page/home.html">NVIDIA</ulink> ou de
<ulink url="https://www.amd.com/">AMD</ulink>.
      </para>
    </note>


    <!-- With elogind, this is not needed anymore
    <para>

      Although all users can use software acceleration, any hardware
      acceleration (DRI2) is only available to <systemitem
      class="username">root</systemitem> and members of the <systemitem
      class="groupname">video</systemitem> group, but
      <phrase revision="sysv"><emphasis>ConsoleKit2</emphasis></phrase>
      <phrase revision="systemd"><emphasis>systemd-logind</emphasis></phrase>
      takes care of adding any logged in user to the user ACL's of
      <filename>/dev/dri/card*</filename>, the special file(s) allowing access
      to hardware acceleration.<phrase revision="systemd"> So, no further
      configuration is needed.</phrase>
    </para>

    <para revision="sysv">
      If your driver is supported and <emphasis>ConsoleKit2</emphasis> is not
      installed, add any users that might use X to the <systemitem
      class="groupname">video</systemitem> group:
    </para>

<screen role="root" revision="sysv"><userinput>usermod -a -G video <replaceable>&lt;username&gt;</replaceable></userinput></screen>
-->
<para>
      Une autre façon de déterminer si DRI fonctionne proprement est d'utiliser un
des deux programmes de démo d'OpenGL installés éventuellement par <xref
linkend="mesa"/>. Depuis un terminal X, lancez <command>glxinfo</command> et
cherchez le passage&nbsp;:
    </para>

<screen><computeroutput>name of display: :0
display: :0  screen: 0
direct rendering: Yes</computeroutput></screen>

    <para>
      Si le direct rendering est activé, vous pouvez ajouter de la verbosité en
lançant <command>LIBGL_DEBUG=verbose glxinfo</command>.  Ceci affichera les
pilotes, les n&oelig;uds de périphériques et les fichiers utilisés par le
système DRI.
    </para>

    <para>
      Pour confirmer que l'accélération matérielle DRI2 fonctionne, vous pouvez
(toujours dans un terminal X)  lancer la commande <command>glxinfo | grep -E
"(OpenGL vendor|OpenGL renderer|OpenGL version)"</command>. Si cela renvoie
quelque chose <emphasis>d'autre que</emphasis> <literal>Software
Rasterizer</literal> c'est que l'accélération fonctionne pour l'utilisateur
qui a lancé la commande.
    </para>

    <para>
      Si votre matériel n'a pas de pilote DRI2 de disponible, il utilisera un
rendu logiciel pour le Direct Rendering. Dans ce cas, vous pouvez utiliser
le nouveau rendu logiciel accéléré de LLVM appelé LLVMPipe. Avant de
construire LLVMPipe soyez certain que <xref linkend="llvm"/> est présent au
moment de la construction de Mesa. Merci de noter que tous les décodages
sont fait par le processeur à la place du GPU, donc l'affichage sera plus
lent qu'avec l'accélération matérielle. Pour vérifier si vous utilisez
LLVMpipe, regardez la sortie de la commande glxinfo précédente. Un exemple
de sortie utilisant le rendu logiciel est montré en dessous&nbsp;:
    </para>

<screen><computeroutput>OpenGL vendor string: VMware, Inc.
OpenGL renderer string: Gallium 0.4 on llvmpipe (LLVM 3.5, 256 bits)
OpenGL version string: 3.0 Mesa 10.4.5</computeroutput></screen>

    <para>
      Vous pouvez toujours forcer LLVMPipe en exportant la variable
d'environnement <envar>LIBGL_ALWAYS_SOFTWARE=1</envar> quand vous démarré
Xorg.
    </para>

    <para>
      De nouveau, si vous avez ajouté le paquet Mesa-Demos, vous pouvez aussi
lancer le programme de test <command>glxgears</command>.  Ce programme
affiche une fenêtre de trois boutons à bascule. Le <command>xterm</command>
affichera le nombre de cadres dessinés toutes les cinq secondes, donc c'est
un test fiable. La fenêtre est redimensionnable et les cadres dessinés par
secondes dépendent beaucoup de la taille de la fenêtre.
    </para>

  </sect2>

  <sect2 role="configuration" id="xorg-debug" xreflabel="Débogage de Xorg">
    <title>Débogage de Xorg</title>

    <para>
      Lorsque vous démarrez xorg, il y a plusieurs moyens de vérifier les
problèmes que vous pourriez avoir. Si le système démarre, vous pouvez voir
le pilote utilisé en lançant <command>xdriinfo</command>. Si vous avez des
problèmes ou souhaitez seulement vérifier, regardez dans
<filename>Xorg.0.log</filename>.
    </para>

    <para>
      L'emplacement de <filename>Xorg.0.log</filename> dépend de la manière dont
Xorg est installé. Si vous avez suivi précisément les instructions du livre
et que Xorg est démarré en ligne de commande, il se trouvera dans le
répertoire <filename
class="directory">$HOME/.local/share/xorg/</filename>. Si Xorg est démarré
par un gestionnaire d'affichage (p.&nbsp;ex. <xref linkend='lightdm'/>,
<xref linkend='sddm'/> ou <xref linkend='gdm'/>) ou si
<filename>$XORG_PREFIX/bin/Xorg</filename> a le bit suid, il se trouvera
dans le répertoire <filename class="directory">/var/log/</filename>.
    </para>

    <bridgehead renderas="sect3">Problèmes dans Xorg.0.log</bridgehead>

    <para>
      Quand vous ouvrez Xorg.0.log, cherchez les entrées comme (EE) ou (WW). Voici
quelques entrées courantes&nbsp;:
    </para>

    <bridgehead renderas="sect5">(WW) Open ACPI failed (/var/run/acpid.socket)</bridgehead>

    <para>
      Cet avertissement a pour origine le fait qu'<xref linkend='acpid'/> n'est
pas installé. Si vous n'êtes pas sur un ordinateur portable, il peut être
ignoré sans problème. Sur un ordinateur portable, installez <xref
linkend='acpid'/> pour activer les actions comme la reconnaissance de la
fermeture de l'écran.
    </para>

    <bridgehead renderas="sect5">(WW) VGA arbiter: cannot open kernel arbiter, no multi-card support</bridgehead>

    <para>
      Cet avertissement est affiché quand un utilisateur normal démarre Xorg. La
bibliothèque <filename>libpciaccess.so</filename> lance cet avertissement
quand elle essaye d'ouvrir <filename>/dev/vga_arbiter</filename>. S'il n'y a
pas plus d'une ancienne carte graphique PCI (et pas PCIe) sur le système, il
peut être ignoré sans problème. Si c'est vraiment nécessaire, les
permissions pour ce périphérique peuvent être changées avec une règle udev
et en ajoutant l’utilisateur local au groupe video. En tant qu'utilisateur
&root;&nbsp;:
    </para>

<screen role="root"><userinput>cat > /etc/udev/rules.d/99-vga-arbiter.rules &lt;&lt; EOF
# /etc/udev/rules.d/99-vga-arbiter.rules: Set vga_arbiter group/mode

ACTION=="add", KERNEL=="vga_arbiter", GROUP="video" MODE="0660"
EOF

usermod -a -G video &lt;user running xorg&gt;</userinput></screen>

  </sect2>

  <sect2 role="configuration" id="hybrid-graphics" xreflabel="Hybrid Graphics">
    <title>Hybrid Graphics</title>

    <para>
      Hybrid Graphics est expérimental dans Linux. Les développeurs de Xorg ont
mis au point une technologie appelé PRIME qui peut être utilisée pour
commuter entre le GPU intégré et celui du processeur "muxless" à souhait. La
commutation automatique n'est pas possible pour le moment.
    </para>

    <para>
      Pour utiliser PRIME pour la commutation de GPU, soyez certain d'utiliser le
noyau Linux 3.4 ou plus (recommandé). Vous devez avoir les pilotes DRI et
DDX pour votre matériel et avoir <application>Xorg Server</application> 1.13
ou plus.
    </para>

    <para>
      <application>Xorg Server</application> devrait charger les deux pilotes GPU
automatiquement. Vous pouvez le vérifier en lançant&nbsp;:
    </para>

<screen><userinput>xrandr --listproviders</userinput></screen>

    <para>
      Il devrait y avoir deux (ou plus) fournisseurs indiqués, par exemple&nbsp;:
    </para>

<!-- Well, both "id" and "name" are supposed to work here but after
         the xf86-video-* removal all the names will be modesetting unless
         a proprietary driver used... -->
<screen><computeroutput>Providers: number : 2
Provider 0: id: 0x7d cap: 0xb, Source Output, Sink Output, Sink Offload crtcs: 3 outputs: 4 associated providers: 1 name:modesetting
Provider 1: id: 0x56 cap: 0xf, Source Output, Sink Output, Source Offload, Sink Offload crtcs: 6 outputs: 1 associated providers: 1 name:modesetting</computeroutput></screen>

    
    <para>
      Pour pouvoir lancer une application GLX sur un GPU particulier, vous devrez
lancer la commande suivante, où &lt;provider&gt; est l'identifiant du plus
puissant et &lt;sink&gt; est l'identifiant de la carte qui fait l'affichage.
    </para>

<screen><userinput>xrandr --setprovideroffloadsink <replaceable>&lt;provider&gt; &lt;sink&gt;</replaceable></userinput></screen>

    <note>
      <para>
        Avec le pilote <application>Xorg</application> modesetting, qui peut
utiliser DRI3, la commande ci-dessus n'est plus nécessaire. Ça ne fait pas
de mal non plus.
      </para>
    </note>

    <para>
      Ensuite, vous devrez exporter la variable d'environnement
<envar>DRI_PRIME=1</envar> à chaque fois que vous voudrez utiliser le GPU le
plus puissant. Par exemple, <screen><userinput>DRI_PRIME=1 glxinfo | grep -E "(OpenGL vendor|OpenGL renderer|OpenGL version)"</userinput></screen> affichera le
fournisseur OpenGL, le rendu et la version du GPU.
    </para>

    <para>
      Si la dernière commande affiche le même rendu OpenGL avec ou sans
<envar>DRI_PRIME=1</envar>, vous devez vérifier votre installation.
    </para>

  </sect2>

  <sect2 role="configuration" id='xconfig'>
    <title>Configuration des périphériques Xorg</title>

    <para>
      Pour la plupart des configurations matérielles, Xorg va automatiquement
obtenir la configuration correcte du serveur sans aucune intervention de
l'utilisateur. Il existe cependant certains cas où l'auto-configuration sera
incorrecte. Voici quelques exemples de la configuration manuelle qui peuvent
être utile dans ces cas-là.
    </para>

    <sect3 id="xinput">
      <title>Configuration des périphériques X d'entrée</title>
      <para>
        Pour la plupart des périphériques d'entrée, aucune configuration
supplémentaire ne sera nécessaire. Cette section est fournie à titre
informatif seulement.
      </para>

      <para>
        Un exemple de configuration XKB par défaut peut être celui-ci (exécuté en
tant que <systemitem class="username">root</systemitem>)&nbsp;:
      </para>

<screen role="root"><userinput>cat &gt; /etc/X11/xorg.conf.d/xkb-defaults.conf &lt;&lt; "EOF"
<literal>Section "InputClass"
    Identifier "XKB Defaults"
    MatchIsKeyboard "yes"
    Option "XkbLayout" "fr"
    Option "XkbOptions" "terminate:ctrl_alt_bksp"
EndSection</literal>
EOF</userinput></screen>

      <para>
        La ligne <quote>XkbLayout</quote> est un exemple pour un clavier français
(AZERTY). Modifiez-la pour votre modèle de clavier. Cette ligne n'est pas
utile pour un clavier QWERTY (US).
      </para>
    </sect3>

    <sect3 id="xdisplay">
      <title>Réglage fin des paramètres d'affichage</title>

      <para>
        Si vous voulez configurer la résolution de l'écran pour Xorg, exécutez
d'abord <command>xrandr</command> dans un terminal X pour lister les
résolutions prises en charge et les taux de rafraîchissement
correspondants. Par exemple, voici la sortie pour un écran donné&nbsp;:
      </para>

<screen><computeroutput>Screen 0: minimum 16 x 16, current 5760 x 2160, maximum 32767 x 32767
DP-1 connected primary 3840x2160+0+0 (normal left inverted right x axis y axis) 600mm x 340mm
   3840x2160     59.98*+
   2048x1536     59.95
   1920x1440     59.90
   1600x1200     59.87
   1440x1080     59.99
   1400x1050     59.98
   1280x1024     59.89
   1280x960      59.94
   1152x864      59.96
   1024x768      59.92
   800x600       59.86
   640x480       59.38</computeroutput></screen>

      <para>
        À partir de la sortie, on peut voir que l'écran est identifié avec
<literal>DP-1</literal>. Choisissez une résolution appropriée dans la liste
en sortie, par exemple <literal>1920x1440</literal>. Ensuit en tant
qu'utilisation &root;, créez un fichier de configuration pour le serveur
Xorg&nbsp;:
      </para>

<screen role="root"><userinput>cat &gt; /etc/X11/xorg.conf.d/monitor-DP-1.conf &lt;&lt; "EOF"
<literal>Section "Monitor"
    Identifier  "DP-1"
    Option      "PerferredMode" "1920x1440"
EndSection</literal>
EOF</userinput></screen>

      <para>
        Parfois <command>xrandr</command> peut échouer à détecter certains
paramètres de résolution pris en charge par l'écran. Cela arrive surtout
avec les écrans virtuels des gestionnaires de machines virtuelles comme
<xref linkend='qemu'/> ou VMWare&nbsp;: un écran virtuel prend en fait en
charge toutes paires d'entier dans un intervalle, mais
<command>xrandr</command> n'en indiquera que quelques unes. Pour utiliser
une résolution qui n'est pas listée par <command>xrandr</command>, exécutez
d'abord <command>cvt</command> pour récupérer la mode line de la
résolution. Par exemple&nbsp;:
      </para>

      <screen><userinput>cvt 1600 900</userinput></screen>

      <para>
        En tant qu'utilisateur &root;, créez un fichier de configuration du serveur
Xorg contenant cette mode line, et spécifiez ce mode comme étant le mode
préféré&nbsp;:
      </para>

<screen role="root"><userinput>cat &gt; /etc/X11/xorg.conf.d/monitor-DP-1.conf &lt;&lt; "EOF"
<literal>Section "Monitor"
    Identifier  "DP-1"
    Modeline    "1600x900_60.00"  118.25  1600 1696 1856 2112  900 903 908 934 -hsync +vsync
    Option      "PerferredMode"   "1600x900_60.00"
EndSection</literal>
EOF</userinput></screen>

      <para>
        Certains écrans LCD haut de gamme prennent en charge un taux de
rafraichissement plus important que 100&nbsp;Hz mais
<command>xrandr</command> peut échouer à reconnaître le taux de
rafraîchissement pris en charge et utiliser 60&nbsp;Hz à la place. Ce
problème vous empêcherait d'utiliser toutes les capacités de votre écran, et
peut causer des clignotements ou afficher des <quote>artéfacts</quote> comme
des grilles ou des réseaux. Pour résoudre le problème, utilisez encore
<command>cvt</command> pour trouver la mode line avec un taux de
rafraîchissement personnalisé&nbsp;:
      </para>

      <screen><userinput>cvt 3840 2160 144</userinput></screen>

      <para>
        Puis collez-la dans le fichier de configuration du serveur Xorg et
indiquez-la comme mode préféré.
      </para>

      <para>
        Une autre configuration courante est d'avoir des configurations
multi-serveurs pour une utilisation dans des environnements différents. Bien
que le serveur détecte automatiquement la présence d'un autre moniteur, il
peut obtenir un ordre incorrect&nbsp;:
      </para>

<screen role="root"><userinput>cat &gt; /etc/X11/xorg.conf.d/server-layout.conf &lt;&lt; "EOF"
<literal>Section "ServerLayout"
    Identifier     "DefaultLayout"
    Screen      0  "Screen0" 0 0
    Screen      1  "Screen1" LeftOf "Screen0"
    Option         "Xinerama"
EndSection</literal>
EOF</userinput></screen>

      <para>
        Lorsque vous déplacez une fenêtre horizontalement dans twm (ou tout autre
gestionnaire de fenêtres sans compositeur), vous observerez peut-être que la
bordure verticale de la fenêtre est cassée en de multiples segments. C'est
un exemple d'artéfact visuel appelé <emphasis>screen
tearing</emphasis>. Pour résoudre ces problèmes, créez un fichier de
configuration qui active l'option TearFree. Remarquez que vous devez avoir
appliqué le correctif Tearfree de <xref role="nodep" linkend="xorg-server"/>
pour que cela fonctionne correctement, et il peut augmenter l'allocation
mémoire nécessaire et réduire les performances.
      </para>

<screen role="root"><userinput>cat &gt; /etc/X11/xorg.conf.d/20-tearfree.conf &lt;&lt; "EOF"
<literal>Section "Device"
   Identifier "Graphics Adapter"
   Driver     "modesetting"
   Option     "TearFree" "true"
EndSection</literal>
EOF</userinput></screen>

      <para>
        Avec un Xorg moderne, peu ou aucune configuration supplémentaire de carte
graphique n'est nécessaire. Si vous avez besoin d'options supplémentaires à
passer à votre pilote vidéo, ajoutez-les aussi à la section
<literal>Device</literal>. Les options prises en charge par le pilote de
gestion des modes sont documentées dans la page de manuel
<filename>modesetting(4)</filename>.
      </para>

    </sect3>
  </sect2>
</sect1>
