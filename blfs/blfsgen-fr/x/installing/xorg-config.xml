<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../../general.ent">
  %general-entities;
]>

<sect1 id="xorg-config">
  <?dbhtml filename="xorg-config.html"?>


  <title>Xorg-&xorg-version; Test et configuration</title>

  <indexterm zone="xorg-config">
    <primary sortas="g-configuring-xorg">Configuration de Xorg</primary>
  </indexterm>

  <sect2 id='X11-testing' xreflabel="Test de Xorg">
    <title>Test de Xorg</title>

    <note>
      <para>
        Avant de démarrer Xorg pour la première fois, il est utile de reconstruire
le cache des bibliothèques en lançant <userinput>ldconfig</userinput> en
tant qu'utilisateur <systemitem class="username">root</systemitem>.
      </para>
    </note>

    <note>
      <para>
        Avant de démarrer Xorg pour la première fois, il est souvent nécessaire de
redémarrer le système pour s'assurer que les démons appropriés sont démarrés
et que les paramètres de sécurités sont correctement initialisés. Autrement,
vous déconnecter et vous reconnecter peut fonctionner mais la méthode n'a
pas été testée.
      </para>
    </note>

    <warning>
      <para>
        Si Xorg se bloque (par exemple, s'il lui manque un pilote d'entrée), le
système peut arrêter de répondre aux entrées utilisateurs. En précaution,
vous pouvez activer la touche <keycap>SysRq</keycap> magique avant de tester
Xorg. En tant qu'utilisateur <systemitem class="username">root</systemitem>,
lancez&nbsp;:
      </para>

<screen><userinput>echo 4 > /proc/sys/kernel/sysrq</userinput></screen>

      <para>
        Si Xorg freeze, vous pouvez utiliser <keycombo><keycap>Alt</keycap>
<keycap>SysRq</keycap> <keycap>R</keycap></keycombo> pour réinitialiser le
mode clavier. Maintenant vous devriez pouvoir utiliser
<keycombo><keycap>Ctrl</keycap> <keycap>Alt</keycap> <keycap>Fx</keycap>
</keycombo> (remplacez x par un numéro de terminal virtuel) pour passer à un
autre VT. Si cela fonctionne, connectez-vous et tuez Xorg via la ligne de
commande dans le nouveau VT.
      </para>
    </warning>

    <para>
      Pour tester l'installation de <application>Xorg</application>, tapez
<command>startx</command>. Cette commande lance un gestionnaire de fenêtres
très rudimentaire appelé <emphasis>twm</emphasis> avec trois terminaux X
(xterm) et une fenêtre d'horloge (xclock). Le terminal X dans le coin
supérieur gauche est un terminal de login et lancer
<emphasis>exit</emphasis> dans le terminal quittera la session
<application>X Window</application>.  Le troisième terminal X peut être
recouvert sur votre système par les deux autres terminaux X.
    </para>

    <note>
      <para>
        <!--<filename revision="sysv">

        /var/log/Xorg.0.log</filename><filename revision="systemd">-->
<!--</filename>
-->
Lorsque vous testez <application>Xorg</application> avec le gestionnaire de
fenêtres <application>twm</application>, il y aura plusieurs avertissements
dans le fichier de log de Xorg, $HOME/.local/share/xorg/Xorg.0.log à propos
de fichiers de police manquants. En plus, il y a plusieurs avertissement sur
le terminal en mode texte (habituellement tty1) à propos de polices
manquantes. Ces avertissements n'affectent pas le fonctionnement, mais
peuvent être supprimés si désiré en installant <xref
linkend="xorg7-legacy"/>.
      </para>
    </note>

    <para>
      Généralement, il n'y a pas de configuration spécifique requise pour
<application>Xorg</application>, mais une personnalisation est
possible. Pour plus de détails voir <xref linkend="xconfig"/> en dessous.
    </para>

  </sect2>

  <sect2 role="configuration" id="checking-dri" xreflabel="Vérifier l'installation de la Direct Rendering Infrastructure (DRI)">
    <title>Vérifier l'installation de la Direct Rendering Infrastructure (DRI)</title>

    <para>
      DRI est un environnement permettant aux logiciels d'accéder au matériel
graphique d'une manière sûre et efficace. Elle est installée par défaut dans
<application>X</application> (en utilisant
<application>MesaLib</application>)  si vous avez une carte graphique
supportée.
    </para>

    <para>
      Pour vérifier que les pilotes DRI sont correctement installés, vérifiez que
le fichier journal <filename>$HOME/.local/share/xorg/Xorg.0.log</filename>
(ou <filename>/var/log/Xorg.0.log</filename> si vous avez construit <xref
linkend="xorg-server"/> avec le bit suid) contient des messages comme&nbsp;:
    </para>

<screen><literal>(II) modeset(0): [DRI2] Setup complete
(II) modeset(0): [DRI2]   DRI driver: crocus
(II) modeset(0): [DRI2]   VDPAU driver: va_gl</literal></screen>

    <note>
      <para>
        DRI configuration may differ if you are using alternate drivers, such as
traditional DDX drivers, or the proprietary drivers from <ulink
url="https://www.nvidia.com/page/home.html">NVIDIA</ulink> or <ulink
url="https://www.amd.com/">AMD</ulink>.
      </para>
    </note>


    <!-- With elogind, this is not needed anymore
    <para>

      Although all users can use software acceleration, any hardware
      acceleration (DRI2) is only available to <systemitem
      class="username">root</systemitem> and members of the <systemitem
      class="groupname">video</systemitem> group, but
      <phrase revision="sysv"><emphasis>ConsoleKit2</emphasis></phrase>
      <phrase revision="systemd"><emphasis>systemd-logind</emphasis></phrase>
      takes care of adding any logged in user to the user ACL's of
      <filename>/dev/dri/card*</filename>, the special file(s) allowing access
      to hardware acceleration.<phrase revision="systemd"> So, no further
      configuration is needed.</phrase>
    </para>

    <para revision="sysv">
      If your driver is supported and <emphasis>ConsoleKit2</emphasis> is not
      installed, add any users that might use X to the <systemitem
      class="groupname">video</systemitem> group:
    </para>

<screen role="root" revision="sysv"><userinput>usermod -a -G video <replaceable>&lt;username&gt;</replaceable></userinput></screen>
-->
<para>
      Une autre façon de déterminer si DRI fonctionne proprement est d'utiliser un
des deux programmes de démo d'OpenGL installés éventuellement par <xref
linkend="mesa"/>. Depuis un terminal X, lancez <command>glxinfo</command> et
cherchez le passage&nbsp;:
    </para>

<screen><computeroutput>name of display: :0
display: :0  screen: 0
direct rendering: Yes</computeroutput></screen>

    <para>
      Si le direct rendering est activé, vous pouvez ajouter de la verbosité en
lançant <command>LIBGL_DEBUG=verbose glxinfo</command>.  Ceci affichera les
pilotes, les n&oelig;uds de périphériques et les fichiers utilisés par le
système DRI.
    </para>

    <para>
      Pour confirmer que l'accélération matérielle DRI2 fonctionne, vous pouvez
(toujours dans un terminal X)  lancer la commande <command>glxinfo | grep -E
"(OpenGL vendor|OpenGL renderer|OpenGL version)"</command>. Si cela renvoie
quelque chose <emphasis>d'autre que</emphasis> <literal>Software
Rasterizer</literal> c'est que l'accélération fonctionne pour l'utilisateur
qui a lancé la commande.
    </para>

    <para>
      Si votre matériel n'a pas de pilote DRI2 de disponible, il utilisera un
rendu logiciel pour le Direct Rendering. Dans ce cas, vous pouvez utiliser
le nouveau rendu logiciel accéléré de LLVM appelé LLVMPipe. Avant de
construire LLVMPipe soyez certain que <xref linkend="llvm"/> est présent au
moment de la construction de Mesa. Merci de noter que tous les décodages
sont fait par le processeur à la place du GPU, donc l'affichage sera plus
lent qu'avec l'accélération matérielle. Pour vérifier si vous utilisez
LLVMpipe, regardez la sortie de la commande glxinfo précédente. Un exemple
de sortie utilisant le rendu logiciel est montré en dessous&nbsp;:
    </para>

<screen><computeroutput>OpenGL vendor string: VMware, Inc.
OpenGL renderer string: Gallium 0.4 on llvmpipe (LLVM 3.5, 256 bits)
OpenGL version string: 3.0 Mesa 10.4.5</computeroutput></screen>

    <para>
      Vous pouvez toujours forcer LLVMPipe en exportant la variable
d'environnement <envar>LIBGL_ALWAYS_SOFTWARE=1</envar> quand vous démarré
Xorg.
    </para>

    <para>
      De nouveau, si vous avez ajouté le paquet Mesa-Demos, vous pouvez aussi
lancer le programme de test <command>glxgears</command>.  Ce programme
affiche une fenêtre de trois boutons à bascule. Le <command>xterm</command>
affichera le nombre de cadres dessinés toutes les cinq secondes, donc c'est
un test fiable. La fenêtre est redimensionnable et les cadres dessinés par
secondes dépendent beaucoup de la taille de la fenêtre.
    </para>

  </sect2>

  <sect2 role="configuration" id="xorg-debug" xreflabel="Débogage de Xorg">
    <title>Débogage de Xorg</title>

    <para>
      Lorsque vous démarrez xorg, il y a plusieurs moyens de vérifier les
problèmes que vous pourriez avoir. Si le système démarre, vous pouvez voir
le pilote utilisé en lançant <command>xdriinfo</command>. Si vous avez des
problèmes ou souhaitez seulement vérifier, regardez dans
<filename>Xorg.0.log</filename>.
    </para>

    <para>
      The location of <filename>Xorg.0.log</filename> depends on how Xorg is
installed.  If the instructions in the book are followed closely and Xorg is
started from the command line, it will be located in the <filename
class="directory">$HOME/.local/share/xorg/</filename> directory.  If Xorg is
started by a display manager (e.g. <xref linkend='lightdm'/>, <xref
linkend='lxdm'/>, or <xref linkend='gdm'/>) or if
<filename>$XORG_PREFIX/bin/Xorg</filename> has the suid bit set, it will be
located in the <filename class="directory">/var/log/</filename> directory.
    </para>

    <bridgehead renderas="sect3">Problèmes dans Xorg.0.log</bridgehead>

    <para>
      Quand vous ouvrez Xorg.0.log, cherchez les entrées comme (EE) ou (WW). Voici
quelques entrées courantes&nbsp;:
    </para>

    <bridgehead renderas="sect5">(WW) Open ACPI failed (/var/run/acpid.socket)</bridgehead>

    <para>
      Cet avertissement a pour origine le fait qu'<xref linkend='acpid'/> n'est
pas installé. Si vous n'êtes pas sur un ordinateur portable, il peut être
ignoré sans problème. Sur un ordinateur portable, installez <xref
linkend='acpid'/> pour activer les actions comme la reconnaissance de la
fermeture de l'écran.
    </para>

    <bridgehead renderas="sect5">(WW) VGA arbiter: cannot open kernel arbiter, no multi-card support</bridgehead>

    <para>
      This warning is displayed when a regular user starts Xorg.  The library
<filename>libpciaccess.so</filename> issues this warning when it tries to
open <filename>/dev/vga_arbiter</filename>.  If there is no more than one
legacy PCI (not PCIe) graphic cards on the system, it can safely be
ignored.  If really necessary, the permissions of this device can be changed
by adding a udev rule and adding the local user to the video group. As the
&root; user:
    </para>

<screen role="root"><userinput>cat > /etc/udev/rules.d/99-vga-arbiter.rules &lt;&lt; EOF
# /etc/udev/rules.d/99-vga-arbiter.rules: Set vga_arbiter group/mode

ACTION=="add", KERNEL=="vga_arbiter", GROUP="video" MODE="0660"
EOF

usermod -a -G video &lt;user running xorg&gt;</userinput></screen>

  </sect2>

  <sect2 role="configuration" id="hybrid-graphics" xreflabel="Hybrid Graphics">
    <title>Hybrid Graphics</title>

    <para>
      Hybrid Graphics est expérimental dans Linux. Les développeurs de Xorg ont
mis au point une technologie appelé PRIME qui peut être utilisée pour
commuter entre le GPU intégré et celui du processeur "muxless" à souhait. La
commutation automatique n'est pas possible pour le moment.
    </para>

    <para>
      Pour utiliser PRIME pour la commutation de GPU, soyez certain d'utiliser le
noyau Linux 3.4 ou plus (recommandé). Vous devez avoir les pilotes DRI et
DDX pour votre matériel et avoir <application>Xorg Server</application> 1.13
ou plus.
    </para>

    <para>
      <application>Xorg Server</application> devrait charger les deux pilotes GPU
automatiquement. Vous pouvez le vérifier en lançant&nbsp;:
    </para>

<screen><userinput>xrandr --listproviders</userinput></screen>

    <para>
      Il devrait y avoir deux (ou plus) fournisseurs indiqués, par exemple&nbsp;:
    </para>

<!-- Well, both "id" and "name" are supposed to work here but after
         the xf86-video-* removal all the names will be modesetting unless
         a proprietary driver used... -->
<screen><computeroutput>Providers: number : 2
Provider 0: id: 0x7d cap: 0xb, Source Output, Sink Output, Sink Offload crtcs: 3 outputs: 4 associated providers: 1 name:modesetting
Provider 1: id: 0x56 cap: 0xf, Source Output, Sink Output, Source Offload, Sink Offload crtcs: 6 outputs: 1 associated providers: 1 name:modesetting</computeroutput></screen>

    
    <para>
      In order to be able to run a GLX application on a discrete GPU, you will
need to run the following command, where &lt;provider&gt; is the id of the
more powerful discrete card, and &lt;sink&gt; is the id of card which has a
display connected:
    </para>

<screen><userinput>xrandr --setprovideroffloadsink <replaceable>&lt;provider&gt; &lt;sink&gt;</replaceable></userinput></screen>

    <note>
      <para>
        With the <application>Xorg</application> modesetting driver, which is DRI3
capable, the above command is no longer necessary. It does no harm however.
      </para>
    </note>

    <para>
      Ensuite, vous devrez exporter la variable d'environnement
<envar>DRI_PRIME=1</envar> à chaque fois que vous voudrez utiliser le GPU le
plus puissant. Par exemple, <screen><userinput>DRI_PRIME=1 glxinfo | grep -E "(OpenGL vendor|OpenGL renderer|OpenGL version)"</userinput></screen> affichera le
fournisseur OpenGL, le rendu et la version du GPU.
    </para>

    <para>
      Si la dernière commande affiche le même rendu OpenGL avec ou sans
<envar>DRI_PRIME=1</envar>, vous devez vérifier votre installation.
    </para>

  </sect2>

  <sect2 role="configuration" id='xconfig'>
    <title>Configuration des périphériques Xorg</title>

    <para>
      Pour la plupart des configurations matérielles, Xorg va automatiquement
obtenir la configuration correcte du serveur sans aucune intervention de
l'utilisateur. Il existe cependant certains cas où l'auto-configuration sera
incorrecte. Voici quelques exemples de la configuration manuelle qui peuvent
être utile dans ces cas-là.
    </para>

    <sect3 id="xinput">
      <title>Configuration des périphériques X d'entrée</title>
      <para>
        Pour la plupart des périphériques d'entrée, aucune configuration
supplémentaire ne sera nécessaire. Cette section est fournie à titre
informatif seulement.
      </para>

      <para>
        Un exemple de configuration XKB par défaut peut être celui-ci (exécuté en
tant que <systemitem class="username">root</systemitem>)&nbsp;:
      </para>

<screen role="root"><userinput>cat &gt; /etc/X11/xorg.conf.d/xkb-defaults.conf &lt;&lt; "EOF"
<literal>Section "InputClass"
    Identifier "XKB Defaults"
    MatchIsKeyboard "yes"
    Option "XkbLayout" "fr"
    Option "XkbOptions" "terminate:ctrl_alt_bksp"
EndSection</literal>
EOF</userinput></screen>

      <para>
        La ligne <quote>XkbLayout</quote> est un exemple pour un clavier français
(AZERTY). Modifiez-la pour votre modèle de clavier. Cette ligne n'est pas
utile pour un clavier QWERTY (US).
      </para>
    </sect3>

    <sect3 id="xdisplay">
      <title>Réglage fin des paramètres d'affichage</title>

      <para>
        If you want to set the monitor resolution for Xorg, first run
<command>xrandr</command> in a X terminal to list the supported resolutions
and the corresponding refresh rates.  For example, it outputs the following
for one monitor:
      </para>

<screen><computeroutput>Screen 0: minimum 16 x 16, current 5760 x 2160, maximum 32767 x 32767
DP-1 connected primary 3840x2160+0+0 (normal left inverted right x axis y axis) 600mm x 340mm
   3840x2160     59.98*+
   2048x1536     59.95  
   1920x1440     59.90  
   1600x1200     59.87  
   1440x1080     59.99  
   1400x1050     59.98  
   1280x1024     59.89  
   1280x960      59.94  
   1152x864      59.96  
   1024x768      59.92  
   800x600       59.86  
   640x480       59.38  </computeroutput></screen>

      <para>
        From the output we can see the monitor is identified
<literal>DP-1</literal>.  Select a suitable resolution from the output list,
for example <literal>1920x1440</literal>.  Then as the &root; user, create a
configuration file for the Xorg server:
      </para>

<screen role="root"><userinput>cat &gt; /etc/X11/xorg.conf.d/monitor-DP-1.conf &lt;&lt; "EOF"
<literal>Section "Monitor"
    Identifier  "DP-1"
    Option      "PerferredMode" "1920x1440"
EndSection</literal>
EOF</userinput></screen>

      <para>
        Sometimes <command>xrandr</command> may fail to detect some resolution
settings supported by the monitor.  It usually happens with virtual monitors
of virtual machine managers like <xref linkend='qemu'/> or VMWare: a virtual
monitor actually supports all pairs of integers in a range as the
resolution, but <command>xrandr</command> will only list a few.  To use a
resolution not listed by <command>xrandr</command>, first run
<command>cvt</command> to get the mode line for the resolution.  For
example:
      </para>

      <screen><userinput>cvt 1600 900</userinput></screen>

      <para>
        As the &root; user, create a Xorg server configuration file containing this
mode line, and specify the mode as preferred mode:
      </para>

<screen role="root"><userinput>cat &gt; /etc/X11/xorg.conf.d/monitor-DP-1.conf &lt;&lt; "EOF"
<literal>Section "Monitor"
    Identifier  "DP-1"
    Modeline    "1600x900_60.00"  118.25  1600 1696 1856 2112  900 903 908 934 -hsync +vsync
    Option      "PerferredMode"   "1600x900_60.00"
EndSection</literal>
EOF</userinput></screen>

      <para>
        Some high-end LCD monitors support a refresh rate higher than 100 Hz but
<command>xrandr</command> may fail to recognize the supported refresh rate
and use 60 Hz instead.  This issue would prevent you from utilizing the full
capability of the monitor, and may cause the screen to flicker or show
<quote>artifacts</quote> like meshes or grids.  To resolve the issue, again
use <command>cvt</command> to get the mode line with a custom refresh rate:
      </para>

      <screen><userinput>cvt 3840 2160 144</userinput></screen>

      <para>
        Then paste it into the Xorg server configuration file and set it as the
preferred mode.
      </para>

      <para>
        Une autre configuration courante est d'avoir des configurations
multi-serveurs pour une utilisation dans des environnements différents. Bien
que le serveur détecte automatiquement la présence d'un autre moniteur, il
peut obtenir un ordre incorrect&nbsp;:
      </para>

<screen role="root"><userinput>cat &gt; /etc/X11/xorg.conf.d/server-layout.conf &lt;&lt; "EOF"
<literal>Section "ServerLayout"
    Identifier     "DefaultLayout"
    Screen      0  "Screen0" 0 0
    Screen      1  "Screen1" LeftOf "Screen0"
    Option         "Xinerama"
EndSection</literal>
EOF</userinput></screen>

      <para>
        When you drag a window in twm (or any non-compositing window manager)
horizontally, you may observe that the vertical borders of the window are
broken into multiple segments.  This is an example of the visual artifacts
called <emphasis>screen tearing</emphasis>.  To resolve the screen tearing
problems, create a configuration file that enables the TearFree option. Note
that you must have the Tearfree patch applied from <xref role="nodep"
linkend="xorg-server"/> for this to function properly, and it may increase
memory allocation and reduce performance.
      </para>

<screen role="root"><userinput>cat &gt; /etc/X11/xorg.conf.d/20-tearfree.conf &lt;&lt; "EOF"
<literal>Section "Device"
   Identifier "Graphics Adapter"
   Driver     "modesetting"
   Option     "TearFree" "true"
EndSection</literal>
EOF</userinput></screen>

      <para>
        With modern Xorg, little or no additional graphic card configuration is
necessary. If you should need extra options passed to your video driver, add
them into the <literal>Device</literal> section as well.  The options
supported by the modesetting driver are documented in the man page
<filename>modesetting(4)</filename>.
      </para>

    </sect3>
  </sect2>
</sect1>
