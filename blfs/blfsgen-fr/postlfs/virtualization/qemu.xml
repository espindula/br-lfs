<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../../general.ent">
  %general-entities;

  <!ENTITY qemu-download-http "https://download.qemu.org/qemu-&qemu-version;.tar.xz">
  <!ENTITY qemu-download-ftp  "">
  <!ENTITY qemu-md5sum        "7dd9ff5a92cf81cfce6cda1f6e271f3a">
  <!ENTITY qemu-size          "118&nbsp;Mo">
  <!ENTITY qemu-buildsize     "2,1&nbsp;Go (366&nbsp;Mo installés)">
  <!ENTITY qemu-time          "1,2&nbsp;SBU (plus 0,8&nbsp;SBU pour les tests, tous deux avec parallélisme
= 4)">
]>

<sect1 id="qemu" xreflabel="qemu-&qemu-version;">
  <?dbhtml filename="qemu.html"?>


  <title>qemu-&qemu-version;</title>

  <indexterm zone="qemu">
    <primary sortas="a-qemu">qemu</primary>
  </indexterm>

  <sect2 role="package">
    <title>Introduction à qemu</title>

    <para>
      <application>qemu</application> est une solution de virtualisation complète
pour Linux avec un processeur x86 supportant les extensions de
virtualisation (Intel VT ou AMD-V).
    </para>

    &lfs120_checked;

    <bridgehead renderas="sect3">Informations sur le paquet</bridgehead>
    <itemizedlist spacing="compact">
      <listitem>
        <para>
          Téléchargement (HTTP)&nbsp;: <ulink url="&qemu-download-http;"/>
        </para>
      </listitem>
      <listitem>
        <para>
          Téléchargement (FTP)&nbsp;: <ulink url="&qemu-download-ftp;"/>
        </para>
      </listitem>
      <listitem>
        <para>
          Somme de contrôle MD5&nbsp;: &qemu-md5sum;
        </para>
      </listitem>
      <listitem>
        <para>
          Taille du téléchargement&nbsp;: &qemu-size;
        </para>
      </listitem>
      <listitem>
        <para>
          Estimation de l'espace disque requis&nbsp;: &qemu-buildsize;
        </para>
      </listitem>
      <listitem>
        <para>
          Estimation du temps de construction&nbsp;: &qemu-time;
        </para>
      </listitem>
    </itemizedlist>

    <bridgehead renderas="sect3">Dépendances de Qemu</bridgehead>

    <bridgehead renderas="sect4">Requises</bridgehead>
    <para role="required">
      <xref linkend="glib2"/>
    </para>

    <bridgehead renderas="sect4">Recommandées</bridgehead>
    <para role="recommended">
      <xref linkend="alsa-lib"/>, <xref linkend="libslirp"/> et <xref
linkend="sdl2"/>
    </para>

    <bridgehead renderas="sect4">Facultatives</bridgehead>
    <para role="optional">
      <!-- libcacard has been a standalone project since qemu-2.5.-->
En fonction du système de son, divers paquets parmi <xref linkend="alsa"/>,
<xref linkend="python3"/>, <xref linkend="pulseaudio"/>, <xref
linkend="bluez"/>, <xref linkend="curl"/>, <xref linkend="cyrus-sasl"/>,
<xref linkend="gnutls"/>, <xref linkend="gtk2"/>, <xref linkend="gtk3"/>,
<xref linkend="libusb"/>, <xref linkend="libgcrypt"/>, <xref
linkend="libssh2"/>, <xref linkend="lzo"/>, <xref linkend="nettle"/>, <xref
linkend="mesa"/>, <xref role="nodep" linkend="vte"/> ou <xref
linkend="vte2"/> et <ulink
url="https://gitlab.freedesktop.org/spice/libcacard">libcacard</ulink>
    </para>

    <bridgehead renderas="sect4">Facultatives (à l'exécution)</bridgehead>
    <para role="runtime">
      &logind;
    </para>

    <bridgehead renderas="sect4">Facultatives (pour construire la documentation)</bridgehead>
    <para role="optional">
      <xref linkend="sphinx_rtd_theme"/>
    </para>

    <note>
      <para>
        La liste des dépendances facultatives n'est pas complète. Regardez la sortie
de <command>./configure --help</command> pour une liste plus complète.
      </para>
    </note>

    <para condition="html" role="usernotes">Notes des rédacteurs&nbsp;: <ulink url="&blfs-wiki;/qemu"/></para>

  </sect2>

  <sect2 id='qemu-prereq'>
    <title>Prérequis de KVM</title>

    <para>
      Avant de construite <application>qemu</application>, vérifier si votre
processeur supporte la technologie de virtualisation (VT)&nbsp;:
    </para>

    <screen><userinput>grep -E '^flags.*(vmx|svm)' /proc/cpuinfo</userinput></screen>

    <para>
      Si vous avez une sortie, vous avez la technologie VT (vmx pour les
processeurs Intel et svm pour les processeurs AMD). Vous devez ensuite allez
voir dans votre BIOS et vérifier qu'elle est activée. Après l'activation,
redémarrez sur votre LFS.
    </para>

  </sect2>

  <sect2 role="kernel" id='qemu-kernel'>
    <title>Configuration du noyau</title>

    <para>
      Activez les options suivantes dans la configuration du noyau et recompilez
le noyau si nécessaire&nbsp;:
    </para>

    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude"
      href="qemu-kvm-kernel.xml"/>

    <indexterm zone="qemu qemu-kernel">
      <primary sortas="d-qemu">qemu</primary>
    </indexterm>

    <para>
      Les options Intel ou AMD ne sont pas toutes les deux nécessaires, mais celle
correspondante à votre processeur est obligatoire.
    </para>

    <para>
      Pour pour utiliser les périphériques <quote>pont</quote> (bridge), comme
expliqué ci-dessous, vérifiez que <xref linkend='bridgeutils'/> est installé
et que les options suivantes dans la configuration du noyau sont
activées&nbsp;:
    </para>

    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude"
      href="qemu-bridge-kernel.xml"/>

  </sect2>

  <sect2 role="installation">
    <title>Installation de qemu</title>

    <!-- group kvm is created in lfs chapter 7 even for sysv
    <para revision="sysv">

      You will need a dedicated group that will contain users (other than root)
      allowed to access the KVM device.  Create this group by running the
      following command as the
      <systemitem class="username">root</systemitem> user:
    </para>

<screen role="root" revision="sysv"><userinput>groupadd -g 61 kvm</userinput></screen>
-->
<para>
      La règle udev de LFS ne permet que l'utilisateur &root;, les utilisateurs
qui ont une session de connexion prise en charge par la dépendance à
l'exécution facultative &logind;, ou les utilisateurs dans le groupe
<systemitem class="groupname">kvm</systemitem> à utiliser le périphérique
KVM. En tant qu'utilisateur &root;, ajoutez les utilisateurs non-&root; qui
peuvent utiliser le périphérique KVM soit sans avoir installé &logind; soit
à distance (via une connexion SSH) au groupe <systemitem
class="groupname">kvm</systemitem>&nbsp;:
    </para>

<screen role="root"><userinput>usermod -a -G kvm <replaceable>&lt;username&gt;</replaceable></userinput></screen>

    <para>
      Installez <application>qemu</application> en exécutant les commandes
suivantes&nbsp;:
    </para>

    <note>
      <para>
        Qemu est capable de faire tourner de nombreuses architectures. La procédure
de construction est aussi capable de construire les différentes cibles en
une fois à l'aide d'une liste de cibles séparées par des virgules à l'option
<option>--target-list</option>. Lancez <command>./configure --help</command>
pour avoir une liste complète des cibles possibles.
      </para>
    </note>


<screen><userinput>if [ $(uname -m) = i686 ]; then
   QEMU_ARCH=i386-softmmu
else
   QEMU_ARCH=x86_64-softmmu
fi


mkdir -vp build &amp;&amp;
cd        build &amp;&amp;

../configure --prefix=/usr               \
             --sysconfdir=/etc           \
             --localstatedir=/var        \
             --target-list=$QEMU_ARCH    \
             --audio-drv-list=alsa       \
             --disable-pa                \
             --enable-slirp              \
             --docdir=/usr/share/doc/qemu-&qemu-version; &amp;&amp;

unset QEMU_ARCH &amp;&amp;

make</userinput></screen>

    <para>
      <application>qemu</application> utilise <command>ninja</command> comme
sous-processus lors de la construction. Pour lancer les tests, lancez&nbsp;:
<command>ninja test</command>. Un test, bios-tables-test, est connu pour
échouer.
    </para>

    <para>
      Maintenant, en tant qu'utilisateur &root;&nbsp;:
    </para>

<screen role="root"><userinput>make install</userinput></screen>

    <para>
      Modifiez les permissions et le propriétaire d'un script d'aide requis
lorsque vous utilisez un périphérique <quote>pont</quote> (voir en
bas). Toujours en tant qu'utilisateur &root;, exécutez&nbsp;:
    </para>

    <note>
      <para>
        Vous devez ajouter les utilisateurs qui pourraient utiliser le périphérique
réseau <quote>bridge</quote> au groupe <systemitem
class="groupname">kvm</systemitem> même si &logind; est installé.
      </para>
    </note>

<screen role="root"><userinput>chgrp kvm  /usr/libexec/qemu-bridge-helper &amp;&amp;
chmod 4750 /usr/libexec/qemu-bridge-helper</userinput></screen>

    <note>
      <para>
        Par confort vous pouvez vouloir créer un lien symbolique pour lancer le
programme installé. Par exemple (en tant qu'utilisateur &root;)&nbsp;:
      </para>

<screen role="root"><userinput>ln -sv qemu-system-`uname -m` /usr/bin/qemu</userinput></screen>
    </note>

  </sect2>

  <sect2 role="commands">
    <title>Explication des commandes</title>

    <para>
      <parameter>--audio-drv-list=alsa --disable-pa</parameter>&nbsp;: ce
paramètre initialise le pilote audio pour ALSA. Voir plus bas pour activer
d'autres pilotes audio.
    </para>

    <para>
      <parameter>--enable-slirp</parameter>&nbsp;: ce paramètre force le système
de construction à vérifier la présence de <xref
linkend='libslirp'/>. Supprimez-le si vous n'avez pas besoin de la prise en
charge de <option>-netdev user</option>.
    </para>

    <para>
      <option>--audio-drv-list=pa --disable-alsa</option>&nbsp;: ce paramètre
initialise le pilote audio pour utiliser pulseaudio. Pour les autres pilotes
consultez les possibilités de la liste --audio-drv-list dans la sortie de
<command>configure --help</command>. Le pilote audio par défaut est
OSS. Pour activer la prise en charge simultanée d'alsa et pulseaudio,
utilisez <option>--audio-drv-list=alsa,pa</option>
    </para>

  </sect2>

  <sect2 role="using">
    <title>Utilisation de Qemu</title>

    <para>
      Comme l'utilisation de qemu signifie d'utiliser un ordinateur virtuel, les
étapes pour mettre en place la machine virtuelle sont très proches de celles
d'un vrai ordinateur. Vous devrez décider du CPU, de la mémoire, des
disques, des périphériques USB, des cartes réseau, de la taille de l'écran,
etc. Une fois que le <quote>matériel</quote> est décidé, vous devrez par
exemple choisir comment connecter la machine à internet et installer un
système d'exploitation. Dans la suite, nous montrons des façons simples
d'effectuer ces étapes. Mais qemu est bien plus que ça, et il est fortement
recommandé de lire la documentation de qemu dans
<filename>/usr/share/doc/qemu-&qemu-version;/qemu-doc.html</filename>.
    </para>

    <note>
      <para>
        Il est d'usage d'appeler l'ordinateur qui fait tourner qemu
l'<quote>hôte</quote> et la machine émulée qui tourne sous qemu
l'<quote>invitée</quote>. Nous utiliserons ces notations dans la suite.
      </para>
    </note>

    <note>
      <para>
        Les instructions suivantes supposent que vous avez créé le lien symbolique
facultatif, <filename>qemu</filename>. De plus, vous devez exécuter
<command>qemu</command> dans un environnement X. Il est tout de même
possible d'utiliser qemu en mode <quote>headless</quote> ou à travers
SSH. Consultez la documentation pour voir les différentes possibilités.
      </para>
    </note>

    <bridgehead renderas="sect3">Disk</bridgehead>
    <para>
      Un disque virtuel peut être mis en place de cette manière&nbsp;:
    </para>

<screen><userinput>VDISK_SIZE=<replaceable>50G</replaceable>
VDISK_FILENAME=<replaceable>vdisk.img</replaceable>
qemu-img create -f qcow2 $VDISK_FILENAME $VDISK_SIZE</userinput></screen>

    <para>
      Ajustez la taille du disque virtuel et le nom du fichier image comme vous le
souhaitez. La taille réelle du fichier sera plus petite que spécifiée, mais
s'agrandira quand il sera utilisé, donc une valeur élevée reste sure.
    </para>

    <bridgehead renderas="sect3">Système d'exploitation</bridgehead>
    <para>
      Pour installer un système d'exploitation, téléchargez une image ISO de votre
distribution Linux préférée. Pour les besoins de l'exemple, nous utiliserons
une distribution <filename>Fedora-16-x86_64-Live-LXDE.iso</filename> dans le
répertoire courant. Exécutez les commandes suivantes&nbsp;:
    </para>

<screen><userinput>qemu -enable-kvm                           \
     -drive file=$VDISK_FILENAME           \
     -cdrom Fedora-16-x86_64-Live-LXDE.iso \
     -boot d                               \
     -m <replaceable>1G</replaceable></userinput></screen>

    <para>
      Suivez la procédure d'installation normale pour la distribution
choisie. L'option <parameter>-boot</parameter> spécifie l'ordre de démarrage
des disques comme une chaîne de lettres de lecteur. Les lettres valides de
lecteurs sont&nbsp;: a, b (lecteur de disquettes 1 et 2), c (premier disque
dur), d (premier lecteur CD-ROM). L'option <parameter>-m</parameter> est la
quantité de mémoire à utiliser pour la machine virtuelle. Le choix dépend de
la charge de l'hôte. Les distributions modernes devraient être à l'aise avec
1 Go. L'option <parameter>-enable-kvm</parameter> permet l'accélération
matérielle. Sans ce paramètre, l'émulation est assez lente.
    </para>

    <bridgehead renderas="sect3">Définition du matériel virtuel</bridgehead>
    <para>
      Le matériel de la machine virtuelle est défini par la ligne de commande de
qemu. Par exemple&nbsp;:
    </para>

<screen><userinput>qemu -enable-kvm                     \
     -smp 4                          \
     -cpu host                       \
     -m 1G                           \
     -drive file=$VDISK_FILENAME     \
     -cdrom grub-img.iso             \
     -boot order=c,once=d,menu=on    \
     -net nic,netdev=net0            \
     -netdev user,id=net0            \
     -device ac97                    \
     -vga std                        \
     -serial mon:stdio               \
     -name "fedora-16"</userinput></screen>

    <bridgehead renderas="sect3">Signification des options de la ligne de commande</bridgehead>
    <para>
      <parameter>-enable-kvm</parameter>&nbsp;: active le support complet de la
virtualisation KVM. Sur certain matériels, il est nécessaire d'ajouter
l'option non-documentée <option>-machine smm=off</option> pour activer KVM.
    </para>

    <para>
      <parameter>-smp &lt;N&gt;</parameter>&nbsp;: active le multi-tâche
symétrique avec &lt;N&gt; processeurs.
    </para>

    <para>
      <parameter>-cpu &lt;model&gt;</parameter>&nbsp;: simule le &lt;modèle&gt; du
processeur. La liste des modèles supportés peut être obtenu avec
<option>-cpu help</option>.
    </para>

    <para>
      <parameter>-drive file=&lt;filename&gt;</parameter>&nbsp;: définie un disque
virtuel dont l'image est enregistrée dans
<filename>&lt;filename&gt;</filename>.
    </para>

    <para>
      <parameter>-cdrom grub-img.iso</parameter>&nbsp;: définit un fichier formaté
en iso à utiliser comme cdrom. Ici nous utilisons le disque de secours de
grub, qui peut être pratique lorsque quelque chose ne va pas au démarrage.
    </para>

    <para>
      <parameter>-boot order=c,once=d,menu=on</parameter>&nbsp;: définit l'ordre
de démarrage pour le BIOS virtuel.
    </para>

    <para>
      <parameter>-net nic,netdev=&lt;netid&gt;</parameter>&nbsp;: définie la carte
réseau connectée au périphérique réseau avec l'id &lt;netid&gt;.
    </para>

    <para>
      <parameter>-netdev user,id=&lt;netid&gt;</parameter>&nbsp;: définie le
périphérique <quote>utilisateur</quote> réseau. Il s'agit d'un réseau local
virtuel avec les adresses 10.0.2.0/24, où l'hôte à l'adresse 10.0.2.2 et
agit comme une passerelle vers internet, et avec un serveur de nom à
l'adresse 10.0.2.3, et un serveur smb à l'adresse 10.0.2.4. Un serveur DHCP
inclus peut allouer des adresses entre 10.0.2.15 et 10.0.2.31.
    </para>

    <para>
      <parameter>-soundhw &lt;model&gt;</parameter>&nbsp;: définie le modèle de la
carte son. La liste peut être obtenue avec <option>-soundhw help</option>.
    </para>

    <para>
      <parameter>-vga &lt;type&gt;</parameter>&nbsp;: définit le type de carte VGA
à émuler. Pour <parameter>-vga std</parameter>, si vous construisez un noyau
Linux pour l'invité, il est recommandé d'activer
<option>CONFIG_DRM_BOCHS</option> (comme partie du noyau ou en module du
noyau) pour piloter toutes les fonctionnalités de la carte VGA émulée, et
<option>CONFIG_FB</option> pour afficher une console Linux dessus. Les
autres valeurs de <option>&lt;type&gt;</option> ne sont pas testées par les
rédacteurs et peuvent nécessiter des dépendances supplémentaires.
    </para>

    <para>
      <parameter>-serial mon:stdio</parameter>&nbsp;: envoie le port série de
l'invité (<filename>/dev/ttyS0</filename> sur les invités linux), multiplexé
avec le moniteur qemu, vers l'entrée standard et la sortie du processus
qemu.
    </para>

    <para>
      <parameter>-name &lt;name&gt;</parameter>&nbsp;: définit le nom de
l'invité. Ce nom est affiché dans le titre de la fenêtre de l'invité. Il
peut être utile si vous lancez plusieurs invités en même temps.
    </para>

    <para>
      <option>-drive
if=pflash,format=raw,readonly=on,file=/usr/share/qemu/edk2-x86_64-code.fd</option>&nbsp;:
charge un micrologiciel UEFI EDK2 préconstruit, au lieu du BIOS PC par
défaut. Utilisez cette option si vous voulez démarrer le système hébergé
avec UEFI.
    </para>

    <para>
      <option>-drive file=&lt;filename&gt;,if=virtio</option>&nbsp;: fournit une
interface Virtio au noyau invité pour accéder à une image disque au lieu de
simuler un vrai disque matériel. Cela peut améliorer les performances
d'entrée-sortie du disque, mais nécessite le pilote Virtio dans le noyau
invité. Utilisez ceci au lieu de <option>-drive</option> seul si le noyau
invité prend Virtio en charge. Pour construire un noyau Linux avec la prise
en charge de Virtio pour l'invité, utilisez <command>make defconfig
&amp;&amp; make kvm_guest.config</command> pour créer une configuration de
noyau initiale avec les périphériques Virtio activés, puis appliquez vos
modifications. Ensuite, si le noyau hôte est Linux, les disques virtuels qui
utilisent l'interface Virtio seront nommés <filename>vdx</filename> dans le
devtmpfs, au lieu de <filename>sdx</filename>.
    </para>

    <para>
      <option>-net nic,netdev=net0,model=virtio-net-pci</option>&nbsp;: fournit
une interface Virtio au noyau invité pour accéder à l'interface réseau au
lieu de simuler une vrai carte matérielle. Cela peut améliorer les
performances d'entrée-sortie du réseau, mais nécessite un pilote Virtio dans
le noyau invité. Utilisez ceci au lieu de <option>-net</option> seul si le
noyau invité prend Virtio en charge.
    </para>

    <bridgehead renderas="sect3">Contrôle de l'affichage émulé</bridgehead>
    <para>
      Pour paramétrer la résolution de l'écran émulé pour un serveur Xorg qui
tourne dans le système Linux invité, consultez <xref linkend='xdisplay'/>.
    </para>

    <bridgehead renderas="sect3">Networking</bridgehead>
    <para>
      La solution pour le réseau ci-dessus permet à l'invité d'accéder au réseau
local à travers l'hôte (et éventuellement d'accéder à internet à travers des
routeurs locaux), mais l'inverse n'est pas vrai. Même l'hôte ne peut pas
accéder à l'invité, à moins que la redirection de port ne soit activée. Et
dans le cas où plusieurs invités tourneraient, ils ne peuvent pas
communiquer entre eux. D'autres périphériques réseau peuvent être utilisés
pour cela. Par exemple, le périphérique <quote>socket</quote> qui permet à
plusieurs invités de partager un réseau virtuel commun. Dans la suite, nous
décrivons plus en détails comment mettre en place le périphérique
<quote>bridge</quote> qui permet aux invités d'apparaître comme s'ils
étaient connectés au réseau local. Toutes les commandes ce-dessous devraient
être lancés en tant qu'utilisateur <systemitem
class="username">root</systemitem>.
    </para>

    <para revision="sysv">
      Initialisez le pont avec <xref linkend="bridgeutils"/>. Seules les
interfaces physiques devraient être mises en place au démarrage. Les
interfaces virtuelles seront ajoutées au besoin au démarrage de qemu.
    </para>

    <para revision="systemd">
      
      <!-- On SYS-V, IP_FORWARD is enabled by the bridge script. -->
Autorisez le système hôte à transférer les paquets IP&nbsp;:
    </para>

<screen role="root"
        revision="systemd"><userinput>sysctl -w net.ipv4.ip_forward=1</userinput></screen>

    <para revision="systemd">
      Pour rendre cela permanent, ajoutez la commande au fichier
<filename>etc/sysctl.d/60-net-forward.conf</filename>&nbsp;:
    </para>

<screen role="root"
        revision="systemd"><userinput>cat &gt;&gt; /etc/sysctl.d/60-net-forward.conf &lt;&lt; EOF
<literal>net.ipv4.ip_forward=1</literal>
EOF</userinput></screen>

    <para>
      Initialisez un fichier de configuration requis&nbsp;:
    </para>


<screen role="root"><!-- /etc/qemu has not been installed by "make install" since version 2.4 -->
<userinput>install -vdm 755 /etc/qemu &amp;&amp;
echo allow br0 &gt; /etc/qemu/bridge.conf</userinput></screen>

    <para>
      Dans la commande qemu au-dessus, remplacez l'option <parameter>-netdev
user,...</parameter> par <parameter>-netdev bridge,…</parameter>.
    </para>

  </sect2>

  <sect2 role="content">
    <title>Contenu</title>

    <segmentedlist>
      <segtitle>Programmes installés</segtitle>
      <segtitle>Bibliothèque installée</segtitle>
      <segtitle>Répertoires installés</segtitle>

      <seglistitem>
        <seg>
          elf2dmp, qemu (lien symbolique), qemu-edid, qemu-ga, qemu-img, qemu-io,
qemu-keymap, qemu-nbd, qemu-pr-helper, qemu-storage-daemon et
qemu-system-&lt;arch&gt;
        </seg>
        <seg>None</seg>
        <seg>
          /usr/share/qemu et /usr/share/doc/qemu-&qemu-version; (facultatif)
        </seg>
      </seglistitem>
    </segmentedlist>

    <variablelist>
      <bridgehead renderas="sect3">Descriptions courtes</bridgehead>
      <?dbfo list-presentation="list"?> <?dbhtml list-presentation="table"?>

      <varlistentry id="elf2dmp">
        <term><command>elf2dmp</command></term>
        <listitem>
          <para>
            Convertit les fichiers du format elf au format dmp
          </para>
          <indexterm zone="qemu elf2dmp">
            <primary sortas="b-elf2dmp">elf2dmp</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="qemu-edid">
        <term><command>qemu-edid</command></term>
        <listitem>
          <para>
            est un outil de test pour le générateur EDID de qemu
          </para>
          <indexterm zone="qemu qemu-edid">
            <primary sortas="b-qemu-edid">qemu-edid</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="qemu-ga">
        <term><command>qemu-ga</command></term>
        <listitem>
          <para>
            implémente le support pour les commandes QMP (Protocole de surveillance
QEMU) et les événements qui terminent et débutent respectivement au sein de
l'invité à l'aide d'un agent intégré dans le cadre de QEMU
          </para>
          <indexterm zone="qemu qemu-ga">
            <primary sortas="b-qemu-ga">qemu-ga</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="qemu-img">
        <term><command>qemu-img</command></term>
        <listitem>
          <para>
            fournit les commandes pour gérer les images disques QEMU
          </para>
          <indexterm zone="qemu qemu-img">
            <primary sortas="b-qemu-img">qemu-img</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="qemu-io">
        <term><command>qemu-io</command></term>
        <listitem>
          <para>
            est un programme de diagnostic et de manipulation pour les médias de mémoire
(virtuels). Il est encore à un stade de développement précoce
          </para>
          <indexterm zone="qemu qemu-io">
            <primary sortas="b-qemu-io">qemu-io</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="qemu-keymap">
        <term><command>qemu-keymap</command></term>
        <listitem>
          <para>
            génère les dispositions inverses à partir des dispositions xkb, que vous
pouvez utiliser avec l'option « -k » de qemu en ligne de commande
          </para>
          <indexterm zone="qemu qemu-keymap">
            <primary sortas="b-qemu-keymap">qemu-keymap</primary>
          </indexterm>
        </listitem>
      </varlistentry>


      <varlistentry id="qemu-nbd">
        <term><command>qemu-nbd</command></term>
        <listitem>
          <para>
            exporte les images disques Qemu en utilisant le protocole disque QEMU
"Network Block Device" (NBD)
          </para>
          <indexterm zone="qemu qemu-nbd">
            <primary sortas="b-qemu-nbd">qemu-nbd</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="qemu-pr-helper">
        <term><command>qemu-pr-helper</command></term>
        <listitem>
          <para>
            Implémente l'outil de réservation persistante pour QEMU
          </para>
          <indexterm zone="qemu qemu-pr-helper">
            <primary sortas="b-qemu-pr-helper">qemu-pr-helper</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="qemu-storage-daemon">
        <term><command>qemu-storage-daemon</command></term>
        <listitem>
          <para>
            vous permet de modifier les images disque qui avec le protocole de
surveillance de QEMU (QMP) sans lancer de VM
          </para>
          <indexterm zone="qemu qemu-storage-daemon">
            <primary sortas="b-qemu-storage-daemon">qemu-storage-daemon</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="qemu-system">
        <term><command>qemu-system-x86_64</command></term>
        <listitem>
          <para>
            est l'émulateur QEMU de système PC
          </para>
          <indexterm zone="qemu qemu-system">
            <primary sortas="b-qemu-system">qemu-system-x86_64</primary>
          </indexterm>
        </listitem>
      </varlistentry>

    </variablelist>

  </sect2>

</sect1>
