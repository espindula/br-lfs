<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../../general.ent">
  %general-entities;

  <!ENTITY qemu-download-http "https://download.qemu-project.org/qemu-&qemu-version;.tar.xz">
  <!ENTITY qemu-download-ftp  "">
  <!ENTITY qemu-md5sum        "a077669ce58b6ee07ec355e54aad25be">
  <!ENTITY qemu-size          "110&nbsp;Mo">
  <!ENTITY qemu-buildsize     "1.9&nbsp;Go">
  <!ENTITY qemu-time          "1.4 SBU (using parallelism=4; add 0.5 SBU for tests)">
]>

<sect1 id="qemu" xreflabel="qemu-&qemu-version;">
  <?dbhtml filename="qemu.html"?>

  <sect1info>
<date>$Date$</date></sect1info>

  <title>qemu-&qemu-version;</title>

  <indexterm zone="qemu">
    <primary sortas="a-qemu">qemu</primary>
  </indexterm>

  <sect2 role="package">
    <title>Introduction à qemu</title>

    <para>
      <application>qemu</application> est une solution de virtualisation complète
pour Linux avec un processeur x86 supportant les extensions de
virtualisation (Intel VT ou AMD-V).
    </para>

    &lfs110a_checked;

    <bridgehead renderas="sect3">Informations sur le paquet</bridgehead>
    <itemizedlist spacing="compact">
      <listitem>
        <para>
          Téléchargement (HTTP)&nbsp;: <ulink url="&qemu-download-http;"/>
        </para>
      </listitem>
      <listitem>
        <para>
          Téléchargement (FTP)&nbsp;: <ulink url="&qemu-download-ftp;"/>
        </para>
      </listitem>
      <listitem>
        <para>
          Somme de contrôle MD5 du téléchargement&nbsp;: &qemu-md5sum;
        </para>
      </listitem>
      <listitem>
        <para>
          Taille du téléchargement&nbsp;: &qemu-size;
        </para>
      </listitem>
      <listitem>
        <para>
          Estimation de l'espace disque requis&nbsp;: &qemu-buildsize;
        </para>
      </listitem>
      <listitem>
        <para>
          Estimation du temps de construction&nbsp;: &qemu-time;
        </para>
      </listitem>
    </itemizedlist>

    <bridgehead renderas="sect3">Dépendances de Qemu</bridgehead>

    <bridgehead renderas="sect4">Requises</bridgehead>
    <para role="required">
      <xref linkend="glib2"/> et <xref linkend="x-window-system"/>
    </para>

    <bridgehead renderas="sect4">Recommandées</bridgehead>
    <para role="recommended">
      <xref linkend="alsa-lib"/> et <xref linkend="sdl2"/>
    </para>

    <bridgehead renderas="sect4">Facultatives</bridgehead>
    <para role="optional">
      <!-- libcacard has been a standalone project since qemu-2.5.-->
En fonction du système de son, divers paquets parmi <xref linkend="alsa"/>,
<xref linkend="python3"/>, <xref linkend="pulseaudio"/>, <xref
linkend="bluez"/>, <xref linkend="curl"/>, <xref linkend="cyrus-sasl"/>,
<xref linkend="gnutls"/>, <xref linkend="gtk2"/>, <xref linkend="gtk3"/>,
<xref linkend="libusb"/>, <xref linkend="libgcrypt"/>, <xref
linkend="libssh2"/>, <xref linkend="lzo"/>, <xref linkend="nettle"/>, <xref
linkend="mesa"/>, <xref linkend="sdl"/>, <xref role="nodep" linkend="vte"/>
ou <xref linkend="vte2"/> et <ulink
url="https://gitlab.freedesktop.org/spice/libcacard">libcacard</ulink>
    </para>

    <bridgehead renderas="sect4">Dépendances facultatives pour installer la documentation</bridgehead>
    <para role="optional">
      <ulink url="https://www.sphinx-doc.org/en/master/index.html">sphinx</ulink>
avec le thème <ulink
url="https://pypi.org/project/sphinx-rtd-theme/">sphinx-rtd-theme</ulink>
    </para>

    <note>
      <para>
        La liste des dépendances facultatives n'est pas complète. Regardez la sortie
de <command>./configure --help</command> pour une liste plus complète.
      </para>
    </note>

    <para condition="html" role="usernotes">Notes utilisateur&nbsp;: <ulink url="&blfs-wiki;/qemu"/></para>

  </sect2>

  <sect2 id='qemu-prereq'>
    <title>Prérequis de KVM</title>

    <para>
      Avant de construite <application>qemu</application>, vérifier si votre
processeur supporte la technologie de virtualisation (VT)&nbsp;:
    </para>

    <screen><userinput>egrep '^flags.*(vmx|svm)' /proc/cpuinfo</userinput></screen>

    <para>
      Si vous avez une sortie, vous avez la technologie VT (vmx pour les
processeurs Intel et svm pour les processeurs AMD). Vous devez également
allez voir dans votre BIOS et vérifier qu'elle est activée. Après
l'activation, redémarrez sur votre LFS.
    </para>

  </sect2>

  <sect2 role="kernel" id='qemu-kernel'>
    <title>Configuration du noyau</title>

    <para>
      Activez les options suivantes dans la configuration du noyau et recompilez
le noyau si nécessaire&nbsp;:
    </para>

<screen><literal>[*] Virtualization:  ---&gt;                                             [CONFIG_VIRTUALIZATION]
  &lt;*/M&gt;   Kernel-based Virtual Machine (KVM) support [CONFIG_KVM]
  &lt;*/M&gt;     KVM for Intel (and compatible) processors support         [CONFIG_KVM_INTEL]
  &lt;*/M&gt;     KVM for AMD processors support                            [CONFIG_KVM_AMD]</literal></screen>

    <indexterm zone="qemu qemu-kernel">
      <primary sortas="d-qemu">qemu</primary>
    </indexterm>

    <para>
      Les options Intel ou AMD ne sont pas toutes les deux nécessaires, mais celle
correspondante à votre processeur est obligatoire.
    </para>

    <para>
      Pour pour utiliser les périphériques <quote>pont</quote> (bridge), comme
expliqué ci-dessous, vérifiez que <xref linkend='bridgeutils'/> est installé
et que les options suivantes dans la configuration du noyau sont
activées&nbsp;:
    </para>

<screen><literal>[*] Networking support  ---&gt;                         [CONFIG_NET]
  Networking options  ---&gt;
    &lt;*/M&gt; 802.1d Ethernet Bridging                   [CONFIG_BRIDGE]
Device Drivers  ---&gt;
  [*] Network device support  ---&gt;                   [CONFIG_NETDEVICES]
    &lt;*/M&gt;    Universal TUN/TAP device driver support [CONFIG_TUN]</literal></screen>

  </sect2>

  <sect2 role="installation">
    <title>Installation de qemu</title>

    <para revision="sysv">
      Vous aurez besoin d'un groupe dédié qui contient les utilisateurs (autre que
root) autorisé à accéder au périphérique KVM. Créez ce groupe en lançant la
commande suivante en tant qu'utilisateur <systemitem
class="username">root</systemitem>&nbsp;:
    </para>

<screen role="root" revision="sysv"><userinput>groupadd -g 61 kvm</userinput></screen>

    <para>
      Ajoutez tous les utilisateurs qui peuvent utiliser le périphérique KVM dans
ce groupe&nbsp;:
    </para>

<screen role="root"><userinput>usermod -a -G kvm <replaceable>&lt;username&gt;</replaceable></userinput></screen>

    <para>
      Installez <application>qemu</application> en lançant les commandes
suivantes&nbsp;:
    </para>

    <note>
      <para>
        Qemu est capable de faire tourner de nombreuses architectures. La procédure
de construction est aussi capable de construire les différentes cibles en
une fois à l'aide d'une liste de cibles séparées par des virgules à l'option
<option>--target-list</option>. Lancez <command>./configure --help</command>
pour avoir une liste complète des cibles possibles.
      </para>
    </note>


<screen><userinput>if [ $(uname -m) = i686 ]; then
   QEMU_ARCH=i386-softmmu
else
   QEMU_ARCH=x86_64-softmmu
fi


mkdir -vp build &amp;&amp;
cd        build &amp;&amp;

../configure --prefix=/usr               \
             --sysconfdir=/etc           \
             --localstatedir=/var        \
             --target-list=$QEMU_ARCH    \
             --audio-drv-list=alsa       \
             --docdir=/usr/share/doc/qemu-&qemu-version; &amp;&amp;

unset QEMU_ARCH &amp;&amp;

make</userinput></screen>

    <para>
      <application>qemu</application> utilise <command>ninja</command> comme
sous-processus lors de la construction. Pour lancer les tests, lancez&nbsp;:
<command>ninja test</command>.
    </para>

    <para>
      Maintenant, en tant qu'utilisateur <systemitem
class="username">root</systemitem>&nbsp;:
    </para>

<screen role="root"><userinput>make install</userinput></screen>

    <para>
      Vous pouvez aussi avoir besoin d'ajouter une règle Udev pour que le
périphérique KVM ait les bonnes permissions&nbsp;:
    </para>

<screen role="root"><userinput>cat > /lib/udev/rules.d/65-kvm.rules &lt;&lt; "EOF"
<literal>KERNEL=="kvm", GROUP="kvm", MODE="0660"</literal>
EOF</userinput></screen>

    <para>
      Modifiez les permissions et le propriétaire d'un script d'aide, qui est
requis lorsque vous utilisez un périphérique <quote>pont</quote> (voir en
bas)&nbsp;:
    </para>

<screen role="root"><userinput>chgrp kvm  /usr/libexec/qemu-bridge-helper &amp;&amp;
chmod 4750 /usr/libexec/qemu-bridge-helper</userinput></screen>

    <note>
      <para>
        Par confort vous pouvez vouloir créer un lien symbolique pour lancer le
programme installé. Par exemple&nbsp;:
      </para>

<screen role="root"><userinput>ln -sv qemu-system-`uname -m` /usr/bin/qemu</userinput></screen>
    </note>

  </sect2>

  <sect2 role="commands">
    <title>Explication des commandes</title>


    <!-- Not used anymore
    <para>

      <command>sed ... util/memfd.c</command>: This command fixes a conflict
      introduced with glibc-2.27.
    </para>
-->
<para>
      <parameter>--audio-drv-list=alsa</parameter>&nbsp;: Ce paramètre initialise
le pilote audio pour ALSA. Voir plus bas pour activer d'autres pilotes
audio.
    </para>

    <para>
      <option>--audio-drv-list=pa</option>&nbsp;: Ce paramètre initialise le
pilote audio pour pulseaudio. Pour les autres pilotes regardez la liste
--audio-drv-list dans la sortie de l'aide de
<command>configure</command>. Le pilote audio par défaut est OSS. Pour
activer le support pour alsa et pulseaudio, utilisez
<option>--audio-drv-list=alsa,pa</option>
    </para>

    

  <!-- this appears to be rejected in 4.1.0
         ERROR: unknown option \-\-with-gtkabi=3.0
    <para>

      <option>\-\-with-gtkabi=3.0</option>: builds with GTK+-3 if both GTK+-2
      and GTK+-3 are installed.
    </para> -->
</sect2>

  <sect2 role="using">
    <title>Utilisation de Qemu</title>

    <para>
      Comme l'utilisation de qemu signifie d'utiliser un ordinateur virtuel, les
étapes pour mettre en place la machine virtuelle sont très proches de celles
d'un vrai ordinateur. Vous devrez décider du CPU, de la mémoire, des
disques, des périphériques USB, des cartes réseau, de la taille de l'écran,
etc. Une fois que le <quote>matériel</quote> est décidé, vous devrez par
exemple choisir comment connecter la machine à internet et installer un
système d'exploitation. Dans la suite, nous montrons des façons simples
d'effectuer ces étapes. Mais qemu est bien plus que ça, et il est fortement
recommandé de lire la documentation de qemu dans
<filename>/usr/share/doc/qemu-&qemu-version;/qemu-doc.html</filename>.
    </para>

    <note>
      <para>
        Il est d'usage d'appeler l'ordinateur qui fait tourner qemu
l'<quote>hôte</quote> et la machine émulée qui tourne sous qemu
l'<quote>invitée</quote>. Nous utiliserons ces notations dans la suite.
      </para>
    </note>

    <note>
      <para>
        Les instructions suivantes supposent que vous avez créé le lien symbolique
facultatif, <filename>qemu</filename>. De plus, vous devez exécuter
<command>qemu</command> depuis un terminal dans une fenêtre X (soit
localement, soit à travers ssh).
      </para>
    </note>

    <bridgehead renderas="sect3">Disk</bridgehead>
    <para>
      Un disque virtuel peut être mis en place de cette manière&nbsp;:
    </para>

<screen><userinput>VDISK_SIZE=<replaceable>50G</replaceable>
VDISK_FILENAME=<replaceable>vdisk.img</replaceable>
qemu-img create -f qcow2 $VDISK_FILENAME $VDISK_SIZE</userinput></screen>

    <para>
      Ajustez la taille du disque virtuel et le nom du fichier image comme vous le
souhaitez. La taille réelle du fichier sera plus petite que spécifiée, mais
s'agrandira quand il sera utilisé, donc une valeur élevée reste sure.
    </para>

    <bridgehead renderas="sect3">Système d'exploitation</bridgehead>
    <para>
      Pour installer un système d'exploitation, téléchargez une image ISO de votre
distribution Linux préférée. Pour les besoins de l'exemple, nous utiliserons
une distribution <filename>Fedora-16-x86_64-Live-LXDE.iso</filename> dans le
répertoire courant. Exécutez les commandes suivantes&nbsp;:
    </para>

<screen><userinput>qemu -enable-kvm                           \
     -drive file=$VDISK_FILENAME           \
     -cdrom Fedora-16-x86_64-Live-LXDE.iso \
     -boot d                               \
     -m <replaceable>1G</replaceable></userinput></screen>

    <para>
      Suivez la procédure d'installation normale pour la distribution
choisie. L'option <parameter>-boot</parameter> spécifie l'ordre de démarrage
des disques comme une chaîne de lettres de lecteur. Les lettres valides de
lecteurs sont&nbsp;: a, b (lecteur de disquettes 1 et 2), c (premier disque
dur), d (premier lecteur CD-ROM). L'option <parameter>-m</parameter> est la
quantité de mémoire à utiliser pour la machine virtuelle. Le choix dépend de
la charge de l'hôte. Les distributions modernes devraient être à l'aise avec
1 Go. L'option <parameter>-enable-kvm</parameter> permet l'accélération
matérielle. Sans ce paramètre, l'émulation est assez lente.
    </para>

    <bridgehead renderas="sect3">Définition du matériel virtuel</bridgehead>
    <para>
      Le matériel de la machine virtuelle est défini par la ligne de commande de
qemu. Par exemple&nbsp;:
    </para>

<screen><userinput>qemu -enable-kvm                     \
     -smp 4                          \
     -cpu host                       \
     -m 1G                           \
     -drive file=$VDISK_FILENAME     \
     -cdrom grub-img.iso             \
     -boot order=c,once=d,menu=on    \
     -net nic,netdev=net0            \
     -netdev user,id=net0            \
     -device ac97                    \
     -vga std                        \
     -serial mon:stdio               \
     -name "fedora-16"</userinput></screen>

    <bridgehead renderas="sect3">Signification des options de la ligne de commande</bridgehead>
    <para>
      <parameter>-enable-kvm</parameter>&nbsp;: active le support complet de la
virtualisation KVM. Sur certain matériels, il est nécessaire d'ajouter
l'option non-documentée <option>-machine smm=off</option> pour activer KVM.
    </para>

    <para>
      <parameter>-smp &lt;N&gt;</parameter>&nbsp;: active le multi-tâche
symétrique avec &lt;N&gt; processeurs.
    </para>

    <para>
      <parameter>-cpu &lt;model&gt;</parameter>&nbsp;: simule le &lt;modèle&gt; du
processeur. La liste des modèles supportés peut être obtenu avec
<option>-cpu help</option>.
    </para>

    <para>
      <parameter>-drive file=&lt;filename&gt;</parameter>&nbsp;: définie un disque
virtuel dont l'image est enregistrée dans
<filename>&lt;filename&gt;</filename>.
    </para>

    <para>
      <parameter>-cdrom grub-img.iso</parameter>&nbsp;: définit un fichier formaté
en iso pour l'utiliser comme cdrom. Ici nous utilisons le disque de secours
de grub, qui peut être pratique lorsque quelque chose ne va pas au
démarrage.
    </para>

    <para>
      <parameter>-boot order=c,once=d,menu=on</parameter>&nbsp;: définit l'ordre
de démarrage pour le BIOS virtuel.
    </para>

    <para>
      <parameter>-net nic,netdev=&lt;netid&gt;</parameter>&nbsp;: définie la carte
réseau connectée au périphérique réseau avec l'id &lt;netid&gt;.
    </para>

    <para>
      <parameter>-netdev user,id=&lt;netid&gt;</parameter>&nbsp;: définie le
périphérique <quote>utilisateur</quote> réseau. Il s'agit d'un réseau local
virtuel avec les adresses 10.0.2.0/24, où l'hôte à l'adresse 10.0.2.2 et
agit comme une passerelle vers internet, et avec un serveur de nom à
l'adresse 10.0.2.3, et un serveur smb à l'adresse 10.0.2.4. Un serveur DHCP
inclus peut allouer des adresses entre 10.0.2.15 et 10.0.2.31.
    </para>

    <para>
      <parameter>-soundhw &lt;model&gt;</parameter>&nbsp;: définie le modèle de la
carte son. La liste peut être obtenue avec <option>-soundhw help</option>.
    </para>

    <para>
      <parameter>-vga &lt;type&gt;</parameter>&nbsp;: définie le type de carte vga
à émuler.
    </para>

    <para>
      <parameter>-serial mon:stdio</parameter>&nbsp;: envoie le port série de
l'invité (<filename>/dev/ttyS0</filename> sur les invités linux), multiplexé
avec le moniteur qemu, vers l'entrée standard et la sortie du processus
qemu.
    </para>

    <para>
      <parameter>-name &lt;name&gt;</parameter>&nbsp;: définit le nom de
l'invité. Ce nom est affiché dans le titre de la fenêtre de l'invité. Il
peut être utile si vous lancez plusieurs invités en même temps.
    </para>

    <bridgehead renderas="sect3">Contrôle de l'affichage émulé</bridgehead>
    <para>
      Il peut arriver que la fenêtre de l'invité affichée par qemu ne corresponde
pas à la plein capacité de la carte vga émulée. Par exemple la carte vmware
est capable d'afficher en 1600x900 mais ne s'affiche qu'en 1024x768 par
défaut. Une configuration appropriée de Xorg sur l'invité permet d'utiliser
la taille maximale (remarquez que le pilote vidéo Xorg à utiliser est <xref
linkend="xorg-vmware-driver"/>)&nbsp;:
    </para>

<screen role="root"><userinput>cat &gt; /usr/share/X11/xorg.conf.d/20-vmware.conf &lt;&lt; "EOF"
<literal>Section         "Monitor"
  Identifier    "Monitor0"
  # cvt 1600 900
  # 1600x900 59.95 Hz (CVT 1.44M9) hsync: 55.99 kHz; pclk: 118.25 MHz
  Modeline      "1600x900"  118.25  1600 1696 1856 2112  900 903 908 934 -hsync +vsync
  Option        "PreferredMode" "1600x900"
  HorizSync     1-200
  VertRefresh   1-200
EndSection

Section         "Device"
  Identifier    "VMware SVGA II Adapter"
  Option        "Monitor" "default"
  Driver        "vmware"
EndSection

Section         "Screen"
  Identifier    "Default Screen"
  Device        "VMware SVGA II Adapter"
  Monitor       "Monitor0"

  SubSection    "Display"
    Depth       24
    Modes       "1600x900" "1440x900" "1366x768" "1280x720" "800x480"
  EndSubSection

EndSection</literal>
EOF</userinput></screen>

    <para>
      Des tailles supplémentaires seront disponibles en plus des tailles
natives. Vous devrez redémarrer X pour rendre ces nouvelles tailles
disponibles.
    </para>

    <bridgehead renderas="sect3">Networking</bridgehead>
    <para>
      La solution pour le réseau ci-dessus permet à l'invité d'accéder au réseau
local à travers l'hôte (et éventuellement d'accéder à internet à travers des
routeurs locaux), mais l'inverse n'est pas vrai. Pas même l'hôte ne peut
accéder à l'invité, à moins que la redirection de port ne soit activée. Et
dans le cas où plusieurs invités tourneraient, ils ne peuvent pas
communiquer entre eux. D'autres périphériques réseau peuvent être utilisés
pour cela. Par exemple, le périphérique <quote>socket</quote> qui permet à
plusieurs invités de partager un réseau virtuel commun. Dans la suite, nous
décrivons plus en détails comment mettre en place le périphérique
<quote>bridge</quote> qui permet aux invités d'apparaître comme s'ils
étaient connectés au réseau local. Toutes les commandes ce-dessous devraient
être lancés en tant qu'utilisateur <systemitem
class="username">root</systemitem>.
    </para>

    <para revision="sysv">
      Initialisez le pont avec <xref linkend="bridgeutils"/>. Seules les
interfaces physiques devraient être mises en place au démarrage. Les
interfaces virtuelles seront ajoutées au besoin au démarrage de qemu.
    </para>

    <para revision="systemd">
      
      <!-- On SYS-V, IP_FORWARD is enabled by the bridge script. -->
Autorisez le système hôte à transférer les paquets IP&nbsp;:
    </para>

<screen role="root"
        revision="systemd"><userinput>sysctl -w net.ipv4.ip_forward=1</userinput></screen>

    <para revision="systemd">
      Pour rendre cela permanent, ajoutez la commande au fichier
<filename>etc/sysctl.d/60-net-forward.conf</filename>&nbsp;:
    </para>

<screen role="root"
        revision="systemd"><userinput>cat &gt;&gt; /etc/sysctl.d/60-net-forward.conf &lt;&lt; EOF
<literal>net.ipv4.ip_forward=1</literal>
EOF</userinput></screen>

    <para>
      Initialisez un fichier de configuration requis&nbsp;:
    </para>


<screen role="root"><!-- /etc/qemu has not been installed by "make install" since version 2.4 -->
<userinput>install -vdm 755 /etc/qemu &amp;&amp;
echo allow br0 &gt; /etc/qemu/bridge.conf</userinput></screen>

    <para>
      Dans la commande au-dessus, remplacez l'option <parameter>-netdev
user,...</parameter> par <parameter>-netdev bridge,id=net0</parameter>.
    </para>

  </sect2>

  <sect2 role="content">
    <title>Contenu</title>

    <segmentedlist>
      <segtitle>Programmes installés</segtitle>
      <segtitle>Bibliothèque installée</segtitle>
      <segtitle>Répertoires installés</segtitle>

      <seglistitem>
        <seg>
          elf2dmp, qemu (lien symbolique), qemu-edid, qemu-ga, qemu-img, qemu-io,
qemu-keymap, qemu-nbd, qemu-pr-helper, qemu-storage-daemon et
qemu-system-&lt;arch&gt;
        </seg>
        <seg>None</seg>
        <seg>
          /usr/share/qemu et /usr/share/doc/qemu-&qemu-version; (facultatif)
        </seg>
      </seglistitem>
    </segmentedlist>

    <variablelist>
      <bridgehead renderas="sect3">Descriptions courtes</bridgehead>
      <?dbfo list-presentation="list"?>
      <?dbhtml list-presentation="table"?>

      <varlistentry id="elf2dmp">
        <term><command>elf2dmp</command></term>
        <listitem>
          <para>
            Convertit les fichiers du format elf au format dmp
          </para>
          <indexterm zone="qemu elf2dmp">
            <primary sortas="b-elf2dmp">elf2dmp</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <!--
      <varlistentry id="ivshmem-client">

        <term><command>ivshmem-client</command></term>
        <listitem>
          <para>
            is a standalone client for using the ivshmem device
          </para>
          <indexterm zone="qemu ivshmem-client">
            <primary sortas="b-ivshmem-client">ivshmem-client</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="ivshmem-server">
        <term><command>ivshmem-server</command></term>
        <listitem>
          <para>
            is an example server for the ivshmem device
          </para>
          <indexterm zone="qemu ivshmem-server">
            <primary sortas="b-ivshmem-server">ivshmem-server</primary>
          </indexterm>
        </listitem>
      </varlistentry>
-->
<varlistentry id="qemu-edid">
        <term><command>qemu-edid</command></term>
        <listitem>
          <para>
            est un outil de test pour le générateur EDID de qemu
          </para>
          <indexterm zone="qemu qemu-edid">
            <primary sortas="b-qemu-edid">qemu-edid</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="qemu-ga">
        <term><command>qemu-ga</command></term>
        <listitem>
          <para>
            implémente le support pour les commandes QMP (Protocole de surveillance
QEMU) et les événements qui terminent et débutent respectivement au sein de
l'invité à l'aide d'un agent intégré dans le cadre de QEMU
          </para>
          <indexterm zone="qemu qemu-ga">
            <primary sortas="b-qemu-ga">qemu-ga</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="qemu-img">
        <term><command>qemu-img</command></term>
        <listitem>
          <para>
            fournit les commandes pour gérer les images disques QEMU
          </para>
          <indexterm zone="qemu qemu-img">
            <primary sortas="b-qemu-img">qemu-img</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="qemu-io">
        <term><command>qemu-io</command></term>
        <listitem>
          <para>
            est un programme de diagnostic et de manipulation pour les médias de mémoire
(virtuels). Il est encore à un stade de développement précoce
          </para>
          <indexterm zone="qemu qemu-io">
            <primary sortas="b-qemu-io">qemu-io</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="qemu-keymap">
        <term><command>qemu-keymap</command></term>
        <listitem>
          <para>
            génère les dispositions inverses à partir des dispositions xkb, que vous
pouvez utiliser avec l'option « -k » de qemu en ligne de commande
          </para>
          <indexterm zone="qemu qemu-keymap">
            <primary sortas="b-qemu-keymap">qemu-keymap</primary>
          </indexterm>
        </listitem>
      </varlistentry>


      <varlistentry id="qemu-nbd">
        <term><command>qemu-nbd</command></term>
        <listitem>
          <para>
            exporte les images disques Qemu en utilisant le protocole disque QEMU
"Network Block Device" (NBD)
          </para>
          <indexterm zone="qemu qemu-nbd">
            <primary sortas="b-qemu-nbd">qemu-nbd</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="qemu-pr-helper">
        <term><command>qemu-pr-helper</command></term>
        <listitem>
          <para>
            Implémente l'outil de réservation persistante pour QEMU
          </para>
          <indexterm zone="qemu qemu-pr-helper">
            <primary sortas="b-qemu-pr-helper">qemu-pr-helper</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="qemu-storage-daemon">
        <term><command>qemu-storage-daemon</command></term>
        <listitem>
          <para>
            vous permet de modifier les images disque qui avec le protocole de
surveillance de QEMU (QMP) sans lancer de VM
          </para>
          <indexterm zone="qemu qemu-storage-daemon">
            <primary sortas="b-qemu-storage-daemon">qemu-storage-daemon</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="qemu-system">
        <term><command>qemu-system-x86_64</command></term>
        <listitem>
          <para>
            est l'émulateur QEMU de système PC
          </para>
          <indexterm zone="qemu qemu-system">
            <primary sortas="b-qemu-system">qemu-system-x86_64</primary>
          </indexterm>
        </listitem>
      </varlistentry>
<!--
      <varlistentry id="virtfs-proxy-helper">

        <term><command>virtfs-proxy-helper</command></term>
        <listitem>
          <para>
            creates a socket pair or a named socket. QEMU and the proxy helper
            communicate using this socket. The QEMU proxy fs driver sends
            filesystem requests to the proxy helper and receives the response
            from it
          </para>
          <indexterm zone="qemu virtfs-proxy-helper">
            <primary sortas="b-virtfs-proxy-helper">virtfs-proxy-helper</primary>
          </indexterm>
        </listitem>
      </varlistentry>
-->

    </variablelist>

  </sect2>

</sect1>
