<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../../general.ent">
  %general-entities;
]>

<sect1 id="postlfs-firmware" xreflabel="À propos des Firmwares">
  <?dbhtml filename="firmware.html"?>


  <title>À propos des Firmwares</title>

  <indexterm zone="postlfs-firmware">
    <primary sortas="e-lib-firmware">/lib/firmware</primary>
  </indexterm>

  <para>
    Sur certains PCs actuels il peut être nécessaire, ou désirable, de charger
des firmwares pour faire travailler les PC au maximum de leurs
possibilités. Le noyau contient un répertoire, <filename
class="directory">/lib/firmware</filename>, ou le noyau ou les pilotes du
noyau cherche des images de firmware.
  </para>

  <para>
    Actuellement, on peut trouver la plupart des firmwares sur un dépôt
<userinput>git</userinput>&nbsp;: <ulink url=
"https://git.kernel.org/cgit/linux/kernel/git/firmware/linux-firmware.git/tree/"/>.
Par commodité, le projet LFS a créé un miroir, mis à jour quotidiennement,
où on peut accéder à ces fichiers de firmwares via
<userinput>wget</userinput> ou un navigateur web sur <ulink
url="&sources-anduin-http;/linux-firmware/"/>.
  </para>

  <para>
    Pour récupérer le microprogramme, vous devez soit aller sur un des dépôts
ci-dessus avec un navigateur pour télécharger les fichiers dont vous avez
besoin, soit installer <xref linkend="git"/> et cloner ce dépôt.
  </para>

  <para>
    Pour certains autres firmwares, particulièrement pour les micro-codes
d'Intel, et certains périphériques wi-fi, le firmware recherché n'est pas
disponible dans le dépôt précédent. Certains d'entre eux seront ajouté
ensuite, mais il est parfois nécessaire de faire une recherche sur internet
pour les firmwares souhaités.
  </para>

  <para>
    Les fichiers firmwares sont par convention référencés comme des blobs car
vous ne pouvez pas déterminer ce qu'ils font. Notez que ces firmwares sont
distribués sous des licences différentes et variées qui ne permettent pas le
désassemblage ou la retro ingénierie.
  </para>

  <para>
    Les firmwares pour PC tombent dans 4 catégories&nbsp;:
  </para>

  <itemizedlist spacing="compact">
    <listitem>
      <para>
        Les firmwares mettant à jour le processeur pour travailler correctement,
couramment appelé micro-code.
      </para>
    </listitem>
    <listitem>
      <para>
        Microprogramme pour les contrôleurs vidéo. Sur les machines x86 ils sont
requis pour les périphériques ATI (puces Radeon et AMDGPU) et peuvent être
utiles pour les GPU Intel (Skylake et ultérieur) et Nvidia (Kepler et
ultérieurs).
      </para>

      <para>
        Les périphériques ATI Radeom et AMDGPU demandent des microprogrammes pour
pouvoir utiliser le KMS (kernel modesetting &mdash; l'option préférée) ainsi
que Xorg. Pour les anciennes puces radeon (avant R600), le microprogramme
est toujours dans les sources du noyau.
      </para>

      <para>
        Les GPU intégrés d'Intel de Skylake et supérieur peuvent utiliser le
microprogramme pour GuC (the microcontrôleur graphique), et le le HuC (le
microcontrôleur HEVC/H265 qui décharge vers le GPU) et DMC (microcontrôleur
pour l'affichage) pour fournir des états à basse consommation
supplémentaires. Le GuC et HuC ont un historique mouvementé dans le noyau et
les microprogrammes à jour peuvent être désactivés par défaut, en fonction
de la version de votre noyau. Des détails supplémentaires se trouvent sur
<ulink url="https://01.org/linuxgraphics/downloads/firmware/">01.org</ulink>
et <ulink url="https://wiki.archlinux.org/index.php/intel_graphics">Arch
linux</ulink>.
      </para>

      <para>
        Les GPU Nvidia à partir de Kepler ont besoin d'un microprogramme signé,
sinon le pilote nouveau est incapable de fournir l'accélération
matérielle. Nvidia a maintenant fourni des microprogrammes jusqu'à Ampere
(la séie GeForce30) dans linux-firmware. Remarquez que les horloges plus
rapides que par défaut ne sont pas activées dans le microprogramme publié.
      </para>
    </listitem>
    <listitem>
      <para>
        Mises à jour des firmware pour les interfaces réseaux filaires. La plupart
fonctionnent sans mise à jour, mais elles fonctionneront sans doute mieux
avec un firmware à jour. Pour certains ordinateurs portables récentes, les
firmware pour le port ethernet (p. ex. rtl_nic) mais aussi pour les
périphériques bluetooth (p. ex. qca) sont <emphasis>requis</emphasis> avant
de pouvoir utiliser les réseau filaire.
      </para>
    </listitem>
    <listitem>
      <para>
        Les Firmwares pour les autres périphériques, comme le réseau sans fil. Ces
périphériques ne sont pas requis pour que le PC démarre, mais demande un
firmware avant que ces périphériques puissent être utilisés.
      </para>
    </listitem>
  </itemizedlist>

  <note>
    <para>
      Bien qu’ils soient inutiles pour charger un firmware fermé (blob), les
outils suivants peuvent être utiles pour déterminer, obtenir, ou préparer le
firmware à utiliser afin de le charger dans le système&nbsp;: <xref
linkend="cpio"/>, <xref linkend="git"/>, <xref linkend="pciutils"/> et <xref
linkend="wget"/>
    </para>
  </note>


  <sect2 id="cpu-microcode">
    <title>Mise à jour de micro-codes pour les CPU</title>

    <para>
      En général, le micro-code peut être chargé par le BIOS ou l'UEFI, et il peut
être mis à jour en passant à une nouvelle version de celui-ci. Sur Linux,
vous pouvez également charger le micro-code depuis le noyau si vous utilisez
au moins un AMD de la famille 10h ou un plus récent (introduit après fin
2007), ou un processeur Intel de 1998 et plus (Pentium4, Core, etc), si un
micro-code mis à jour a été publié. Ces mises à jour sont actives seulement
jusqu'à ce que la machine soit éteinte, il est donc nécessaire de les
appliquer à chaque démarrage.
    </para>

    <para>
      Intel fournit des mises à jour de leur microcode pour les versions Skylake
et ultérieures de leurs processeurs quand de nouvelles vulnérabilités sont
découvertes, et l'ont fait pour les processeurs SandyBridge et ultérieurs
par le passé, bien qu'ils ne soient plus pris en charge pour les nouvelles
corrections. Les nouvelles versions de microprogramme d'AMD sont rares et ne
s'appliquent qu'à quelques modèles, bien que les fabricants de carte mères
obtiennent des mises à jour AGESA (AMD Generic Encapsulated Software
Architecture) pour changer les valeurs du BIOS, par exemple pour prendre en
charge plus de variantes de mémoire, de nouvelles vulnérabilités ou de
nouveaux CPU.
    </para>

    <para>
      Il y avait deux façons de charger le microcode, décrites comme «&nbsp;au
plus tôt&nbsp;» et «&nbsp;au plus tard&nbsp;». Le chargement «&nbsp;au plus
tôt&nbsp;» arrive avant que l'espace utilisateur ne démarre, le chargement
«&nbsp;au plus tard&nbsp;» arrive quand l'espace utilisateur est
démarré. Cependant, le chargement au plus tard est problématique et n'est
plus pris en charge (voir l commit du noyau noté <ulink
url="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=d23d33e">x86/microcode:
Taint and warn on late loading</ulink>). En effet, il est nécessaire de
contourner une erreur particulière dans les premiers processeurs Intel
Haswell qui ont le TSX d'activé. (Voir <ulink url=
"https://www.anandtech.com/show/8376/intel-disables-tsx-instructions-erratum-found-in-haswell-haswelleep-broadwelly/">Intel
Disables TSX Instructions: Erratum Found in Haswell, Haswell-E/EP,
Broadwell-Y</ulink>). Sans cette mise à jour glibc peut produire des erreurs
dans des situations particulières.
    </para>

    <para>
      Dans les versions précédentes de ce livre, nous recommandions le chargement
au plus tard pour voir s'il était appliqué, suivi par l'utilisation d'un
initrd pour forcer le chargement au plus tôt. Mais maintenant que le contenu
de l'archive de microcode Intel est documenté, et que le microcode AMD peut
être lu par un script Python pour déterminer les machines qu'il couvre, il
n'y a plus de raison d'utiliser le chargement au plus tard.
    </para>

    <para>
      Il reste peut-être possible de manuellement forcer le chargement «&nbsp;au
plus tard&nbsp;» du microcode, mais cela pourrait occasionner une
malfonction du noyau et vous devez être conscient·e du risque. Vous devrez
reconfigurer votre noyau pour l'une ou l'autre méthode. Les instructions ici
montrent comment créer un initrd pour un chargement «&nbsp;au plus
tôt&nbsp;». Il est aussi possible d'intégrer le même fichier binaire de
microcode dans le noyau, ce qui permet le chargement au plus tôt mais
nécessite de recompiler le noyau pour mettre à jour le microcode.
    </para>

    <para>
      Pour déterminer l'identité de votre processeur (s'il y en a plus d'un, ils
seront identiques) regardez dans /proc/cpuinfo. Déterminez les valeurs
décimales de la famille du processeur, le modèle, et le pas en exécutant la
commande suivante (elle rapportera aussi la version actuelle du
micro-code)&nbsp;:
    </para>

<screen><userinput>head -n7 /proc/cpuinfo</userinput></screen>

    <para>
      Convertissez la famille, le modèle et le pas du processeur en paires de
nombre hexadécimaux et rappelez-vous la valeur du champ
<quote>microcode</quote>. Vous pouvez maintenant vérifier si un microcode
est disponible.
    </para>

    <para>
      Si vous créez un initrd pour mettre à jour le microcode de différentes
machines, comme le ferait une distro, regardez «&nbsp;Chargement du
microcode au plus tôt&nbsp;» et concaténez tous les blobs Intel dans
GenuineIntel.bin ou tous ceux de AMD dans AUthenticAMD.bin. Cela crée un
initrd plus gros — pour toutes les machines Intel dans la mise à jour
20200609 la taille est de 3,0&nbsp;Mo par rapport à 24 Ko pour une seule
machine.
    </para>

    <sect3 id="intel-microcode">
      <title>Micro-code Intel pour le processeur</title>

      <para>
        <!-- at one time, some skylakes had problems with a certain revision
        secure version of the microcode, for those machines which can boot it, -->
La première étape consiste à obtenir la version la plus récente du microcode
d'Intel. Vous devez pour cela aller sur <ulink url=
'https://github.com/intel/Intel-Linux-Processor-Microcode-Data-Files/releases/'/>
et télécharger le fichier le plus récent. Au moment de l'écriture de ces
lignes la version la plus sure du micro-code est
microcode-20230808. Extrayez ce fichier normalement, le microcode se trouve
dans le répertoire <filename>intel-ucode</filename> qui contient les divers
blobs avec des noms de la forme XX-YY-ZZ. Il y a aussi d'autres fichiers
divers et un fichier releasenote.
      </para>

      <para>
        Par le passé, Intel ne fournissait aucun détails sur les blobs dont la
version changeait, mais maintenant les releasenote en parlent. Vous pouvez
comparer la version du microcode dans <filename>/proc/cpuinfo</filename>
avec la version pour votre modèle de CPU dans les releasenote pour savoir
s'il y a une mise à jour.
      </para>

      <para>
        Le firmware récent pour les processeurs les plus anciens est fournit pour
traiter des vulnérabilités qui ont été rendue publiques, et pour certains
d'entre eux comme le <foreignphrase>Microarchitectural Data
Sampling</foreignphrase> (MDS) vous pourriez vouloir augmenter la protection
en désactivant l'hyperthreading ou en désactivant les contournements par
défaut du noyau à cause de son impact sur les temps de compilation. Lisez
bien la documentation en ligne sur <ulink url=
'https://www.kernel.org/doc/html/latest/admin-guide/hw-vuln/index.html'/>.
      </para>

      <para>
        Pour un mobile Tigerlake (décrit comme Intel(R) Core(TM) i5-1300H CPU) les
valeurs utiles sont famille CPU 6, modèle 140, pas 1, donc dans ce cas
l'identifiant requis est 06-8c-01. Les releasenote disent que le dernier
microcode pour ce CPU est la version 0xac. Si la valeur du champ
<quote>microcode</quote> dans <filename>/proc/cpuinfo</filename> est 0xac ou
plus, cela signifie que la mise à jour du microcode est déjà appliquée par
le BIOS. Sinon, configurez le noyau pour prendre en charge le chargement du
microcode Intel puis consultez <xref linkend='early-microcode'/>.
      </para>

      <xi:include xmlns:xi="http://www.w3.org/2001/XInclude"
        href="intel-ucode-kernel.xml"/>

    </sect3>

    <sect3 id="amd-microcode">
      <title>Micro-code AMD pour le processeur</title>

      <para>
        Commencez par télécharger un paquet de firmware pour votre famille de CPU
sur <ulink url= '&sources-anduin-http;/linux-firmware/amd-ucode/'/>. La
famille est toujours spécifiée en hexadécimal. Les familles 10h à 14h (16 à
20) sont dans microcode_amd.bin. Les familles 15h, 16h, 17h (Zen, Zen+,
Zen2) et 19h (Zen3) ont leur propre conteneur. Seules quelques machines sont
susceptibles de recevoir une mise à jour du microcode. Au lieu de cela, AMD
fournit un AGESA à jour aux constructeurs de cartes mères qui peuvent
l'utiliser pour proposer une mise à jour du BIOS. Il y a un script Python3
sur <ulink url=
'https://github.com/AMDESE/amd_ucode_info/blob/master/amd_ucode_info.py'/>.
Téléchargez ce script et lancez-le avec le fichier binaire pour vérifier si
vos processeurs ont une mise à jour.
      </para>

      <para>
        Pour le très vieil Athlon(tm) II X2 de ces exemples, les valeurs étaient
famille CPU 16, modèle 5, pas 3, ce qui donne un identifiant Family=0x10
Model=0x05 Stepping=0x03. Une ligne de la sortie du script
<command>amd_ucode_info.py</command> décrit la version du microcode pour ce
CPU&nbsp;:
      </para>

<screen><computeroutput>Family=0x10 Model=0x05 Stepping=0x03: Patch=0x010000c8 Length=960 bytes</computeroutput></screen>

      <para>
        Si la valeur du champ <quote>microcode</quote> dans
<filename>/proc/cpuinfo</filename> est 0x10000c8 ou plus, cela signifie que
le BIOS a déjà appliqué la mise à jour du microcode. Sinon, configurez le
noyau pour prendre en charge le chargement du microcode AMD puis consultez
<xref linkend='early-microcode'/>&nbsp;:
      </para>

      <xi:include xmlns:xi="http://www.w3.org/2001/XInclude"
        href="amd-ucode-kernel.xml"/>

    </sect3>

    <sect3 id="early-microcode">
      <title>Chargement "tôt" du micro-code</title>

      <para>
        Si vous avez établi qu'un micro-code mis à jour est disponible pour votre
système, il est temps de le préparer pour un chargement "tôt". Cela demande
un paquet supplémentaire, <xref linkend='cpio'/> et la création d'un initrd
qui devra être ajouté à grub.cfg.
      </para>

      <para>
        L'endroit ou vous préparez l'initrd n'est pas important, et une fois
fonctionnel vous pouvez appliquer le même initrd aux versions futures de LFS
ou aux nouveaux noyaux sur cette même machine, au moins jusqu'à ce qu'une
nouvelle version du micro-code soit publiée. Utiliser la suite&nbsp;:
      </para>

<screen><userinput>mkdir -p initrd/kernel/x86/microcode
cd initrd</userinput></screen>

      <para>
        Pour une machine AMD, utilisez la commande suivante (remplacez
&lt;MYCONTAINER&gt; par le nom du paquet de votre famille de CPU)&nbsp;:
      </para>

<screen><userinput>cp -v ../&lt;MYCONTAINER&gt; kernel/x86/microcode/AuthenticAMD.bin</userinput></screen>

      <para>
        Ou pour une machine Intel copiez le blob approprié en utilisant cette
commande&nbsp;:
      </para>

<!-- new version from 20201110 release onwards, assumed to work on all skylakes
   But complaints about previous version took some days to appear, so keep as a comment for now.
      <caution>

        <para>
          On some Skylake machines with hex Model Number '4e' (78 decimal) the
          upgrade to microcode version '0xdc' is reported to cause the machine to
          hang in early boot, and the fix is to revert to version 0xd6 which was
          first shipped in the 20191115 microcode release.
        </para>

        <para>
          At least one model '5e' Skylake does boot successfully with version
          0xdc, but Intel has now shipped a 20200616 release which is intended for
          distros which need an initrd that will boot on everyone's machine: it
          reverts both Skylake variants ('4e' and '5e') to the old 0xd6.
        </para>

        <para>
          For a Skylake which does not boot with 0xdc, reverting to 0xd6 will make
          the machine usable, but without the SRBDS mitigations.
        </para>
      </caution>-->
<screen><userinput>cp -v ../intel-ucode/&lt;XX-YY-ZZ&gt; kernel/x86/microcode/GenuineIntel.bin</userinput></screen>



      <para>
        Maintenant préparez l'initrd&nbsp;:
      </para>

<screen><userinput>find . | cpio -o -H newc &gt; /boot/microcode.img</userinput></screen>

      <para>
        Vous devrez également ajouter une nouvelle entrée à /boot/grub/grub.cfg et
vous devrez ajouter une ligne après la ligne linux entre les apostrophes. Si
/boot est dans une partition séparée&nbsp;:
       </para>

<screen><userinput>initrd /microcode.img</userinput></screen>

      <para>
        ou sinon&nbsp;:
      </para>

<screen><userinput>initrd /boot/microcode.img</userinput></screen>

      <para>
        Si vous avez déjà démarré avec un initrd (voir <xref linkend="initramfs"/>)
vous deviez de nouveau lancer <command>mkinitramfs</command> après avoir
placé le blob ou le conteneur approprié dans <filename
class="directory">/lib/firmware</filename>. Plus précisément, placez le blob
Intel dans le répertoire <filename
class="directory">/lib/firmware/intel-ucode</filename> ou le conteneur AMD
dans <filename class="directory">/lib/firmware/amd-ucode</filename> avant
d'exécuter <command>mkinitramfs</command>. Autrement, vous pouvez avoir les
deux initrd sur la même ligne, comme dans <userinput>initrd /microcode.img
/other-initrd.img</userinput> (adaptez comme ci-dessus si /boot n'est pas
dans une partition séparée).
      </para>

      <para>
        Vous pouvez maintenant redémarrer avec l'initrd supplémentaire, puis
utiliser la même commande pour vérifier que le chargement «&nbsp;au plus
tôt&nbsp;» a fonctionné.
      </para>

<screen><userinput>dmesg | grep -e 'microcode' -e 'Linux version' -e 'Command line'</userinput></screen>

      <para>
        Si vous avez mis à jour pour corriger des vulnérabilités, vous pouvez
regarder la sortie de la commande <command>lscpu</command> pour voir ce
qu'il rapporte maintenant.
      </para>

      <para>
        Les endroits et les moments où le chargement au plus tôt se passent sont
très différents entre les machines AMD et Intel. En premier, un exemple
d'Intel (mobile Tigerlake) avec le chargement au plus tôt&nbsp;:
      </para>

<screen><literal>[    0.000000] microcode: microcode updated early: 0x86 -> 0xac, date = 2023-02-27
[    0.000000] Linux version 6.4.7 (root@stargazer) (gcc (GCC) 13.2.0, GNU ld (GNU Binutils) 2.41) #1 SMP PREEMPT_DYNAMIC Wed Aug  2 19:08:46 CST 2023
[    0.000000] Command line: BOOT_IMAGE=/boot/vmlinuz-6.4.7 root=PARTUUID=<replaceable>&lt;CLASSIFIED&gt;</replaceable> ro
[    0.424002] microcode: Microcode Update Driver: v2.2.</literal></screen>


      <para>
        Un exemple historique pour AMD&nbsp;:
      </para>

<screen><literal>[    0.000000] Linux version 4.15.3 (ken@testserver) (gcc version 7.3.0 (GCC))
               #2 SMP Sun Feb 18 02:32:03 GMT 2018
[    0.000000] Command line: BOOT_IMAGE=/vmlinuz-4.15.3-sda5 root=/dev/sda5 ro
[    0.307619] microcode: microcode updated early to new patch_level=0x010000c8
[    0.307678] microcode: CPU0: patch_level=0x010000c8
[    0.307723] microcode: CPU1: patch_level=0x010000c8
[    0.307795] microcode: Microcode Update Driver: v2.2.</literal></screen>

    </sect3>

  </sect2>

  <sect2 id="video-firmware">
    <title>Firmware pour les cartes vidéo</title>

    <sect3 id="ati-video-firmware">
      <title>Firmware pour les puces vidéo ATI (R600 et plus)</title>

      <para>
        Ces instructions NE s'appliquent PAS aux anciennes radeons avant la famille
R600. Pour elles, le firmware est dans le répertoire du noyau <filename
class='directory'>/lib/firmware/</filename>. Appliquez-les seulement si vous
prévoyez d'éviter une configuration graphique tels que Xorg et que vous
voulez vous contenter d'utiliser l'affichage 80x25 par défaut plutôt qu'un
framebuffer.
      </para>

      <para>
        Les périphériques radeon plus anciens demandaient seulement un simple blob
de 2&nbsp;Ko. Les périphériques récents ont besoin de plusieurs blobs
différents, et certains d'entre eux sont bien plus gros. La taille totale du
répertoire des firmwares radeon est de plus de 500&nbsp;Ko — sur un gros
système moderne vous pouvez probablement utiliser cet espace, mais cela
reste redondant d'installer tous les fichiers inutiles chaque fois que vous
construisez un système.
      </para>

      <para>
        Une meilleure approche est d'installer<xref linkend='pciutils'/> et ensuite
utiliser <userinput>lspci</userinput> pour identifier quel controleur VGA
est installé.
      </para>

      <para>
        Avec cette information, vérifiez la page RadeonFeature du wiki Xorg <ulink
url="https://wiki.x.org/wiki/RadeonFeature/#index5h2">Decoder ring for
engineering vs marketing names</ulink> pour identifier la famille (vous
aurez besoin de savoir cela pour identifier le pilote Xorg dans BLFS —
Southern Islands et Sea Islands utilise le pilote radeonsi) et le modèle
spécifique.
      </para>

      <para>
        Maintenant que vous savez quel contrôleur vous allez utiliser, consultez la
page <ulink
url="https://wiki.gentoo.org/wiki/Radeon#Firmware">Radeon</ulink> du wiki de
Gentoo qui a un tableau listant les blobs de firmware requis pour les
différentes puces. Notez que les puces Southern Islands et Sea Islands
utilisent des firmwares différents pour les noyaux 3.17 et supérieur par
rapport aux noyaux antérieurs. Identifiez et téléchargez les blobs requis et
ensuite installez les&nbsp;:
      </para>

<screen><userinput>mkdir -pv /lib/firmware/radeon
cp -v &lt;YOUR_BLOBS&gt; /lib/firmware/radeon</userinput></screen>

    <para>
      Construire le pilote amdgpu du noyau en tant que module est recommandé car
les fichiers du micrologiciel doivent être accessibles au moment du
chargement. Si vous le construisez dans l'image du noyau pour quelque raison
que ce soit, vous devez inclure les fichiers du micrologiciel dans
l'initramfs (consultez <xref linkend='initramfs'/> pour les détails) ou les
inclure dans l'image du noyau directement (consultez <xref
linkend='firmware-in-kernel-image'/> pour les détails).
    </para>

    </sect3>

    <sect3 id="amdgpu-video-firmware">
      <title>Firmware pour les puces vidéo amdgp AMD/ATI</title>

      <para>
        Tous les controlleurs vidéo qui utilisent le pilote amdgpu du noyau ont
besoin d'un firmware, que vous utilisiez le pilote amdgpu de xorg, le pilote
modesetting de xserver, ou juste de modesetting du noyau pour avoir un
framebuffer de console plus grand que 80x25.
      </para>

      <para>
        Installez <xref linkend="pciutils"/> et utilisez-le pour vérifier le nom du
modèle (cherchez «&nbsp;VGA compatible controller:&nbsp;»). Si vous ave un
APU (unité de traitement accélérée, c'est-à-dire le CPU et la carte vidéo
sur la même puce), cela vous en dira sans doute le nom. Si vous avez une
carte vidéo amdgpu séparée vous devrez chercher pour déterminer le nom
qu'elle utilise (p.&nbsp;ex. une carte décrite comme Advanced Micro Devices,
Inc. [AMD/ATI] Baffin [Radeon RX 550 640SP / RX 560/560X] a besoin du pilote
Polaris11). Il y a une table de correspondance «&nbsp;Famille, nom de puce,
nom de produit et firmware&nbsp;» à la fin des sections du noyau sur la page
<ulink
url="https://wiki.gentoo.org/wiki/AMDGPU#Known_firmware_blobs">AMDGPU</ulink>
du wiki de Gentoo.
    </para>

    <para>
      Une fois que vous avez identifié le nom du firmware, installez tous les
fichiers utiles. Par exemple, la carte Baffin mentionnée plus tôt a 21
fichiers polaris11* différents, les APU comme renoir et picasso ont au moins
12 fichiers et pourront en avoir plus dans les mises à jour futures
(p.&nbsp;ex. l'APU raven a maintenant un 13ème fichier, raven_ta.bin).
    </para>

<screen><userinput>mkdir -pv /lib/firmware/amdgpu
cp -v &lt;YOUR_BLOBS&gt; /lib/firmware/amdgpu</userinput></screen>

    <para>
      Si l'espace disque n'est pas un problème, vous pouvez installer tous les
fichiers de firmware actuel sans vous soucier de savoir quelle puce est
installée.
    </para>

    <para>
      Construire le pilote amdgpu du noyau en tant que module est recommandé car
les fichiers du micrologiciel doivent être accessibles au moment du
chargement. Si vous le construisez dans l'image du noyau pour quelque raison
que ce soit, vous devez inclure les fichiers du micrologiciel dans
l'initramfs (consultez <xref linkend='initramfs'/> pour les détails) ou les
inclure dans l'image du noyau directement (consultez <xref
linkend='firmware-in-kernel-image'/> pour les détails).
    </para>

    </sect3>

    <sect3 id="nvidia-video-firmware">
      <title>Firmware pour les puces vidéo Nvidia</title>

      <para>
        Nvidia a publié des firmware de base signés pour les puces graphiques
récentes, mais bien après que les puces et ses propres pilotes binaires ne
soient disponibles. Pour les autres puces il était nécessaire d'extraire le
firmware du pilote binaire.
      </para>
      <para>
        Pour des informations précises sur les puces qui ont besoin d'un firmware
extrait, voir <ulink url=
"https://nouveau.freedesktop.org/VideoAcceleration.html"/>.
      </para>

      <para>
        Si le firmware requis est disponible dans le répertoire <filename
class="directory">nvidia/</filename> de linux-firmware, copiez-le dans
<filename class="directory">/lib/firmware/nouveau</filename>.
      </para>
      <para>
        Si le firmware n'a pas été mis à disposition dans linux-firmware, pour les
anciennes puces mentionnées dans le lien vers le wiki de nouveau ci-dessus,
exécutez les commandes suivantes&nbsp;:
      </para>

<screen><userinput>wget https://anduin.linuxfromscratch.org/BLFS/nvidia-firmware/extract_firmware.py
wget https://us.download.nvidia.com/XFree86/Linux-x86/340.32/NVIDIA-Linux-x86-340.32.run
sh NVIDIA-Linux-x86-340.32.run --extract-only
python3 extract_firmware.py
mkdir -p /lib/firmware/nouveau
cp -d nv* vuc-* /lib/firmware/nouveau/</userinput></screen>

    </sect3>
  </sect2>

  <sect2 id="nic-firmware">
    <title>Firmware pour les interfaces réseaux</title>

    <para>
      Le noyau aime charger des firmware pour quelques pilotes réseaux,
particulièrement ceux du répertoire Realtek (/lib/linux-firmware/rtl_nic/),
mais il apparaît généralement que cela fonctionne sans. Cependant, vous
pouvez démarrer le noyau, vérifier si dmesg contient des messages à propos
de firmwares manquants, et si nécessaire télécharger les firmwares et les
mettre dans un répertoire spécifique dans <filename
class="directory">/lib/firmware</filename> afin qu'ils puissent être trouvés
lors des prochains démarrages. Notez qu'avec les noyaux actuels cela
fonctionne que le pilote soit compilé dedans ou construit comme un module,
il n'est pas utile de construire ce firmware dans le noyau. Ici un exemple
ou le pilote R8169 a été compilé dedans mais le firmware n'est pas
disponible. Une fois que le firmware a été fourni, il n'y est plus fait
mention dans les démarrages suivants.
    </para>

<screen><literal>dmesg | grep firmware | grep r8169
[    7.018028] r8169 0000:01:00.0: Direct firmware load for rtl_nic/rtl8168g-2.fw failed with error -2
[    7.018036] r8169 0000:01:00.0 eth0: unable to load firmware patch rtl_nic/rtl8168g-2.fw (-2)</literal></screen>

  </sect2>

  <sect2 id="regulatory-db">
    <title>Micrologiciel pour les bases de données légales pour les périphériques sans
fil</title>

    <para>
      Plusieurs pays ont des réglementations différentes sur l'utilisation du
spectre radio des appareils sans-fil. Vous pouvez installer un
microprogramme pour qu'un appareil sans-fil obéisse aux réglementations sur
les émissions, pour ne pas être inquiété par les autorités ou découvrir que
votre wifi brouille les fréquences d'autres appareils (par exemple des
télécommandes). Le microprogramme qui contient la base de régulations se
trouve sur <ulink url =
'https://kernel.org/pub/software/network/wireless-regdb/'/>. Pour
l'installer, extrayez simplement <filename>regulatory.db</filename> et
<filename>regulatory.db.p7s</filename> de l'archive vers <filename
class="directory">/lib/firmware</filename>. Remarquez que vous devez soit
sélectionner le pilote <option>cfg80211</option> en tant que module pour que
les fichiers <filename>regulatory.*</filename> soient chargés, soit inclure
ces fichiers directement comme un micrologiciel dans le noyau, comme
expliqué plus haut dans <xref linkend="video-firmware"/>.
    </para>

    <para>
      Le point d'accès (AP) enverrait un code de pays à votre carte sans fil, et
<xref linkend='wpa_supplicant'/> dirait au noyau de charger les règles pour
ce pays à partir de <filename>regulatory.db</filename> et de les
utiliser. Remarquez que de nombreux points d'accès n'envoient pas de code de
pays, donc vous pourriez être bloqué dans une utilisation restreinte
(surtout si vous voulez utiliser votre interface comme point d'accès).
    </para>
  </sect2>

  <sect2 id="sound-open-firmware">
    <title>Micrologiciels libres pour l'audio</title>

    <para>
      Certains systèmes (surtout les portables pas chers) utilisent un DSP fournit
avec le CPU pour se connecter au codec audio. Le micrologiciel libre pour
l'audio (Open Sound Firmware) doit être chargé sur le DSP pour le rendre
fonctionnel. Ces fichiers de micrologiciel peuvent être téléchargés sur
<ulink url='https://github.com/thesofproject/sof-bin/releases'/>. Extrayez
l'archive et rendez-vous dans le répertoire extrait, puis en tant
qu'utilisateur &root; installez le micrologiciel&nbsp;:
    </para>

    <screen role="nodump"><userinput>install -vdm755 /usr/lib/firmware/intel       &amp;&amp;
cp -av -T --no-preserve=ownership sof-v*      \
   /usr/lib/firmware/intel/sof                &amp;&amp;
cp -av -T --no-preserve=ownership sof-tplg-v* \
   /usr/lib/firmware/intel/sof-tplg</userinput></screen>

    <para>
      <xref linkend="alsa-lib"/> nécessite des fichiers de configuration de type
«&nbsp;Use Case Manager&nbsp;» pour que le système utilise également ce
micrologiciel. Les fichiers de configuration UCM d'ALSA peuvent être
téléchargés sur <ulink
url='https://github.com/alsa-project/alsa-ucm-conf/tags'/>. Extrayez
l'archive et rendez-vous dans le répertoire extrait, puis en tant
qu'utilisateur &root; installez les fichiers de configuration&nbsp;:
    </para>

    <screen role="nodump"><userinput>install -vdm755 /usr/share/alsa &amp;&amp;
cp -av -T --no-preserve=ownership ucm2 /usr/share/alsa/ucm2</userinput></screen>

    <para>
      Une fois le micrologiciel chargé (vous devrez peut-être redémarrer pour que
le noyau les charge) et les fichiers de configuration UCM installés, suivez
<xref linkend="alsa-utils-config-sect"/> pour configurer votre carte son
avec ALSA correctement.
    </para>
  </sect2>

  <sect2 id="other-firmware">
    <title>Firmware pour les autres périphériques</title>

    <para>
      Pour identifier le bon firmware vous devrez normallement install <xref
linkend='pciutils'/> puis utiliser <userinput>lspci</userinput> pour
identifier le matériel. Vous devriez ensuite chercher en ligne pour vérifier
le module qu’il utilise, quel firmware et où obtenir le firmware &mdash; ils
ne sont pas tous dans linux-firmware.
    </para>

    <para>
      Si possible, vous pouvez commencer par utiliser une connexion filaire quand
vous démarrez la première fois votre système LFS. Pour utiliser une
connexion sans fils vous aurez besoin d'utiliser des outils réseau tels que
<xref linkend="iw"/>, <xref linkend='wireless_tools'/> ou <xref
linkend='wpa_supplicant'/>.
    </para>

    <para>
      Les firmwares peuvent aussi être utiles pour d'autres périphériques comme
les contrôleurs SCSI, les adaptateurs Bluetooth, ou les enregistreurs
TV. Les mêmes principes s'appliquent.
    </para>

  </sect2>

  <sect2 id='firmware-in-kernel-image'>
    <title>Inclure les blobs des micrologiciels dans l'image du noyau</title>

    <para>
      Certains pilotes, surtout les pilotes pour les GPU ATI ou AMD, ont besoin
que des fichiers de micrologiciel soient accessibles au chargement. La
méthode la plus facile de gérer ces pilotes est de les construire en tant
que module du noyau. Une autre méthode consiste à créer un initramfs
(consultez <xref linkend='initramfs'/> pour les détails) qui contiendrait
les fichiers du micrologiciel. Si vous ne voulez pas utiliser ces méthodes,
vous pouvez inclure directement les fichiers du micrologiciel dans l'image
du noyau. Installez d'abord les fichiers de micrologiciel requis dans
<filename class='directory'>/lib/firmware</filename>, puis configurez le
noyau et reconstruisez-le&nbsp;:
    </para>

    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude"
      href="builtin-fw-kernel.xml"/>

    <para>
      Remplacez <replaceable>xx/aa.bin xx/bb.bin</replaceable> par une liste de
chemins séparés par des espaces vers les fichiers requis, relativement à
<filename class='directory'>/lib/firmware</filename>. Une méthode plus
simple que de taper la liste complète à la main (ça peut être long) consiste
à exécuter la commande suivante&nbsp;:
    </para>

    <screen><userinput>echo CONFIG_EXTRA_FIRMWARE='"'$({ cd /lib/firmware; echo <replaceable>amdgpu/*</replaceable> })'"' &gt;&gt; .config
make oldconfig</userinput></screen>

    <para>
      Remplacez <replaceable>amdgpu/*</replaceable> par un motif shell
correspondant aux fichiers de micrologiciel requis.
    </para>

    <warning>
      <para>
        Ne distribuez pas une image du noyau contenant les micrologiciels à d'autres
personnes ou vous pourriez violer la licence GPL.
      </para>
    </warning>

  </sect2>

</sect1>
