<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../../general.ent">
  %general-entities;
]>

<sect1 id="postlfs-firmware" xreflabel="À propos des Firmwares">
  <?dbhtml filename="firmware.html"?>

  <sect1info>
<date>$Date$</date></sect1info>

  <title>À propos des Firmwares</title>

  <indexterm zone="postlfs-firmware">
    <primary sortas="e-lib-firmware">/lib/firmware</primary>
  </indexterm>

  <para>
    Sur certains PCs actuels il peut être nécessaire, ou désirable, de charger
des firmwares pour faire travailler les PC au maximum de leurs
possibilités. Le noyau contient un répertoire, <filename
class="directory">/lib/firmware</filename>, ou le noyau ou les pilotes du
noyau cherche des images de firmware.
  </para>

  <para>
    Currently, most firmware can be found at a <userinput>git</userinput>
repository: <ulink url=
"https://git.kernel.org/cgit/linux/kernel/git/firmware/linux-firmware.git/tree/"/>.
For convenience, the LFS Project has created a mirror, updated daily, where
these firmware files can be accessed via <userinput>wget</userinput> or a
web browser at <ulink url="&sources-anduin-http;/linux-firmware/"/>.
  </para>

  <para>
    Pour récupérer le microprogramme, vous devez soit aller sur un des dépôts
ci-dessus avec un navigateur pour télécharger les fichiers dont vous avez
besoin, soit installer <xref linkend="git"/> et cloner ce dépôt.
  </para>

  <para>
    Pour certains autres firmwares, particulièrement pour les micro-codes
d'Intel, et certains périphériques wi-fi, le firmware recherché n'est pas
disponible dans le dépôt précédent. Certains d'entre eux seront ajouté
ensuite, mais il est parfois nécessaire de faire une recherche sur internet
pour les firmwares souhaités.
  </para>

  <para>
    Les fichiers firmwares sont par convention référencés comme des blobs car
vous ne pouvez pas déterminer ce qu'ils font. Notez que ces firmwares sont
distribués sous des licences différentes et variées qui ne permettent pas le
désassemblage ou la retro ingénierie.
  </para>

  <para>
    Les firmwares pour PC tombent dans 4 catégories&nbsp;:
  </para>

  <itemizedlist spacing="compact">
    <listitem>
      <para>
        Les firmwares mettant à jour le processeur pour travailler correctement,
couramment appelé micro-code.
      </para>
    </listitem>
    <listitem>
      <para>
        Microprogramme pour les contrôleurs vidéo. Sur les machines x86 ils sont
requis pour les périphériques ATI (puces Radeon et AMDGPU) et peuvent être
utiles pour les GPU Intel (Skylake et ultérieur) et Nvidia (Kepler et
ultérieurs).
      </para>

      <para>
        Les périphériques ATI Radeom et AMDGPU demandent des microprogrammes pour
pouvoir utiliser le KMS (kernel modesetting &mdash; l'option préférée) ainsi
que Xorg. Pour les puces radeon plus anciennes (avant R600), le
microprogramme est resté dans le noyau.
      </para>

      <para>
        Les GPU intégrés d'Intel de Skylake et supérieur peuvent utiliser le
microprogramme pour GuC (the microcontrôleur graphique), et le le HuC (le
microcontrôleur HEVC/H265 qui décharge vers le GPU) et DMC (microcontrôleur
pour l'affichage) pour fournir des états à basse consommation
supplémentaires. Le GuC et HuC ont un historique mouvementé dans le noyau et
les microprogrammes à jour peuvent être désactivés par défaut, en fonction
de la version de votre noyau. Des détails supplémentaires se trouvent sur
<ulink url="https://01.org/linuxgraphics/downloads/firmware/">01.org</ulink>
et <ulink url="https://wiki.archlinux.org/index.php/intel_graphics">Arch
linux</ulink>.
      </para>

      <para>
        Les GPU Nvidia à partir de Kepler ont besoin d'un microprogramme signé,
sinon le pilote nouveau est incapable de fournir l'accélération
matérielle. Nvidia a maintenant fourni des microprogrammes jusqu'à Ampere
(la séie GeForce30) dans linux-firmware. Remarquez que les horloges plus
rapides que par défaut ne sont pas activées dans le microprogramme publié.
      </para>
    </listitem>
    <listitem>
      <para>
        Mises à jour des firmware pour les interfaces réseaux filaires. La plupart
du temps elles fonctionnent sans mise à jour, mais elles fonctionneront sans
doute mieux avec un firmware à jour. Pour certains ordinateurs portables
récentes, les firmware pour le port ethernet (p. ex. rtl_nic) mais aussi
pour les périphériques bluetooth (p. ex. qca) sont
<emphasis>requis</emphasis> avant de pouvoir utiliser les réseau filaire.
      </para>
    </listitem>
    <listitem>
      <para>
        Les Firmwares pour les autres périphériques, comme le wi-fi. Ces
périphériques ne sont pas requis pour que le PC démarre, mais demande un
firmware avant que ces périphériques puissent être utilisés.
      </para>
    </listitem>
  </itemizedlist>

  <note>
    <para>
      Bien qu’ils soient inutiles pour charger un firmware fermé (blob), les
outils suivants peuvent être utiles pour déterminer, obtenir, ou préparer le
firmware à utiliser afin de le charger dans le système&nbsp;: <xref
linkend="cpio"/>, <xref linkend="git"/>, <xref linkend="pciutils"/> et <xref
linkend="wget"/>
    </para>
  </note>

  <para condition="html" role="usernotes">Notes utilisateur&nbsp;: <ulink url="&blfs-wiki;/aboutfirmware"/></para>

  <sect2 id="cpu-microcode">
    <title>Mise à jour de micro-codes pour les CPU</title>

    <para>
      En général, le micro-code peut être chargé par le BIOS ou l'UEFI, et il peut
être mis à jour en passant à une nouvelle version de celui-ci. Sur Linux,
vous pouvez également charger le micro-code depuis le noyau si vous utilisez
au moins un AMD de la famille 10h ou un plus récent (introduit après fin
2007), ou un processeur Intel de 1998 et plus (Pentium4, Core, etc), si un
micro-code mis à jour a été publié. Ces mises à jour sont actives seulement
jusqu'à ce que la machine soit éteinte, il est donc nécessaire de les
appliquer à chaque démarrage.
    </para>

    <para>
      Intel fournit des mises à jour de leur microcode pour les versions Skylake
et ultérieures de leurs processeurs quand de nouvelles vulnérabilités sont
découvertes, et l'ont fait pour les processeurs SandyBridge et ultérieurs
par le passé, bien qu'ils ne soient plus pris en charge pour les nouvelles
corrections. Les nouvelles versions de microprogramme d'AMD sont rares et ne
s'appliquent qu'à quelques modèles, bien que les fabricants de carte mères
obtiennent des mises à jour AGESA (AMD Generic Encapsulated Software
Architecture) pour changer les valeurs du BIOS, par exemple pour prendre en
charge plus de variantes de mémoire ou de nouveaux CPU.
    </para>

    <para>
      There were two ways of loading the microcode, described as 'early' and
'late'. Early loading happens before userspace has been started, late
loading happens after userspace has started. However, late loading is known
to be problematic and not supported anymore (see the kernel commit <ulink
url="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=d23d33e">
x86/microcode: Taint and warn on late loading</ulink>.)  Indeed, early
loading is needed to work around one particular erratum in early Intel
Haswell processors which had TSX enabled.  (See <ulink url=
"https://www.anandtech.com/show/8376/intel-disables-tsx-instructions-erratum-found-in-haswell-haswelleep-broadwelly/">
Intel Disables TSX Instructions: Erratum Found in Haswell, Haswell-E/EP,
Broadwell-Y</ulink>.)  Without this update glibc can do the wrong thing in
uncommon situations.
    </para>

    <para>
      Dans les versions précédentes de ce livre, nous recommandions le chargement
au plus tard pour voir s'il était appliqué, suivi par l'utilisation d'un
initrd pour forcer le chargement au plus tôt. Mais maintenant que le contenu
de l'archive de microcode Intel est documenté, et que le microcode AMD peut
être lu par un script Python pour déterminer les machines qu'il couvre, il
n'y a plus de raison d'utiliser le chargement au plus tard.
    </para>

    <para>
      Il reste peut-être possible de manuellement forcer le chargement «&nbsp;au
plus tard&nbsp;» du microcode, mais cela pourrait occasionner une
malfonction du noyau et vous devez être conscient·e du risque. Vous devrez
reconfigurer votre noyau pour l'une ou l'autre méthode. Les instructions ici
montrent comment créer un initrd pour un chargement «&nbsp;au plus
tôt&nbsp;». Il est aussi possible d'intégrer le même fichier binaire de
microcode dans le noyau, ce qui permet le chargement au plus tôt mais
nécessite de recompiler le noyau pour mettre à jour le microcode.
    </para>

    <para>
      Pour déterminer l'identité de votre processeur (s'il y en a plus d'un, ils
seront identiques) regardez dans /proc/cpuinfo. Déterminez les valeurs
décimales de la famille du processeur, le modèle, et le pas en exécutant la
commande suivante (elle rapportera aussi la version actuelle du
micro-code)&nbsp;:
    </para>

<screen><userinput>head -n7 /proc/cpuinfo</userinput></screen>

    <para>
      Convertissez la famille, le modèle et le pas du processeur en paires de
nombre hexadécimaux et rappelez-vous la valeur du champ
<quote>microcode</quote>. Vous pouvez maintenant vérifier si un microcode
est disponible.
    </para>

    <para>
      Si vous créez un initrd pour mettre à jour le microcode de différentes
machines, comme le ferait une distro, regardez «&nbsp;Chargement du
microcode au plus tôt&nbsp;» et concaténez tous les blobs Intel dans
GenuineIntel.bin ou tous ceux de AMD dans AUthenticAMD.bin. Cela crée un
initrd plus gros — pour toutes les machines Intel dans la mise à jour
20200609 la taille est de 3,0&nbsp;Mo par rapport à 24 Ko pour une seule
machine.
    </para>

    <sect3 id="intel-microcode">
      <title>Micro-code Intel pour le processeur</title>

      <para>
        <!-- at one time, some skylakes had problems with a certain revision
        secure version of the microcode, for those machines which can boot it, -->
<!-- If you have a Skylake machine, please read the
        Caution in the 'Early loading of microcode' section below.-->
La première étape est d'obtenir la version la plus récente du microcode
d'Intel. Vous devez pour cela aller sur <ulink url=
'https://github.com/intel/Intel-Linux-Processor-Microcode-Data-Files/releases/'/>
et télécharger le fichier le plus récent. Au moment de l'écriture de ces
lignes la version la plus sure du micro-code est
microcode-20220510. Extrayez ce fichier normalement, le microcode se trouve
dans le répertoire <filename>intel-ucode</filename> qui contient les divers
blobs avec des noms de la forme XX-YY-ZZ. Il y a aussi d'autres fichiers
divers et un fichier releasenote.
      </para>

      <para>
        Par le passé, Intel ne fournissait aucun détails sur les blobs dont la
version changeait, mais maintenant les releasenote en parlent. Vous pouvez
comparer la version du microcode dans <filename>/proc/cpuinfo</filename>
avec la version pour votre modèle de CPU dans les releasenote pour savoir
s'il y a une mise à jour.
      </para>

      <para>
        Le firmware récent pour les processeurs les plus anciens est fournit pour
traiter des vulnérabilités qui ont été rendue publiques, et pour certains
d'entre eux comme le <foreignphrase>Microarchitectural Data
Sampling</foreignphrase> (MDS) vous pourriez vouloir augmenter la protection
en désactivant l'hyperthreading ou en désactivant les contournements par
défaut du noyau à cause de son impact sur les temps de compilation. Lisez
bien la documentation en ligne sur <ulink url=
'https://www.kernel.org/doc/html/latest/admin-guide/hw-vuln/index.html'/>.
      </para>

      <para>
        Pour un mobile Icelake (décrit comme Intel(R) Core(TM) i7-1065G7 CPU) les
valeurs utiles sont famille CPU 6, modèle 126, pas 5, donc dans ce cas
l'identifiant requis est 06-7e-05. Les releasenote disent que le dernier
microcode pour ce CPU est la version 0xb2. Si la valeur du champ
<quote>microcode</quote> dans <filename>/proc/cpuinfo</filename> et 0xb2 ou
plus, cela signifie que la mise à jour du microcode est déjà appliquée par
le BIOS. Sinon, configurez le noyau pour prendre en charge le chargement du
microcode Intel puis consultez <xref linkend='early-microcode'/>.
      </para>

<screen><literal>General Setup ---&gt;
  [*] Initial RAM filesystem and RAM disk (initramfs/initrd) support [CONFIG_BLK_DEV_INITRD]
Processor type and features  ---&gt;
  [*] CPU microcode loading support  [CONFIG_MICROCODE]
  [*]      Intel microcode loading support [CONFIG_MICROCODE_INTEL]</literal></screen>

    </sect3>

    <sect3 id="amd-microcode">
      <title>Micro-code AMD pour le processeur</title>

      <para>
        Commencez par télécharger un paquet de firmware pour votre famille de CPU
sur <ulink url= '&sources-anduin-http;/linux-firmware/amd-ucode/'/>. La
famille est toujours spécifiée en hexadécimal. Les familles 10h à 14h (16 à
20) sont dans microcode_amd.bin. Les familles 15h, 16h et 17h (Zen, Zen+,
Zen2) ont leur propre conteneur. Seules quelques machines sont susceptibles
de recevoir une mise à jour du microcode. Il y a un script Python3 sur
<ulink url=
'https://github.com/AMDESE/amd_ucode_info/blob/master/amd_ucode_info.py'/>.
Téléchargez ce script et lancez-le avec le fichier binaire pour vérifier si
vos processeurs ont une mise à jour.
      </para>

      <para>
        Pour le très vieil Athlon(tm) II X2 de ces exemples, les valeurs étaient
famille CPU 16, modèle 5, pas 3, ce qui donne un identifiant Family=0x10
Model=0x05 Stepping=0x03. Une ligne de la sortie du script
<command>amd_ucode_info.py</command> décrit la version du microcode pour ce
CPU&nbsp;:
      </para>

<screen><computeroutput>Family=0x10 Model=0x05 Stepping=0x03: Patch=0x010000c8 Length=960 bytes</computeroutput></screen>

      <para>
        Si la valeur du champ <quote>microcode</quote> dans
<filename>/proc/cpuinfo</filename> est 0x10000c8 ou plus, cela signifie que
le BIOS a déjà appliqué la mise à jour du microcode. Sinon, configurez le
noyau pour prendre en charge le chargement du microcode AMD puis consultez
<xref linkend='early-microcode'/>&nbsp;:
      </para>

<screen><literal>General Setup ---&gt;
  [*] Initial RAM filesystem and RAM disk (initramfs/initrd) support [CONFIG_BLK_DEV_INITRD]
Processor type and features  ---&gt;
  [*] CPU microcode loading support  [CONFIG_MICROCODE]
  [*]      AMD microcode loading support [CONFIG_MICROCODE_AMD]</literal></screen>
    </sect3>

    <sect3 id="early-microcode">
      <title>Chargement "tôt" du micro-code</title>

      <para>
        Si vous avez établi qu'un micro-code mis à jour est disponible pour votre
système, il est temps de le préparer pour un chargement "tôt". Cela demande
un paquet supplémentaire, <xref linkend='cpio'/> et la création d'un initrd
qui devra être ajouté à grub.cfg.
      </para>

      <para>
        L'endroit ou vous préparez l'initrd n'est pas important, et une fois
fonctionnel vous pouvez appliquer le même initrd aux versions futures de LFS
ou aux nouveaux noyaux sur cette même machine, au moins jusqu'à ce qu'une
nouvelle version du micro-code soit publiée. Utiliser la suite&nbsp;:
      </para>

<screen><userinput>mkdir -p initrd/kernel/x86/microcode
cd initrd</userinput></screen>

      <para>
        Pour une machine AMD, utilisez la commande suivante (remplacez
&lt;MYCONTAINER&gt; par le nom du paquet de votre famille de CPU)&nbsp;:
      </para>

<screen><userinput>cp -v /lib/firmware/amd-ucode/&lt;MYCONTAINER&gt; kernel/x86/microcode/AuthenticAMD.bin</userinput></screen>

      <para>
        Ou pour une machine Intel copiez le blob approprié en utilisant cette
commande&nbsp;:
      </para>

<!-- new version from 20201110 release onwards, assumed to work on all skylakes
   But complaints about previous version took some days to appear, so keep as a comment for now.
      <caution>

        <para>
          On some Skylake machines with hex Model Number '4e' (78 decimal) the
          upgrade to microcode version '0xdc' is reported to cause the machine to
          hang in early boot, and the fix is to revert to version 0xd6 which was
          first shipped in the 20191115 microcode release.
        </para>

        <para>
          At least one model '5e' Skylake does boot successfully with version
          0xdc, but Intel has now shipped a 20200616 release which is intended for
          distros which need an initrd that will boot on everyone's machine: it
          reverts both Skylake variants ('4e' and '5e') to the old 0xd6.
        </para>

        <para>
          For a Skylake which does not boot with 0xdc, reverting to 0xd6 will make
          the machine usable, but without the SRBDS mitigations.
        </para>
      </caution>-->
<screen><userinput>cp -v /lib/firmware/intel-ucode/&lt;XX-YY-ZZ&gt; kernel/x86/microcode/GenuineIntel.bin</userinput></screen>



      <para>
        Maintenant préparez l'initrd&nbsp;:
      </para>

<screen><userinput>find . | cpio -o -H newc &gt; /boot/microcode.img</userinput></screen>

      <para>
        Vous devrez également ajouter une nouvelle entrée à /boot/grub/grub.cfg et
vous devrez ajouter une ligne après la ligne linux entre les apostrophes. Si
/boot est dans une partition séparée&nbsp;:
       </para>

<screen><userinput>initrd /microcode.img</userinput></screen>

      <para>
        ou sinon&nbsp;:
      </para>

<screen><userinput>initrd /boot/microcode.img</userinput></screen>

      <para>
        Si vous avez déjà démarré avec un initrd (voir <xref linkend="initramfs"/>)
vous deviez de nouveau lancer <command>mkinitramfs</command> après avoir
placé le blob ou le conteneur approprié dans <filename
class="directory">/lib/firmware</filename> comme expliqué
ci-dessus. Autrement, vous pouvez avoir les deux initrd sur la même ligne,
comme dans <userinput>initrd /microcode.img /other-initrd.img</userinput>
(adaptez comme ci-dessus si /boot n'est pas dans une partition
séparée)&nbsp;:
      </para>

      <para>
        Vous pouvez maintenant redémarrer avec l'initrd ajouté, et ensuite utiliser
la même commande pour vérifier que le chargement «&nbsp;au plus tôt&nbsp;» a
fonctionné.
      </para>

<screen><userinput>dmesg | grep -e 'microcode' -e 'Linux version' -e 'Command line'</userinput></screen>

      <para>
        Si vous avez mis à jour pour corriger des vulnérabilités, vous pouvez
regarder la sortie de la commande <command>lscpu</command> pour voir ce
qu'il rapporte maintenant.
      </para>

      <para>
        Les endroits et les moments où le chargement au plus tôt se passent sont
très différents entre les machines AMD et Intel. En premier, un exemple
d'Intel (mobile Icelake) avec le chargement au plus tôt&nbsp;:
      </para>

<screen><literal>[    0.000000] microcode: microcode updated early to revision 0xb2, date = 2022-03-17
[    0.000000] Linux version 5.19.2 (xry111@xry111-X57S1) (gcc (GCC) 12.2.0, GNU ld (GNU Binutils) 2.39) #123 SMP PREEMPT_DYNAMIC Sun Aug 20 21:14:29 CST 2022
[    0.000000] Command line: BOOT_IMAGE=/vmlinuz-5.19.2-lfs-11.2-systemd root=/dev/nvme0n1p7 ro
[    0.435085] microcode: sig=0x706e5, pf=0x80, revision=0xb2
[    0.435197] microcode: Microcode Update Driver: v2.2.</literal></screen>


      <para>
        Un exemple historique pour AMD&nbsp;:
      </para>

<screen><literal>[    0.000000] Linux version 4.15.3 (ken@testserver) (gcc version 7.3.0 (GCC))
               #2 SMP Sun Feb 18 02:32:03 GMT 2018
[    0.000000] Command line: BOOT_IMAGE=/vmlinuz-4.15.3-sda5 root=/dev/sda5 ro
[    0.307619] microcode: microcode updated early to new patch_level=0x010000c8
[    0.307678] microcode: CPU0: patch_level=0x010000c8
[    0.307723] microcode: CPU1: patch_level=0x010000c8
[    0.307795] microcode: Microcode Update Driver: v2.2.</literal></screen>

    </sect3>

  </sect2>

  <sect2 id="video-firmware">
    <title>Firmware pour les cartes vidéo</title>

    <sect3 id="ati-video-firmware">
      <title>Firmware pour les puces vidéo ATI (R600 et plus)</title>

      <para>
        Ces instructions NE s'appliquent PAS aux anciennes radeons avant la famille
R600. Pour elles, le firmware est dans le répertoire du noyau <filename
class='directory'>/lib/firmware/</filename>. Appliquez-les seulement si vous
prévoyez d'éviter une configuration graphique tels que Xorg et que vous
voulez vous contenter d'utiliser l'affichage 80x25 par défaut plutôt qu'un
framebuffer.
      </para>

      <para>
        Les périphériques radeon plus anciens demandaient seulement un simple blob
de 2&nbsp;Ko. Les périphériques récents ont besoin de plusieurs blobs
différents, et certains d'entre eux sont bien plus gros. La taille totale du
répertoire des firmwares radeon est de plus de 500&nbsp;Ko — sur un gros
système moderne vous pouvez probablement utiliser cet espace, mais cela
reste redondant d'installer tous les fichiers inutiles chaque fois que vous
construisez un système.
      </para>

      <para>
        Une meilleure approche est d'installer<xref linkend='pciutils'/> et ensuite
utiliser <userinput>lspci</userinput> pour identifier quel controleur VGA
est installé.
      </para>

      <para>
        With that information, check the RadeonFeature page of the Xorg wiki for
<ulink url="https://wiki.x.org/wiki/RadeonFeature/#index5h2">Decoder ring
for engineering vs marketing names</ulink> to identify the family (you may
need to know this for the Xorg driver in BLFS &mdash; Southern Islands and
Sea Islands use the radeonsi driver) and the specific model.
      </para>

      <para>
        Maintenant que vous savez quel contrôleur vous allez utiliser, consultez la
page <ulink
url="https://wiki.gentoo.org/wiki/Radeon#Firmware">Radeon</ulink> du wiki de
Gentoo qui a un tableau listant les blobs de firmware requis pour les
différentes puces. Notez que les puces Southern Islands et Sea Islands
utilisent des firmwares différents pour les noyaux 3.17 et supérieur par
rapport aux noyaux antérieurs. Identifiez et téléchargez les blobs requis et
ensuite installez les&nbsp;:
      </para>

<screen><userinput>mkdir -pv /lib/firmware/radeon
cp -v &lt;YOUR_BLOBS&gt; /lib/firmware/radeon</userinput></screen>

      <para>
        Il y a en fait deux façons d'installer ces firmwares. BLFS, dans le
sous-chapitre 'Configuration du noyau pour les firmwares supplémentaires' du
chapitre <xref linkend="xorg-ati-driver"/> donne un exemple de compilation
des firmwares dans le noyau - c'est légèrement plus rapide à charger, mais
utilises plus de mémoire pour le noyau. Ici nous utiliserons la méthode
alternative en faisant un module du pilote radeon. Dans votre configuration
du noyau initialisez la suite&nbsp;:
      </para>

<screen><literal>Device Drivers ---&gt;
  Graphics support ---&gt;
      Direct Rendering Manager ---&gt;
        [*] Direct Rendering Manager (XFree86 ... support)  [CONFIG_DRM]
      [M] ATI Radeon                                        [CONFIG_DRM_RADEON]</literal></screen>

      <para>
        Le chargement de plusieurs blobs volumineux dans /lib/firmware prend un
temps notable, pendant lequel l'écran est blanc. Si vous n'avez pas activé
le logo framebuffer du pingouin, ou changé la taille de la console en
utilisant une police plus grosse, cela n'a probablement pas d'importance. Si
vous le souhaitez, vous pouvez légèrement réduire le temps si vous suivez la
méthode alternative en spécifiant 'y' pour CONFIG_DRM_RADEON couvert dans
BLFS au lien précédent &mdash; vous devez spécifier chaque blob radeon utile
si vous faite cela.
      </para>

    </sect3>

    <sect3 id="amdgpu-video-firmware">
      <title>Firmware pour les puces vidéo amdgp AMD/ATI</title>

      <para>
        Tous les controlleurs vidéo qui utilisent le pilote amdgpu du noyau ont
besoin d'un firmware, que vous utilisiez le pilote amdgpu de xorg, le pilote
modesetting de xserver, ou juste de modesetting du noyau pour avoir un
framebuffer de console plus grand que 80x25.
      </para>

      <para>
        Installez <xref linkend="pciutils"/> et utilisez-le pour vérifier le nom du
modèle (cherchez «&nbsp;VGA compatible controller:&nbsp;»). Si vous ave un
APU (unité de traitement accélérée, c'est-à-dire le CPU et la carte vidéo
sur la même puce), cela vous en dira sans doute le nom. Si vous avez une
carte vidéo amdgpu séparée vous devrez chercher pour déterminer le nom
qu'elle utilise (p.&nbsp;ex. une carte décrite comme Advanced Micro Devices,
Inc. [AMD/ATI] Baffin [Radeon RX 550 640SP / RX 560/560X] a besoin du pilote
Polaris11). Il y a une table de correspondance «&nbsp;Famille, nom de puce,
nom de produit et firmware&nbsp;» à la fin des sections du noyau sur la page
<ulink
url="https://wiki.gentoo.org/wiki/AMDGPU#Known_firmware_blobs">AMDGPU</ulink>
du wiki de Gentoo.
    </para>

    <para>
      Une fois que vous avez identifié le nom du firmware, installez tous les
fichiers utiles. Par exemple, la carte Baffin mentionnée plus tôt a 21
fichiers polaris11* différents, les APU comme renoir et picasso ont au moins
12 fichiers et pourront en avoir plus dans les mises à jour futures
(p.&nbsp;ex. l'APU raven a maintenant un 13ème fichier, raven_ta.bin).
    </para>

<screen><userinput>mkdir -pv /lib/firmware/amdgpu
cp -v &lt;YOUR_BLOBS&gt; /lib/firmware/amdgpu</userinput></screen>

    <para>
      Si l'espace disque n'est pas un problème, vous pouvez installer tous les
fichiers de firmware actuel sans vous soucier de savoir quelle puce est
installée.
    </para>

    <para>
      Nous vous recommandons de construire le pilote amdgpu du noyau en tant que
module. Dans le .config de votre noyau indiquez au moins les options
suivantes et vérifiez les autres options AMDGPU en fonction du matériel pour
lequel vous construisez, par exemple la prise en charge d'ACP (co-processeur
audio)&nbsp;:
    </para>

<screen><literal>Device Drivers ---&gt;
  Graphics support ---&gt;
      Direct Rendering Manager ---&gt;
        [*] Direct Rendering Manager (XFree86 ... support)  [CONFIG_DRM]
        [M] AMD GPU                                         [CONFIG_DRM_AMDGPU]
        Display Engine Configuration ---&gt;
          [*] AMD DC - Enable new display engine (NEW)      [CONFIG_DRM_AMD_DC]</literal></screen>

      <para>
        Comme nous l'avons écrit plus haut à la fin de la section sur les « Firmware
pour les puces vidéo ATI », le chargement de gros blobs dans /lib/firmware
peut prendre un temps notable pendant lequel l'écran sera vide. Sur une
machine lente vous voudrez peut-être consulter la partie
«&nbsp;Configuration du noyau pour les firmwares supplémentaires&nbsp;» de
<xref linkend="xorg-amdgpu-driver"/> et compiler tous les modules requis
dans le noyau pour réduire ce tems, au prix de l'utilisation de plus de
mémoire du noyau.
      </para>

    </sect3>

    <sect3 id="nvidia-video-firmware">
      <title>Firmware pour les puces vidéo Nvidia</title>

      <para>
        Nvidia a publié des firmware de base signés pour les puces graphiques
récentes, mais bien après que les puces et ses propres pilotes binaires ne
soient disponibles. Pour les autres puces il était nécessaire d'extraire le
firmware du pilote binaire.
      </para>
      <para>
        Pour des informations précises sur les puces qui ont besoin d'un firmware
extrait, voir <ulink url=
"https://nouveau.freedesktop.org/wiki/VideoAcceleration/#firmware"/>.
      </para>

      <para>
        Tout d'abord, le pilote Nvidia doit être activé dans le noyau&nbsp;:
      </para>

<screen><literal>Device Drivers ---&gt;
  Graphics support ---&gt;
      Direct Rendering Manager ---&gt;
        &lt;*&gt; Direct Rendering Manager (XFree86 ... support)  [CONFIG_DRM]
      &lt;*/M&gt; Nouveau (NVIDIA) cards                          [CONFIG_DRM_NOUVEAU]</literal></screen>

      <para>
        Si le firmware requis est disponible dans le répertoire <filename
class="directory">nvidia/</filename> de linux-firmware, copiez-le dans
<filename class="directory">/lib/firmware/nouveau</filename>.
      </para>
      <para>
        Si le firmware n'a pas été mis à disposition dans linux-firmware, pour les
anciennes puces mentionnées dans le lien vers le wiki de nouveau ci-dessus,
assurez-vous d'avoir installé <xref linkend="python2"/> et lancez les
commandes suivantes&nbsp;:
      </para>

      
<screen><!-- Someone please port this to Python 3.  -->
<userinput>wget https://raw.github.com/imirkin/re-vp2/master/extract_firmware.py
wget https://us.download.nvidia.com/XFree86/Linux-x86/325.15/NVIDIA-Linux-x86-325.15.run
sh NVIDIA-Linux-x86-325.15.run --extract-only
python2 extract_firmware.py
mkdir -p /lib/firmware/nouveau
cp -d nv* vuc-* /lib/firmware/nouveau/</userinput></screen>

    </sect3>
  </sect2>

  <sect2 id="nic-firmware">
    <title>Firmware pour les interfaces réseaux</title>

    <para>
      Le noyau aime charger des firmware pour quelques pilotes réseaux,
particulièrement ceux du répertoire Realtek (/lib/linux-firmware/rtl_nic/),
mais il apparaît généralement que cela fonctionne sans. Cependant, vous
pouvez démarrer le noyau, vérifier si dmesg contient des messages à propos
de firmwares manquants, et si nécessaire télécharger les firmwares et les
mettre dans un répertoire spécifique dans <filename
class="directory">/lib/firmware</filename> afin qu'ils puissent être trouvés
lors des prochains démarrages. Notez qu'avec les noyaux actuels cela
fonctionne que le pilote soit compilé dedans ou construit comme un module,
il n'est pas utile de construire ce firmware dans le noyau. Ici un exemple
ou le pilote R8169 a été compilé dedans mais le firmware n'est pas
disponible. Une fois que le firmware a été fourni, il n'y est plus fait
mention dans les démarrages suivants.
    </para>

<screen><literal>dmesg | grep firmware | grep r8169
[    7.018028] r8169 0000:01:00.0: Direct firmware load for rtl_nic/rtl8168g-2.fw failed with error -2
[    7.018036] r8169 0000:01:00.0 eth0: unable to load firmware patch rtl_nic/rtl8168g-2.fw (-2)</literal></screen>

  </sect2>

  <sect2 id="other-firmware">
    <title>Firmware pour les autres périphériques</title>

    <para>
      Pour identifier le bon firmware vous devrez normallement install <xref
linkend='pciutils'/> puis utiliser <userinput>lspci</userinput> pour
identifier le matériel. Vous devriez ensuite chercher en ligne pour vérifier
le module qu’il utilise, quel firmware et où obtenir le firmware &mdash; ils
ne sont pas tous dans linux-firmware.
    </para>

    <para>
      Si possible, vous pouvez commencer par utiliser une connexion filaire quand
vous démarrez la première fois votre système LFS. Pour utiliser une
connexion sans fils vous aurez besoin d'utiliser des outils réseau tel que
<xref linkend='wireless_tools'/> et <xref linkend='wpa_supplicant'/>.
    </para>

    <para>
      Plusieurs pays ont des réglementations différentes sur l'utilisation du
spectre radio des appareils sans-fil. Vous pouvez installer un
microprogramme pour qu'un appareil sans-fil obéisse aux réglementations sur
les émissions, pour ne pas être inquiété par les autorités ou découvrir que
votre wifi brouille les fréquences d'autres appareils (par exemple des
télécommandes). Le microprogramme qui contient la base de régulations se
trouve sur <ulink url =
'https://kernel.org/pub/software/network/wireless-regdb/'/>. Pour
l'installer, extrayez simplement <filename>regulatory.db</filename> et
<filename>regulatory.db.p7s</filename> de l'archive vers <filename
class="directory">/lib/firmware</filename>. Le point d'accès envoie un code
de pays à votre antenne, et <xref linkend='wpa_supplicant'/> le dit au noyau
qui charge les réglementations de ce pays à partir de
<filename>regulatory.db</filename> et les met en place.
    </para>

    <para>
      Les firmwares peuvent aussi être utiles pour d'autres périphériques comme
les contrôleurs SCSI, les adaptateurs Bluetooth, ou les enregistreurs
TV. Les mêmes principes s'appliquent.
    </para>

  </sect2>

</sect1>
