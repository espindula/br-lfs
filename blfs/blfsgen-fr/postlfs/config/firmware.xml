<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../../general.ent">
  %general-entities;
]>

<sect1 id="postlfs-firmware" xreflabel="À propos des Firmwares">
  <?dbhtml filename="firmware.html"?>

  <sect1info>
<date>$Date$</date></sect1info>

  <title>À propos des Firmwares</title>

  <indexterm zone="postlfs-firmware">
    <primary sortas="e-lib-firmware">/lib/firmware</primary>
  </indexterm>

  <para>
    Sur certains PCs actuels il peut être nécessaire, ou désirable, de charger
des firmwares pour faire travailler les PC au maximum de leurs
possibilités. Le noyau contient un répertoire, <filename
class="directory">/lib/firmware</filename>, ou le noyau ou les pilotes du
noyau cherche des images de firmware.
  </para>

  <para>
    Actuellement, on peut trouver la plupart des firmwares sur un dépôt
<userinput>git</userinput>&nbsp;: <ulink url=
"http://git.kernel.org/cgit/linux/kernel/git/firmware/linux-firmware.git/tree/"/>.
Par commodité, le projet LFS a créé un miroir, mis à jour quotidiennement,
où on peut accéder à ces fichiers de firmwares via
<userinput>wget</userinput> ou un navigateur web sur <ulink
url="&sources-anduin-http;/linux-firmware/"/>.
  </para>

  <para>
    Pour récupérer le microprogramme, vous devez soit aller sur un des dépôts
ci-dessus avec un navigateur pour télécharger les fichiers dont vous avez
besoin, soit installer <xref linkend="git"/> et cloner ce dépôt.
  </para>

  <para>
    Pour certains autres firmwares, particulièrement pour les micro-codes
d'Intel, et certains périphériques wi-fi, le firmware recherché n'est pas
disponible dans le dépôt précédent. Certains d'entre eux seront ajouté
ensuite, mais il est parfois nécessaire de faire une recherche sur internet
pour les firmwares souhaités.
  </para>

  <para>
    Les fichiers firmwares sont par convention référencés comme des blobs car
vous ne pouvez pas déterminer ce qu'ils font. Notez que ces firmwares sont
distribués sous des licences différentes et variées qui ne permettent pas le
désassemblage ou la retro ingénierie.
  </para>

  <para>
    Les firmwares pour PC tombent dans 4 catégories&nbsp;:
  </para>

  <itemizedlist spacing="compact">
    <listitem>
      <para>
        Les firmwares mettant à jour le processeur pour travailler correctement,
couramment appelé micro-code.
      </para>
    </listitem>
    <listitem>
      <para>
        Microprogramme pour les contrôleurs vidéo. Sur les machines x86 ils sont
requis pour les périphériques ATI (puces Radeon et AMDGPU) et peuvent être
utiles pour les GPU Intel (Skylake et ultérieur) et Nvidia (Kepler et
ultérieurs).
      </para>

      <para>
        Les périphériques ATI Radeom et AMDGPU demandent des microprogrammes pour
pouvoir utiliser le KMS (kernel modesetting &mdash; l'option préférée) ainsi
que Xorg. Pour les puces radeon plus anciennes (avant R600), le
microprogramme est resté dans le noyau.
      </para>

      <para>
        Les GPU intégrés d'Intel de Skylake et supérieur peuvent utiliser le
microprogramme pour GuC (the microcontrôleur graphique), et le le HuC (le
microcontrôleur HEVC/H265 qui décharge vers le GPU) et DMC (microcontrôleur
pour l'affichage) pour fournir des états à basse consommation
supplémentaires. Le GuC et HuC ont un historique mouvementé dans le noyau et
les microprogrammes à jour peuvent être désactivés par défaut, en fonction
de la version de votre noyau. Des détails supplémentaires se trouvent sur
<ulink url="https://01.org/linuxgraphics/downloads/firmware/">01.org</ulink>
et <ulink url="https://wiki.archlinux.org/index.php/intel_graphics">Arch
linux</ulink>.
      </para>

      <para>
        Les GPU Nvidia à partir de Kepler ont besoin d'un microprogramme signé,
sinon le pilote nouveau est incapable de fournir l'accélération
matérielle. Nvidia a maintenant fourni des microprogrammes jusqu'à Ampere
(la séie GeForce30) dans linux-firmware. Remarquez que les horloges plus
rapides que par défaut ne sont pas activées dans le microprogramme publié.
      </para>
    </listitem>
    <listitem>
      <para>
        Mises à jour des firmware pour les interfaces réseaux filaires. La plupart
du temps elles fonctionnent sans mise à jour, mais elles fonctionneront sans
doute mieux avec un firmware à jour. Pour certains ordinateurs portables
récentes, les firmware pour le port ethernet (p. ex. rtl_nic) mais aussi
pour les périphériques bluetooth (p. ex. qca) sont
<emphasis>requis</emphasis> avant de pouvoir utiliser les réseau filaire.
      </para>
    </listitem>
    <listitem>
      <para>
        Les Firmwares pour les autres périphériques, comme le wi-fi. Ces
périphériques ne sont pas requis pour que le PC démarre, mais demande un
firmware avant que ces périphériques puissent être utilisés.
      </para>
    </listitem>
  </itemizedlist>

  <note>
    <para>
      Bien qu’ils soient inutiles pour charger un firmware fermé (blob), les
outils suivants peuvent être utiles pour déterminer, obtenir, ou préparer le
firmware à utiliser afin de le charger dans le système&nbsp;: <xref
linkend="cpio"/>, <xref linkend="git"/>, <xref linkend="pciutils"/> et <xref
linkend="wget"/>
    </para>
  </note>

  <para condition="html" role="usernotes">Notes utilisateur&nbsp;: <ulink url="&blfs-wiki;/aboutfirmware"/></para>

  <sect2 id="cpu-microcode">
    <title>Mise à jour de micro-codes pour les CPU</title>

    <para>
      En général, le micro-code peut être chargé par le BIOS ou l'UEFI, et il peut
être mis à jour en passant à une nouvelle version de celui-ci. Sur Linux,
vous pouvez également charger le micro-code depuis le noyau si vous utilisez
au moins un AMD de la famille 10h ou un plus récent (introduit après fin
2007), ou un processeur Intel de 1998 et plus (Pentium4, Core, etc), si un
micro-code mis à jour a été publié. Ces mises à jour sont actives seulement
jusqu'à ce que la machine soit éteinte, il est donc nécessaire de les
appliquer à chaque démarrage.
    </para>

    <para>
      Intel fournit des mises à jour de leur microcode pour les versions Skylake
et ultérieures de leurs processeurs quand de nouvelles vulnérabilités sont
découvertes, et l'ont fait pour les processeurs SandyBridge et ultérieurs
par le passé, bien qu'ils ne soient plus pris en charge pour les nouvelles
corrections. Les nouvelles versions de microprogramme d'AMD sont rares et ne
s'appliquent qu'à quelques modèles, bien que les fabricants de carte mères
obtiennent des mises à jour AGESA (AMD Generic Encapsulated Software
Architecture) pour changer les valeurs du BIOS, par exemple pour prendre en
charge plus de variantes de mémoire ou de nouveaux CPU.
    </para>

    <para>
      There were two ways of loading the microcode, described as 'early' and
'late'. Early loading happens before userspace has been started, late
loading happens after userspace has started. However, late loading is known
to be problematic and not supported anymore (see the kernel commit <ulink
url="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=d23d33e">
x86/microcode: Taint and warn on late loading</ulink>.)  Indeed, early
loading is needed to work around one particular erratum in early Intel
Haswell processors which had TSX enabled.  (See <ulink url=
"http://www.anandtech.com/show/8376/intel-disables-tsx-instructions-erratum-found-in-haswell-haswelleep-broadwellyi/">
Intel Disables TSX Instructions: Erratum Found in Haswell, Haswell-E/EP,
Broadwell-Y</ulink>.)  Without this update glibc can do the wrong thing in
uncommon situations.
    </para>

    <para>
      In previous versions of this book, late loading of microcode to see if it
gets applied was recommended, followed by using an initrd to force early
loading. But now that the contents of the Intel microcode tarball is
documented, and AMD microcode can be read by a Python script to determine
which machines it covers, there is no real reason to use late loading.
    </para>

    <para>
      It might be still possible to manually force late loading of microcode.  But
it may cause kernel malfunction and you should take the risk yourself.  You
will need to reconfigure your kernel for either method. The instructions
here will show you how to create an initrd for early loading. It is also
possible to build the same microcode bin file into the kernel, which allows
early loading but requires the kernel to be recompiled to update the
microcode.
    </para>

    <para>
      To confirm what processor(s) you have (if more than one, they will be
identical) look in /proc/cpuinfo. Determine the decimal values of the cpu
family, model and stepping by running the following command (it will also
report the current microcode version):
    </para>

<screen><userinput>head -n7 /proc/cpuinfo</userinput></screen>

    <para>
      Convert the cpu family, model and stepping to pairs of hexadecimal digits,
and remember the value of the <quote>microcode</quote> field.  You can now
check if there is any microcode available.
    </para>

    <para>
      If you are creating an initrd to update firmware for different machines, as
a distro would do, go down to 'Early loading of microcode' and cat all the
Intel blobs to GenuineIntel.bin or cat all the AMD blobs to
AuthenticAMD.bin. This creates a larger initrd - for all Intel machines in
the 20200609 update the size was 3.0 MB compared to typically 24 KB for one
machine.
    </para>

    <sect3 id="intel-microcode">
      <title>Micro-code Intel pour le processeur</title>

      <para>
        <!-- at one time, some skylakes had problems with a certain revision
        secure version of the microcode, for those machines which can boot it, -->
<!-- If you have a Skylake machine, please read the
        Caution in the 'Early loading of microcode' section below.-->
The first step is to get the most recent version of the Intel microcode.
This must be done by navigating to <ulink url=
'https://github.com/intel/Intel-Linux-Processor-Microcode-Data-Files/releases/'/>
and downloading the latest file there.  As of this writing the most secure
version of the microcode is microcode-20220510.  Extract this file in the
normal way, the microcode is in the <filename>intel-ucode </filename>
directory, containing various blobs with names in the form XX-YY-ZZ. There
are also various other files, and a releasenote.
      </para>

      <para>
        In the past, intel did not provide any details of which blobs had changed
versions, but now the releasenote details this.  You can compare the
microcode version in <filename>/proc/cpuinfo</filename> with the version for
your CPU model in the releasenote to know if there is an update.
      </para>

      <para>
        Le firmware récent pour les processeurs les plus anciens est fournit pour
traiter des vulnérabilités qui ont été rendue publiques, et pour certains
d'entre eux comme le <foreignphrase>Microarchitectural Data
Sampling</foreignphrase> (MDS) vous pourriez vouloir augmenter la protection
en désactivant l'hyperthreading ou en désactivant les contournements par
défaut du noyau à cause de son impact sur les temps de compilation. Lisez
bien la documentation en ligne sur <ulink url=
'https://www.kernel.org/doc/html/latest/admin-guide/hw-vuln/index.html'/>.
      </para>

      <para>
        For an Icelake mobile (described as Intel(R) Core(TM) i7-1065G7 CPU) the
relevant values are cpu family 6, model 126, stepping 5 so in this case the
required identification is 06-7e-05. The releasenote says the latest
microcode for it is versioned 0xb0.  If the value of the
<quote>microcode</quote> field in <filename>/proc/cpuinfo</filename> is 0xb0
or greater, it indicates the microcode update is already applied by the
BIOS.  Otherwise, configure the kernel to support loading Intel microcode,
and then proceed to <xref linkend='early-microcode'/>:
      </para>

<screen><literal>General Setup ---&gt;
  [*] Initial RAM filesystem and RAM disk (initramfs/initrd) support [CONFIG_BLK_DEV_INITRD]
Processor type and features  ---&gt;
  [*] CPU microcode loading support  [CONFIG_MICROCODE]
  [*]      Intel microcode loading support [CONFIG_MICROCODE_INTEL]</literal></screen>

    </sect3>

    <sect3 id="amd-microcode">
      <title>Micro-code AMD pour le processeur</title>

      <para>
        Begin by downloading a container of firmware for your CPU family from <ulink
url= '&sources-anduin-http;/linux-firmware/amd-ucode/'/>.  The family is
always specified in hex. Families 10h to 14h (16 to 20)  are in
microcode_amd.bin.  Families 15h, 16h, 17h (Zen, Zen+, Zen2) and 19h (Zen3)
have their own containers.  Very few machines are likely to get updated
microcode. There is a Python3 script at <ulink url=
'https://github.com/AMDESE/amd_ucode_info/blob/master/amd_ucode_info.py'/>.
Download that script and run it against the bin file to check which
processors have updates.
      </para>

      <para>
        For the very old Athlon(tm) II X2 in these examples the values were cpu
family 16, model 5, stepping 3 giving an identification of Family=0x10
Model=0x05 Stepping=0x03.  One line of the
<command>amd_ucode_info.py</command> script output describes the microcode
version for it:
      </para>

<screen><computeroutput>Family=0x10 Model=0x05 Stepping=0x03: Patch=0x010000c8 Length=960 bytes</computeroutput></screen>

      <para>
        If the value of the <quote>microcode</quote> field in
<filename>/proc/cpuinfo</filename> is 0x10000c8 or greater, it indicates the
BIOS has already applied the microcode update.  Otherwise, configure the
kernel to support loading AMD microcode, and then proceed to <xref
linkend='early-microcode'/>:
      </para>

<screen><literal>General Setup ---&gt;
  [*] Initial RAM filesystem and RAM disk (initramfs/initrd) support [CONFIG_BLK_DEV_INITRD]
Processor type and features  ---&gt;
  [*] CPU microcode loading support  [CONFIG_MICROCODE]
  [*]      AMD microcode loading support [CONFIG_MICROCODE_AMD]</literal></screen>
    </sect3>

    <sect3 id="early-microcode">
      <title>Chargement "tôt" du micro-code</title>

      <para>
        Si vous avez établi qu'un micro-code mis à jour est disponible pour votre
système, il est temps de le préparer pour un chargement "tôt". Cela demande
un paquet supplémentaire, <xref linkend='cpio'/> et la création d'un initrd
qui devra être ajouté à grub.cfg.
      </para>

      <para>
        L'endroit ou vous préparez l'initrd n'est pas important, et une fois
fonctionnel vous pouvez appliquer le même initrd aux versions futures de LFS
ou aux nouveaux noyaux sur cette même machine, au moins jusqu'à ce qu'une
nouvelle version du micro-code soit publiée. Utiliser la suite&nbsp;:
      </para>

<screen><userinput>mkdir -p initrd/kernel/x86/microcode
cd initrd</userinput></screen>

      <para>
        Pour une machine AMD, utilisez la commande suivante (remplacez
&lt;MYCONTAINER&gt; par le nom du paquet de votre famille de CPU)&nbsp;:
      </para>

<screen><userinput>cp -v /lib/firmware/amd-ucode/&lt;MYCONTAINER&gt; kernel/x86/microcode/AuthenticAMD.bin</userinput></screen>

      <para>
        Ou pour une machine Intel copiez le blob approprié en utilisant cette
commande&nbsp;:
      </para>

<!-- new version from 20201110 release onwards, assumed to work on all skylakes
   But complaints about previous version took some days to appear, so keep as a comment for now.
      <caution>

        <para>
          On some Skylake machines with hex Model Number '4e' (78 decimal) the
          upgrade to microcode version '0xdc' is reported to cause the machine to
          hang in early boot, and the fix is to revert to version 0xd6 which was
          first shipped in the 20191115 microcode release.
        </para>

        <para>
          At least one model '5e' Skylake does boot successfully with version
          0xdc, but Intel has now shipped a 20200616 release which is intended for
          distros which need an initrd that will boot on everyone's machine: it
          reverts both Skylake variants ('4e' and '5e') to the old 0xd6.
        </para>

        <para>
          For a Skylake which does not boot with 0xdc, reverting to 0xd6 will make
          the machine usable, but without the SRBDS mitigations.
        </para>
      </caution>-->
<screen><userinput>cp -v /lib/firmware/intel-ucode/&lt;XX-YY-ZZ&gt; kernel/x86/microcode/GenuineIntel.bin</userinput></screen>



      <para>
        Maintenant préparez l'initrd&nbsp;:
      </para>

<screen><userinput>find . | cpio -o -H newc &gt; /boot/microcode.img</userinput></screen>

      <para>
        Vous devrez également ajouter une nouvelle entrée à /boot/grub/grub.cfg et
vous devrez ajouter une ligne après la ligne linux entre les apostrophes. Si
/boot est dans une partition séparée&nbsp;:
       </para>

<screen><userinput>initrd /microcode.img</userinput></screen>

      <para>
        ou sinon&nbsp;:
      </para>

<screen><userinput>initrd /boot/microcode.img</userinput></screen>

      <para>
        Si vous avez déjà démarré avec un initrd (voir <xref linkend="initramfs"/>)
vous deviez de nouveau lancer <command>mkinitramfs</command> après avoir
placé le blob ou le conteneur approprié dans <filename
class="directory">/lib/firmware</filename> comme expliqué
ci-dessus. Autrement, vous pouvez avoir les deux initrd sur la même ligne,
comme dans <userinput>initrd /microcode.img /other-initrd.img</userinput>
(adaptez comme ci-dessus si /boot n'est pas dans une partition
séparée)&nbsp;:
      </para>

      <para>
        Vous pouvez maintenant redémarrer avec l'initrd ajouté, et ensuite utiliser
la même commande pour vérifier que le chargement «&nbsp;au plus tôt&nbsp;» a
fonctionné.
      </para>

<screen><userinput>dmesg | grep -e 'microcode' -e 'Linux version' -e 'Command line'</userinput></screen>

      <para>
        If you updated to address vulnerabilities, you can look at the output of the
<command>lscpu</command> command to see what is now reported.
      </para>

      <para>
        The places and times where early loading happens are very different in AMD
and Intel machines. First, an example of an Intel (Icelake mobile) with
early loading:
      </para>

<screen><literal>[    0.000000] microcode: microcode updated early to revision 0xb0, date = 2022-03-09
[    0.000000] Linux version 5.18.1 (xry111@xry111-X57S1) (gcc (GCC) 12.1.0, GNU ld (GNU Binutils) 2.38) #95 SMP PREEMPT_DYNAMIC Sun Jun 5 21:14:29 CST 2022
[    0.000000] Command line: BOOT_IMAGE=/vmlinuz-5.18.1-lfs-r11.1-109-systemd root=/dev/nvme0n1p7 ro
[    0.435085] microcode: sig=0x706e5, pf=0x80, revision=0xb0
[    0.435197] microcode: Microcode Update Driver: v2.2.</literal></screen>


      <para>
        Un exemple historique pour AMD&nbsp;:
      </para>

<screen><literal>[    0.000000] Linux version 4.15.3 (ken@testserver) (gcc version 7.3.0 (GCC))
               #2 SMP Sun Feb 18 02:32:03 GMT 2018
[    0.000000] Command line: BOOT_IMAGE=/vmlinuz-4.15.3-sda5 root=/dev/sda5 ro
[    0.307619] microcode: microcode updated early to new patch_level=0x010000c8
[    0.307678] microcode: CPU0: patch_level=0x010000c8
[    0.307723] microcode: CPU1: patch_level=0x010000c8
[    0.307795] microcode: Microcode Update Driver: v2.2.</literal></screen>

    </sect3>

  </sect2>

  <sect2 id="video-firmware">
    <title>Firmware pour les cartes vidéo</title>

    <sect3 id="ati-video-firmware">
      <title>Firmware pour les puces vidéo ATI (R600 et plus)</title>

      <para>
        Ces instructions NE s'appliquent PAS aux anciennes radeons avant la famille
R600. Pour elles, le firmware est dans le répertoire du noyau <filename
class='directory'>/lib/firmware/</filename>. Appliquez-les seulement si vous
prévoyez d'éviter une configuration graphique tels que Xorg et que vous
voulez vous contenter d'utiliser l'affichage 80x25 par défaut plutôt qu'un
framebuffer.
      </para>

      <para>
        Les périphériques radeon plus anciens demandaient seulement un simple blob
de 2&nbsp;Ko. Les périphériques récents ont besoin de plusieurs blobs
différents, et certains d'entre eux sont bien plus gros. La taille totale du
répertoire des firmwares radeon est de plus de 500&nbsp;Ko — sur un gros
système moderne vous pouvez probablement utiliser cet espace, mais cela
reste redondant d'installer tous les fichiers inutiles chaque fois que vous
construisez un système.
      </para>

      <para>
        Une meilleure approche est d'installer<xref linkend='pciutils'/> et ensuite
utiliser <userinput>lspci</userinput> pour identifier quel controleur VGA
est installé.
      </para>

      <para>
        Avec cette information, vérifiez la page RadeonFeature du wiki Xorg <ulink
url="http://wiki.x.org/wiki/RadeonFeature/#index5h2">Decoder ring for
engineering vs marketing names</ulink> pour identifier la famille (vous
aurez besoin de savoir cela pour identifier le pilote Xorg dans BLFS —
Southern Islands et Sea Islands utilise le pilote radeonsi) et le modèle
spécifique.
      </para>

      <para>
        Maintenant que vous savez quel contrôleur vous allez utiliser, consultez la
page <ulink
url="https://wiki.gentoo.org/wiki/Radeon#Firmware">Radeon</ulink> du wiki de
Gentoo qui a un tableau listant les blobs de firmware requis pour les
différentes puces. Notez que les puces Southern Islands et Sea Islands
utilisent des firmwares différents pour les noyaux 3.17 et supérieur par
rapport aux noyaux antérieurs. Identifiez et téléchargez les blobs requis et
ensuite installez les&nbsp;:
      </para>

<screen><userinput>mkdir -pv /lib/firmware/radeon
cp -v &lt;YOUR_BLOBS&gt; /lib/firmware/radeon</userinput></screen>

      <para>
        Il y a en fait deux façons d'installer ces firmwares. BLFS, dans le
sous-chapitre 'Configuration du noyau pour les firmwares supplémentaires' du
chapitre <xref linkend="xorg-ati-driver"/> donne un exemple de compilation
des firmwares dans le noyau - c'est légèrement plus rapide à charger, mais
utilises plus de mémoire pour le noyau. Ici nous utiliserons la méthode
alternative en faisant un module du pilote radeon. Dans votre configuration
du noyau initialisez la suite&nbsp;:
      </para>

<screen><literal>Device Drivers ---&gt;
  Graphics support ---&gt;
      Direct Rendering Manager ---&gt;
        [*] Direct Rendering Manager (XFree86 ... support)  [CONFIG_DRM]
      [M] ATI Radeon                                        [CONFIG_DRM_RADEON]</literal></screen>

      <para>
        Le chargement de plusieurs blobs volumineux dans /lib/firmware prend un
temps notable, pendant lequel l'écran est blanc. Si vous n'avez pas activé
le logo framebuffer du pingouin, ou changé la taille de la console en
utilisant une police plus grosse, cela n'a probablement pas d'importance. Si
vous le souhaitez, vous pouvez légèrement réduire le temps si vous suivez la
méthode alternative en spécifiant 'y' pour CONFIG_DRM_RADEON couvert dans
BLFS au lien précédent &mdash; vous devez spécifier chaque blob radeon utile
si vous faite cela.
      </para>

    </sect3>

    <sect3 id="amdgpu-video-firmware">
      <title>Firmware for AMD/ATI amdgpu video chips</title>

      <para>
        All video controllers using the amdgpu kernel driver require firmware,
whether you will be using the xorg amdgpu driver, the xserver's modesetting
driver, or just kernel modesetting to get a console framebuffer larger than
80x25.
      </para>

      <para>
        Install <xref linkend="pciutils"/> and use that to check the model name
(look for 'VGA compatible controller:'). If you have an APU (Accelerated
Processing Unit, i.e. CPU and video on the same chip) that will probably
tell you the name. If you have a separate amdgpu video card you will need to
search to determine which name it uses (e.g. a card described as Advanced
Micro Devices, Inc. [AMD/ATI] Baffin [Radeon RX 550 640SP / RX 560/560X]
needs Polaris11 firmware.  There is a table of "Family, Chipset name,
Product name and Firmware" at the end of the Kernel sections in <ulink
url="https://wiki.gentoo.org/wiki/AMDGPU#Known_firmware_blobs">
AMDGPU</ulink> page of the Gentoo wiki.
    </para>

    <para>
      Once you have identified the firmware name, install all the relevant files
for it. For example, the Baffin card mentioned above has 21 different
polaris11* files, APUs such as renoir and picasso have at least 12 files and
might gain more in future updates (e.g. the raven APU now has a 13th file,
raven_ta.bin).
    </para>

<screen><userinput>mkdir -pv /lib/firmware/amdgpu
cp -v &lt;YOUR_BLOBS&gt; /lib/firmware/amdgpu</userinput></screen>

    <para>
      If disk space is not a problem, you could install all the current amdgpu
firmware files and not worry about exactly which chipset is installed.
    </para>

    <para>
      You are recommended to build the kernel amdgpu driver as a module.  In your
kernel .config set at least the following options and review the other
AMDGPU options according to what hardware you are building for, e.g ACP
(Audio Co-Processor) support for some APUs,
    </para>

<screen><literal>Device Drivers ---&gt;
  Graphics support ---&gt;
      Direct Rendering Manager ---&gt;
        [*] Direct Rendering Manager (XFree86 ... support)  [CONFIG_DRM]
        [M] AMD GPU                                         [CONFIG_DRM_AMDGPU]
        Display Engine Configuration ---&gt;
          [*] AMD DC - Enable new display engine (NEW)      [CONFIG_DRM_AMD_DC]</literal></screen>

      <para>
        As written above at the end of the section on 'Firmware for ATI video
chips', loading large blobs from /lib/firmware can take a noticeable time
during which the screen will be blank. On a slow machine you might wish to
refer to the 'Kernel Configuration for additional firmware' part of <xref
linkend="xorg-amdgpu-driver"/> and compile all the required modules into the
kernel to reduce this time, at the cost of using more kernel memory.
      </para>

    </sect3>

    <sect3 id="nvidia-video-firmware">
      <title>Firmware pour les puces vidéo Nvidia</title>

      <para>
        Nvidia has released basic signed firmware for recent graphics chips, but
significantly after the chips and its own binary drivers were first
available. For other chips it has been necessary to extract the firmware
from the binary driver.
      </para>
      <para>
        For more exact information about which chips need extracted firmware, see
<ulink url=
"https://nouveau.freedesktop.org/wiki/VideoAcceleration/#firmware"/>.
      </para>

      <para>
        Tout d'abord, le pilote Nvidia doit être activé dans le noyau&nbsp;:
      </para>

<screen><literal>Device Drivers ---&gt;
  Graphics support ---&gt;
      Direct Rendering Manager ---&gt;
        &lt;*&gt; Direct Rendering Manager (XFree86 ... support)  [CONFIG_DRM]
      &lt;*/M&gt; Nouveau (NVIDIA) cards                          [CONFIG_DRM_NOUVEAU]</literal></screen>

      <para>
        If the necessary firmware is available in the <filename
class="directory">nvidia/</filename> directory of linux-firmware, copy it to
<filename class="directory">/lib/firmware/nouveau</filename>.
      </para>
      <para>
        If the firmware has not been made available in linux-firmware, for the old
chips mentioned in the nouveau wiki link above ensure you have installed
<xref linkend="python2"/> and run the following commands:
      </para>

<screen><userinput>wget https://raw.github.com/imirkin/re-vp2/master/extract_firmware.py
wget http://us.download.nvidia.com/XFree86/Linux-x86/325.15/NVIDIA-Linux-x86-325.15.run
sh NVIDIA-Linux-x86-325.15.run --extract-only
python2 extract_firmware.py
mkdir -p /lib/firmware/nouveau
cp -d nv* vuc-* /lib/firmware/nouveau/</userinput></screen>

    </sect3>
  </sect2>

  <sect2 id="nic-firmware">
    <title>Firmware pour les interfaces réseaux</title>

    <para>
      Le noyau aime charger des firmware pour quelques pilotes réseaux,
particulièrement ceux du répertoire Realtek (/lib/linux-firmware/rtl_nic/),
mais il apparaît généralement que cela fonctionne sans. Cependant, vous
pouvez démarrer le noyau, vérifier si dmesg contient des messages à propos
de firmwares manquants, et si nécessaire télécharger les firmwares et les
mettre dans un répertoire spécifique dans <filename
class="directory">/lib/firmware</filename> afin qu'ils puissent être trouvés
lors des prochains démarrages. Notez qu'avec les noyaux actuels cela
fonctionne que le pilote soit compilé dedans ou construit comme un module,
il n'est pas utile de construire ce firmware dans le noyau. Ici un exemple
ou le pilote R8169 a été compilé dedans mais le firmware n'est pas
disponible. Une fois que le firmware a été fourni, il n'y est plus fait
mention dans les démarrages suivants.
    </para>

<screen><literal>dmesg | grep firmware | grep r8169
[    7.018028] r8169 0000:01:00.0: Direct firmware load for rtl_nic/rtl8168g-2.fw failed with error -2
[    7.018036] r8169 0000:01:00.0 eth0: unable to load firmware patch rtl_nic/rtl8168g-2.fw (-2)</literal></screen>

  </sect2>

  <sect2 id="other-firmware">
    <title>Firmware pour les autres périphériques</title>

    <para>
      Pour identifier le bon firmware vous devrez normallement install <xref
linkend='pciutils'/> puis utiliser <userinput>lspci</userinput> pour
identifier le matériel. Vous devriez ensuite chercher en ligne pour vérifier
le module qu’il utilise, quel firmware et où obtenir le firmware &mdash; ils
ne sont pas tous dans linux-firmware.
    </para>

    <para>
      Si possible, vous pouvez commencer par utiliser une connexion filaire quand
vous démarrez la première fois votre système LFS. Pour utiliser une
connexion sans fils vous aurez besoin d'utiliser des outils réseau tel que
<xref linkend='wireless_tools'/> et <xref linkend='wpa_supplicant'/>.
    </para>

    <para>
      Plusieurs pays ont des réglementations différentes sur l'utilisation du
spectre radio des appareils sans-fil. Vous pouvez installer un
microprogramme pour qu'un appareil sans-fil obéisse aux réglementations sur
les émissions, pour ne pas être inquiété par les autorités ou découvrir que
votre wifi brouille les fréquences d'autres appareils (par exemple des
télécommandes). Le microprogramme qui contient la base de régulations se
trouve sur <ulink url =
'https://kernel.org/pub/software/network/wireless-regdb/'/>. Pour
l'installer, extrayez simplement <filename>regulatory.db</filename> et
<filename>regulatory.db.p7s</filename> de l'archive vers <filename
class="directory">/lib/firmware</filename>. Le point d'accès envoie un code
de pays à votre antenne, et <xref linkend='wpa_supplicant'/> le dit au noyau
qui charge les réglementations de ce pays à partir de
<filename>regulatory.db</filename> et les met en place.
    </para>

    <para>
      Les firmwares peuvent aussi être utiles pour d'autres périphériques comme
les contrôleurs SCSI, les adaptateurs Bluetooth, ou les enregistreurs
TV. Les mêmes principes s'appliquent.
    </para>

  </sect2>

</sect1>
