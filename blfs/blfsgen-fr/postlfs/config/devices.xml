<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../../general.ent">
  %general-entities;
]>

<sect1 id="postlfs-devices" xreflabel="À propos des périphériques">
  <?dbhtml filename="devices.html"?>


  <title>À propos des périphériques</title>

  <indexterm zone="postlfs-devices">
    <primary sortas="e-etc-udev-rules">/etc/udev/rules.d</primary>
  </indexterm>

  <para>
    Bien que la plupart des périphériques dont ont besoin les paquets de BLFS
ont été correctement paramétrés par <application>udev</application> en
utilisant les règles par défaut installées par LFS dans <filename
class="directory">/etc/udev/rules.d</filename>, il y a des cas où il faut
modifier ou ajouter des règles.
  </para>

  <sect2>
    <title>Cartes sons multiples</title>

    <para>
      S'il y a plusieurs cartes sons sur un système, la carte son
«&nbsp;default&nbsp;» (par défaut) devient aléatoire. La méthode pour
établir un ordre dans les cartes sons dépend du fait que les pilotes soient
en modules ou pas. Si les pilotes de la carte son sont compilés dans le
noyau, leur contrôle s'effectue via des paramètres de la ligne de commande
du noyau dans <filename>/boot/grub/grub.cfg</filename>. Par exemple, si un
système contient une carte FM801 et une carte PCI SoundBlaster, ce qui suit
peut être ajouté à la ligne de commande&nbsp;:
    </para>

<screen><literal>snd-fm801.index=0 snd-ens1371.index=1</literal></screen>

    <para>
      Si les pilotes de la carte son sont construits en modules, on peut établir
l'ordre dans le fichier <filename>/etc/modprobe.conf</filename> avec&nbsp;:
    </para>

<screen><literal>options snd-fm801 index=0
options snd-ens1371 index=1</literal></screen>

  </sect2>

  <sect2 id="usb-device-issues">
    <title>Problèmes sur les périphériques USB</title>

    <para>
      Les périphériques USB ont habituellement deux types de nœuds de
périphériques associés avec eux.
    </para>

    <para>
      Le premier type est créé par le pilote du périphérique spécifique
(usb_storage/sd_mod ou usblp) dans le noyau. Par exemple, un périphérique de
stockage USB peut être /dev/sdb, et une imprimante USB peut être
/dev/usb/lp0. Ces nœuds de périphériques existent seulement quand le pilote
du périphérique spécifique est chargé.
    </para>

    <para>
      Le second type de nœud de périphériques (/dev/bus/usb/BBB/DDD, ou BBB est le
numéro du bus et DDD est le numéro du périphérique) est créé chaque fois que
le périphérique n'a pas de driver dans le noyau. En utilisant ces nœuds de
périphérique USB "directs", une application peut échanger arbitrairement des
paquets USB avec le périphérique, c'est-à-dire, court-circuiter le possible
pilote existant du noyau.
    </para>

    <para>
      Access to raw USB device nodes is needed when a userspace program is acting
as a device driver. However, for the program to open the device
successfully, the permissions have to be set correctly. By default, due to
security concerns, all raw USB devices are owned by user root and group
root, and have 0664 permissions (the read access is needed, e.g., for lsusb
to work and for programs to access USB hubs). Packages (such as SANE and
libgphoto2) containing userspace USB device drivers also ship udev rules
that change the permissions of the controlled raw USB devices. That is,
rules installed by SANE change permissions for known scanners, but not
printers.  If a package maintainer forgot to write a rule for your device,
report a bug to both BLFS (if the package is there) and upstream, and you
will need to write your own rule.
    </para>

    <para>
      Before Linux-2.6.15, raw USB device access was performed not with
/dev/bus/usb/BBB/DDD device nodes, but with /proc/bus/usb/BBB/DDD
pseudofiles. Some applications still use only this deprecated technique and
can't use the new device nodes.  They cannot work with Linux kernel version
3.5 or newer.  If you need to run such an application, contact the developer
of it for a fix.
    </para>

  </sect2>

  <sect2>
    <title>Attributs de périphériques d'Udev</title>

    <para>
      Le peaufinage des attributs de périphériques tels que le nom du groupe et
les droits est possible en créant des règles <application>udev</application>
supplémentaires, correspondant à quelque chose de ce genre. On peut trouver
le fabricant et le produit en cherchant les entrées du répertoire <filename
class='directory'>/sys/devices</filename> ou en utilisant
<command>udevinfo</command> après avoir attaché le périphérique. Voir la
documentation dans le répertoire d'<application>udev</application> actuel
<filename class='directory'>/usr/share/doc</filename> pour des détails.
    </para>

<screen><literal>SUBSYSTEM=="usb_device", SYSFS{idVendor}=="05d8", SYSFS{idProduct}=="4002", \
  GROUP:="scanner", MODE:="0660"</literal></screen>

    <note>
      <para>
        On n'utilise la ligne ci-dessus qu'à des fins descriptives.  Les règles
d'analyse d'<application>udev</application> sont mises en place lors de
l'installation de <xref linkend="sane"/>.
      </para>
    </note>

  </sect2>





  <!--
  <sect2>

    <title>Multiple Network Interfaces</title>


  </sect2>
-->
<!-- These instructions are invalid on systemd because we don't use bootscripts.
     In addition, we should probably verify that these are valid on SysV too.-->
<sect2 revision="sysv">
    <title>Périphériques pour les serveurs</title>

    <para>
      Dans certains cas, il est utile de désactiver
<application>udev</application> complètement et de créer des périphériques
statiques. Les serveurs sont un exemple de cette situation. Est-ce qu'un
serveur a besoin de la possibilité de gérer des périphériques
dynamiques&nbsp;? Seul l'administrateur système peut répondre à cette
question, mais dans de nombreux cas, la réponse est non.
    </para>

    <para>
      Si vous ne désirez pas de périphériques dynamiques, vous devez créer des
périphériques statiques sur le système. Dans la configuration par défaut, le
script de démarrage <filename>/etc/rc.d/rcS.d/S10udev</filename> monte une
partition <systemitem class="filesystem">tmpfs</systemitem> dans le
répertoire <filename class="directory">/dev</filename>. Ce problème peut
être résolu en montant temporairement la partition racine&nbsp;:
    </para>

    <warning>
      <para>
        Si vous ne suivez pas rigoureusement les instructions ci-dessous, votre
système pourrait ne plus pouvoir démarrer.
      </para>
    </warning>


<screen><userinput>mount --bind / /mnt
cp -a /dev/* /mnt/dev
rm /etc/rc.d/rcS.d/{S10udev,S50udev_retry}
umount /mnt</userinput></screen>

    <para>
      Dès lors, le système utilisera des périphériques statiques lors du prochain
redémarrage. Créez les périphériques supplémentaires désirés en utilisant
<command>mknod</command>.
    </para>

    <para>
      Si vous voulez restaurer les périphériques dynamiques, recréez les liens
symboliques <filename>/etc/rc.d/rcS.d/{S10udev,S50udev_retry}</filename> et
redémarrez de nouveau. Il n'est pas nécessaire de supprimer les
périphériques statiques (console et null sont toujours nécessaires) car ils
sont recouverts par la partition <systemitem
class="filesystem">tmpfs</systemitem>.  L'utilisation du disque par des
périphériques est négligeable (environ 20&ndash;30 octets par entrée).
    </para>

  </sect2>

  <sect2 id="dev-dvd">
    <title>Périphériques pour les lecteurs DVD</title>

    <para>
      Si le processus de démarrage initial ne met pas en place le périphérique
<systemitem>/dev/dvd</systemitem> correctement, cela peut être fait avec les
modifications suivantes des règles udev par défaut. En tant qu'utilisateur
<systemitem class="username">root</systemitem>, lancez&nbsp;:
    </para>

<screen><userinput>sed '1d;/SYMLINK.*cdrom/ a\
KERNEL=="sr0", ENV{ID_CDROM_DVD}=="1", SYMLINK+="dvd", OPTIONS+="link_priority=-100"' \
/lib/udev/rules.d/60-cdrom_id.rules > /etc/udev/rules.d/60-cdrom_id.rules</userinput></screen>

  </sect2>

</sect1>
