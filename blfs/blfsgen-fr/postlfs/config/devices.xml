<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../../general.ent">
  %general-entities;
]>

<sect1 id="postlfs-devices" xreflabel="À propos des périphériques">
  <?dbhtml filename="devices.html"?>

  <sect1info>
<date>$Date$</date></sect1info>

  <title>À propos des périphériques</title>

  <indexterm zone="postlfs-devices">
    <primary sortas="e-etc-udev-rules">/etc/udev/rules.d</primary>
  </indexterm>

  <para>
    Bien que la plupart des périphériques dont ont besoin les paquets de BLFS
ont été correctement paramétrés par <application>udev</application> en
utilisant les règles par défaut installées par LFS dans <filename
class="directory">/etc/udev/rules.d</filename>, il y a des cas où il faut
modifier ou ajouter des règles.
  </para>

  <para condition="html" role="usernotes">Notes utilisateur&nbsp;: <ulink url="&blfs-wiki;/aboutdevices"/></para>

  <sect2>
    <title>Cartes sons multiples</title>

    <para>
      S'il y a plusieurs cartes sons sur un système, la carte son
«&nbsp;default&nbsp;» (par défaut) devient aléatoire. La méthode pour
établir un ordre dans les cartes sons dépend du fait que les pilotes soient
en modules ou pas. Si les pilotes de la carte son sont compilés dans le
noyau, leur contrôle s'effectue via des paramètres de la ligne de commande
du noyau dans <filename>/boot/grub/grub.cfg</filename>. Par exemple, si un
système contient une carte FM801 et une carte PCI SoundBlaster, ce qui suit
peut être ajouté à la ligne de commande&nbsp;:
    </para>

<screen><literal>snd-fm801.index=0 snd-ens1371.index=1</literal></screen>

    <para>
      Si les pilotes de la carte son sont construits en modules, on peut établir
l'ordre dans le fichier <filename>/etc/modprobe.conf</filename> avec&nbsp;:
    </para>

<screen><literal>options snd-fm801 index=0
options snd-ens1371 index=1</literal></screen>

  </sect2>

  <sect2 id="usb-device-issues">
    <title>Problèmes sur les périphériques USB</title>

    <para>
      Les périphériques USB ont habituellement deux types de nœuds de
périphériques associés avec eux.
    </para>

    <para>
      Le premier type est créé par le pilote du périphérique spécifique
(usb_storage/sd_mod ou usblp) dans le noyau. Par exemple, un périphérique de
stockage USB peut être /dev/sdb, et une imprimante USB peut être
/dev/usb/lp0. Ces nœuds de périphériques existent seulement quand le pilote
du périphérique spécifique est chargé.
    </para>

    <para>
      Le second type de nœud de périphériques (/dev/bus/usb/BBB/DDD, ou BBB est le
numéro du bus et DDD est le numéro du périphérique) est créé chaque fois que
le périphérique n'a pas de driver dans le noyau. En utilisant ces nœuds de
périphérique USB "directs", une application peut échanger arbitrairement des
paquets USB avec le périphérique, c'est-à-dire, court-circuiter le possible
pilote existant du noyau.
    </para>

    <para>
      Accéder aux nœuds périphériques USB directement est nécessaire quand un
programme de l'espace utilisateur est considéré comme un pilote de
périphérique.  Cependant, pour que le programme ouvre avec succès le
périphérique, les permissions doivent être initialisées correctement. Par
défaut, pour des considérations de sécurité, tous les périphériques USB
directs appartiennent à l'utilisateur root et au groupe usb, et ont la
permission 0664 (l'accès en lecture est nécessaire, par exemple pour que
lsusb puisse travailler et pour les programmes d'accès aux concentrateurs
USB). Des paquets (comme SANE et libgphoto2) contenant un pilote de
périphérique USB dans l'espace utilisateur utilisent aussi les règles udev
pour changer les permissions des périphériques USB contrôlés. Ce qui fait
que les règles installées par SANE changent les permissions pour les
scanners reconnus, mais pas pour les imprimantes. Si le mainteneur du paquet
oublie d'écrire une règle pour votre périphérique, signalez le bogue à BLFS
(si le paquet est ici) et en amont, et vous aurez besoin d'écrire votre
propre règle.
    </para>

    <para>
      Il y a une situation ou un contrôle d'accès fin avec des règles udev
pré-générées ne marche pas. Nommément, les émulateurs de PC comme KVM, QEMU
et VirtualBox utilisent des nœuds de périphérique USB direct pour les
périphériques USB arbitrairement présents dans le système d'exploitation
invité (note&nbsp;: des correctifs sont nécessaires pour que cela fonctionne
dans les points de montage obsolètes /proc/bus/usb décris
précédemment). Naturellement, les mainteneurs de ces paquets ne peuvent pas
connaître quels périphériques USB seront connectés sur le système
d'exploitation invité. Vous pouvez soit écrire des règles udev séparées pour
tous les périphériques USB nécessaires vous même, soit utiliser les règles
par défaut du groupe "usb", les membres de celui-ci pouvant envoyer des
commandes arbitraires pour tous périphériques USB.
    </para>

    <para>
      Avant Linux-2.6.15, l'accès direct aux périphériques USB n'était pas géré
avec les nœuds de périphériques /dev/bus/usb/BBB/DDD, mais avec des
pseudo-fichiers /proc/bus/usb/BBB/DDD. Quelques applications (par exemple.,
VMware Workstation)  semblent utiliser seulement cette technique obsolète et
ne peuvent pas utiliser les nouveaux nœuds de périphériques. Pour qu'elles
puissent fonctionner, utiliser le groupe "usb", mais rappelez-vous que les
membres ont un accès complet à tous les périphériques USB.  Pour créer
l'entrée fstab pour le fichier système obsolète usbfs:
    </para>

<screen><literal>usbfs  /proc/bus/usb  usbfs  devgid=14,devmode=0660  0  0</literal></screen>

    <note>
      <para>
        Ajouter les utilisateurs dans le groupe "usb" est par nature pas sécurisé,
car cela court-circuite les restrictions d'accès imposées par les pilotes
spécifiques des nœuds de périphériques USB. Par nature, ils peuvent lire des
données sensibles des disques USB sans être dans le groupe "disque". Évitez
d'ajouter des utilisateurs dans ce groupe si vous le pouvez.
    </para>
    </note>

  </sect2>

  <sect2>
    <title>Attributs de périphériques d'Udev</title>

    <para>
      Le peaufinage des attributs de périphériques tels que le nom du groupe et
les droits est possible en créant des règles <application>udev</application>
supplémentaires, correspondant à quelque chose de ce genre. On peut trouver
le fabricant et le produit en cherchant les entrées du répertoire <filename
class='directory'>/sys/devices</filename> ou en utilisant
<command>udevinfo</command> après avoir attaché le périphérique. Voir la
documentation dans le répertoire d'<application>udev</application> actuel
<filename class='directory'>/usr/share/doc</filename> pour des détails.
    </para>

<screen><literal>SUBSYSTEM=="usb_device", SYSFS{idVendor}=="05d8", SYSFS{idProduct}=="4002", \
  GROUP:="scanner", MODE:="0660"</literal></screen>

    <note>
      <para>
        On n'utilise la ligne ci-dessus qu'à des fins descriptives.  Les règles
d'analyse d'<application>udev</application> sont mises en place lors de
l'installation de <xref linkend="sane"/>.
      </para>
    </note>

  </sect2>





  <!--
  <sect2>

    <title>Multiple Network Interfaces</title>


  </sect2>
-->
<!-- These instructions are invalid on systemd because we don't use bootscripts.
     In addition, we should probably verify that these are valid on SysV too.-->
<sect2 revision="sysv">
    <title>Périphériques pour les serveurs</title>

    <para>
      Dans certains cas, il est utile de désactiver
<application>udev</application> complètement et de créer des périphériques
statiques. Les serveurs sont un exemple de cette situation. Est-ce qu'un
serveur a besoin de la possibilité de gérer des périphériques
dynamiques&nbsp;? Seul l'administrateur système peut répondre à cette
question, mais dans de nombreux cas, la réponse est non.
    </para>

    <para>
      Si vous ne désirez pas de périphériques dynamiques, vous devez créer des
périphériques statiques sur le système. Dans la configuration par défaut, le
script de démarrage <filename>/etc/rc.d/rcS.d/S10udev</filename> monte une
partition <systemitem class="filesystem">tmpfs</systemitem> dans le
répertoire <filename class="directory">/dev</filename>. Ce problème peut
être résolu en montant temporairement la partition racine&nbsp;:
    </para>

    <warning>
      <para>
        Si vous ne suivez pas rigoureusement les instructions ci-dessous, votre
système pourrait ne plus pouvoir démarrer.
      </para>
    </warning>


<screen><userinput>mount --bind / /mnt
cp -a /dev/* /mnt/dev
rm /etc/rc.d/rcS.d/{S10udev,S50udev_retry}
umount /mnt</userinput></screen>

    <para>
      Dès lors, le système utilisera des périphériques statiques lors du prochain
redémarrage. Créez les périphériques supplémentaires désirés en utilisant
<command>mknod</command>.
    </para>

    <para>
      Si vous voulez restaurer les périphériques dynamiques, recréez les liens
symboliques <filename>/etc/rc.d/rcS.d/{S10udev,S50udev_retry}</filename> et
redémarrez de nouveau. Il n'est pas nécessaire de supprimer les
périphériques statiques (console et null sont toujours nécessaires) car ils
sont recouverts par la partition <systemitem
class="filesystem">tmpfs</systemitem>.  L'utilisation du disque par des
périphériques est négligeable (environ 20&ndash;30 octets par entrée).
    </para>

  </sect2>

  <sect2 id="dev-dvd">
    <title>Périphériques pour les lecteurs DVD</title>

    <para>
      Si le processus de démarrage initial ne met pas en place le périphérique
<systemitem>/dev/dvd</systemitem> correctement, cela peut être fait avec les
modifications suivantes des règles udev par défaut. En tant qu'utilisateur
<systemitem class="username">root</systemitem>, lancez&nbsp;:
    </para>

<screen><userinput>sed '1d;/SYMLINK.*cdrom/ a\
KERNEL=="sr0", ENV{ID_CDROM_DVD}=="1", SYMLINK+="dvd", OPTIONS+="link_priority=-100"' \
/lib/udev/rules.d/60-cdrom_id.rules > /etc/udev/rules.d/60-cdrom_id.rules</userinput></screen>

  </sect2>

</sect1>
