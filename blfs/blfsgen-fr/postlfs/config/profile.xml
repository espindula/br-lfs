<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../../general.ent">
  %general-entities;
]>

<sect1 id="postlfs-config-profile" xreflabel="Les fichiers de démarrage du shell Bash">
  <?dbhtml filename="profile.html"?>


  <title>Les fichiers de démarrage du shell Bash</title>

  <para>
    Le programme de shell <filename>/bin/bash</filename> (auquel on se référera
ci-après sous le nom de «&nbsp;shell&nbsp;» utilise un ensemble de fichiers
de démarrage pour aider à la création d'un environnement. Chaque fichier a
une utilisation spécifique et il peut concerner différemment la connexion et
les environnements interactifs. Les fichiers du répertoire <filename
class="directory">/etc</filename> fournissent en général les paramètres
globaux. Si un fichier équivalent existe dans votre répertoire home, il peut
remplacer les paramètres globaux.
  </para>

  <para>
    Un shell de connexion interactif démarre après une connexion réussie, en
utilisant <filename>/bin/login</filename>, en lisant le fichier
<filename>/etc/passwd</filename>. Cet appel du shell lit normalement
<filename>/etc/profile</filename> et son équivalent privé
<filename>~/.bash_profile</filename> (ou <filename>~/.profile</filename>
s'il est appelé par <command>/bin/sh</command>) au démarrage.
  </para>

  <para>
    Un shell de non-connexion interactif démarre normalement en ligne de
commande en utilisant un programme de shell (comme
<prompt>[prompt]$</prompt><command>/bin/bash</command>) ou par la commande
<command>/bin/su</command>. Un shell de non-connexion interactif démarre
également avec un programme de terminal tel que <command>xterm</command> ou
<command>konsole</command> depuis un environnement graphique. Ce type
d'appel de shell copie normalement l'environnement parent puis lit le
fichier <filename>~/.bashrc</filename> de l'utilisateur pour des
instructions de configuration de démarrage supplémentaires.
  </para>

  <para>
    Un shell non interactif est présent en général lorsqu'un script shell
s'exécute. Il n'est pas interactif car il exécute un script et n'attend pas
d'entrée de l'utilisateur entre les commandes. Pour ces appels de shell,
seul l'environnement hérité du shell parent est utilisé.
  </para>

  <para>
    Le fichier <filename>~/.bash_logout</filename> n'est pas utilisé pour un
appel du shell. Il est lu et exécuté lorsqu'un utilisateur quitte un shell
de connexion interactif.
  </para>

  <para>
    De nombreuses distributions utilisent <filename>/etc/bashrc</filename> pour
l'initialisation pour tout le système de shells de non-connexion. Ce fichier
est en général appelé depuis le fichier <filename>~/.bashrc</filename> de
l'utilisateur et il n'est pas construit directement dans
<command>bash</command> lui-même. On suit cette convention dans cette
section.
  </para>

  <para>
    Pour plus d'informations, voir <command>info bash</command> -- <emphasis
role="strong">Nodes: Bash Startup Files et Interactive Shells</emphasis>.
  </para>

  <note>
    <para>
      La plupart des instructions ci-dessous sont utilisées pour créer des
fichiers qui se trouvent dans la structure de répertoires <filename
class='directory'>/etc</filename>, ce qui implique que vous exécutiez les
commandes en tant qu'utilisateur <systemitem
class='username'>root</systemitem>. Si vous optez plutôt pour la création
des fichiers dans le répertoire home de l'utilisateur, vous devriez lancer
les commandes en tant qu'utilisateur non privilégié.
    </para>
  </note>

  <para condition="html" role="usernotes">Notes des rédacteurs&nbsp;: <ulink
url="&blfs-wiki;/bash-shell-startup-files"/></para>

  <sect2 id="etc-profile-profile">
    <title>/etc/profile</title>

    <indexterm zone="postlfs-config-profile etc-profile-profile">
      <primary sortas="e-etc-profile">/etc/profile</primary>
    </indexterm>

    <para>
      Voici un <filename>/etc/profile</filename> de base. Ce fichier démarre en
paramétrant des fonctions d'aide et quelques paramètres de base.  Il
spécifie des paramètres d'historique de <command>bash</command> et, pour des
raisons de sécurité, il désactive la conservation d'un fichier d'historique
permanent pour l'utilisateur <systemitem
class="username">root</systemitem>.  Il paramètre aussi une invite
utilisateur par défaut. Il appelle ensuite de petits scripts à finalité
unique dans le répertoire <filename
class='directory'>/etc/profile.d</filename> pour fournir la plupart de
l'initialisation.
    </para>

    <para>
      Pour plus d'informations sur les séquences d'échappement que vous pouvez
utiliser pour votre invite (à savoir la variable d'environnement
<envar>PS1</envar>) voir <command>info bash</command> -- <emphasis
role="strong">Node: Printing a Prompt</emphasis>.
    </para>

<screen role="root"><?dbfo keep-together="auto"?><userinput>cat &gt; /etc/profile &lt;&lt; "EOF"
<literal># Début de /etc/profile
# Écrit pour Beyond Linux From Scratch
# par James Robertson &lt;jameswrobertson@earthlink.net&gt;
# modifications de Dagmar d'Surreal &lt;rivyqntzne@pbzpnfg.arg&gt;

# Variables d'environnement du système et programmes de démarrage.

# Les alias et les fonctions du système devraient aller dans /etc/bashrc.  Les variables
# d'environnement et les programmes personnels devraient aller dans
# ~/.bash_profile.  Les alias et fonctions personnels devraient aller dans
# ~/.bashrc.

# Fonctions pour aider à gérer les chemins de recherche.  Le second argument est le nom de
# la variable de chemin à modifier (par défaut : PATH)
pathremove () {
        local IFS=':'
        local NEWPATH
        local DIR
        local PATHVARIABLE=${2:-PATH}
        for DIR in ${!PATHVARIABLE} ; do
                if [ "$DIR" != "$1" ] ; then
                  NEWPATH=${NEWPATH:+$NEWPATH:}$DIR
                fi
        done
        export $PATHVARIABLE="$NEWPATH"
}

pathprepend () {
        pathremove $1 $2
        local PATHVARIABLE=${2:-PATH}
        export $PATHVARIABLE="$1${!PATHVARIABLE:+:${!PATHVARIABLE}}"
}

pathappend () {
        pathremove $1 $2
        local PATHVARIABLE=${2:-PATH}
        export $PATHVARIABLE="${!PATHVARIABLE:+${!PATHVARIABLE}:}$1"
}

export -f pathremove pathprepend pathappend

# Indique le chemin de recherche
export PATH=/usr/bin

# Tentative de rétro-compatibilité avec LFS inférieur à 11
if [ ! -L /bin ]; then
        pathappend /bin
fi

if [ $EUID -eq 0 ] ; then
        pathappend /usr/sbin
        if [ ! -L /sbin ]; then
                pathappend /sbin
        fi
        unset HISTFILE
fi

# Mise en place de certaines variables d'environnement.
export HISTSIZE=1000
export HISTIGNORE="&amp;:[bf]g:exit"

# Set some defaults for graphical systems
export XDG_DATA_DIRS=${XDG_DATA_DIRS:-/usr/share/}
export XDG_CONFIG_DIRS=${XDG_CONFIG_DIRS:-/etc/xdg/}
export XDG_RUNTIME_DIR=${XDG_RUNTIME_DIR:-/tmp/xdg-$USER}

# Mise en place d'une invite rouge pour root et verte pour les utilisateurs.
NORMAL="\[\e[0m\]"
RED="\[\e[1;31m\]"
GREEN="\[\e[1;32m\]"
if [[ $EUID == 0 ]] ; then
  PS1="$RED\u [ $NORMAL\w$RED ]# $NORMAL"
else
  PS1="$GREEN\u [ $NORMAL\w$GREEN ]\$ $NORMAL"
fi

for script in /etc/profile.d/*.sh ; do
        if [ -r $script ] ; then
                . $script
        fi
done

unset script RED GREEN NORMAL

# Fin de /etc/profile</literal>
EOF</userinput></screen>

    <sect3 id="etc-profile.d">
      <title>Le répertoire /etc/profile.d</title>

      <indexterm zone="postlfs-config-profile etc-profile.d">
        <primary sortas="e-etc-profile.d">/etc/profile.d</primary>
      </indexterm>

      <para>
        Maintenant créez le répertoire <filename
class='directory'>/etc/profile.d</filename>, où sont mis les scripts
d'initialisation individuels&nbsp;:
      </para>

<screen role="root"><userinput>install --directory --mode=0755 --owner=root --group=root /etc/profile.d</userinput></screen>

    </sect3>

    <sect3 id="etc-profile.d-bash-completion.sh">
      <title>/etc/profile.d/bash_completion.sh</title>

      <indexterm zone="postlfs-config-profile etc-profile.d-bash-completion.sh">
        <primary sortas="e-etc-profile.d-bash-completion.sh">/etc/profile.d/bash_completion.sh</primary>
      </indexterm>

      <note>
        <para>
          L'utilisation du script de complétion bash ci-dessous ne fait pas
consensus. Tous les utilisateurs ne l'aiment pas. Il ajoute de nombreuses
(plus de 1000) lignes à l'environnement bash et rend difficile d'utiliser la
commande «&nbsp;set&nbsp;» pour examiner des variables d'environnement
simples. Passer ce script n'interfère pas avec la capacité de bash
d'utiliser la touche de tabulation pour compléter les noms de fichiers.
        </para>
      </note>

      <para>
        Ce script importe les scripts de complétion bash, installé par beaucoup
d'autres paquets BLFS pour permettre la complétion de la ligne de commande
avec TAB.
      </para>

<screen role="root"><userinput>cat &gt; /etc/profile.d/bash_completion.sh &lt;&lt; "EOF"
<literal># Begin /etc/profile.d/bash_completion.sh
# Import bash completion scripts

# If the bash-completion package is installed, use its configuration instead
if [ -f /usr/share/bash-completion/bash_completion ]; then

  # Check for interactive bash and that we haven't already been sourced.
  if [ -n "${BASH_VERSION-}" -a -n "${PS1-}" -a -z "${BASH_COMPLETION_VERSINFO-}" ]; then

    # Check for recent enough version of bash.
    if [ ${BASH_VERSINFO[0]} -gt 4 ] || \
       [ ${BASH_VERSINFO[0]} -eq 4 -a ${BASH_VERSINFO[1]} -ge 1 ]; then
       [ -r "${XDG_CONFIG_HOME:-$HOME/.config}/bash_completion" ] &amp;&amp; \
            . "${XDG_CONFIG_HOME:-$HOME/.config}/bash_completion"
       if shopt -q progcomp &amp;&amp; [ -r /usr/share/bash-completion/bash_completion ]; then
          # Source completion code.
          . /usr/share/bash-completion/bash_completion
       fi
    fi
  fi

else

  # bash-completions are not installed, use only bash completion directory
  if shopt -q progcomp; then
    for script in /etc/bash_completion.d/* ; do
      if [ -r $script ] ; then
        . $script
      fi
    done
  fi
fi

# End /etc/profile.d/bash_completion.sh</literal>
EOF</userinput></screen>
      <para>
        Assurez-vous que le répertoire existe&nbsp;:
      </para>

<screen role="root"><userinput>install --directory --mode=0755 --owner=root --group=root /etc/bash_completion.d</userinput></screen>

      <para>
        Pour une installation plus complète, voir <ulink
url="&blfs-wiki;/bash-shell-startup-files#bash-completions"/>.
      </para>

    </sect3>

    <sect3 id="etc-profile.d-dircolors.sh">
      <title>/etc/profile.d/dircolors.sh</title>

      <indexterm zone="postlfs-config-profile etc-profile.d-dircolors.sh">
        <primary sortas="e-etc-profile.d-dircolors.sh">/etc/profile.d/dircolors.sh</primary>
      </indexterm>

      <para>
        Ce script utilise les fichiers <filename>~/.dircolors</filename> et
<filename>/etc/dircolors</filename> pour contrôler les couleurs des noms de
fichiers dans la liste du contenu d'un répertoire. Ils contrôlent la sortie
en couleurs de commandes telles que <command>ls --color</command>.
L'explication de la façon d'initialiser ces fichiers se trouvent à la fin de
cette section.
      </para>

<screen role="root"><userinput>cat &gt; /etc/profile.d/dircolors.sh &lt;&lt; "EOF"
<literal># Setup for /bin/ls and /bin/grep to support color, the alias is in /etc/bashrc.
if [ -f "/etc/dircolors" ] ; then
        eval $(dircolors -b /etc/dircolors)
fi

if [ -f "$HOME/.dircolors" ] ; then
        eval $(dircolors -b $HOME/.dircolors)
fi

alias ls='ls --color=auto'
alias grep='grep --color=auto'</literal>
EOF</userinput></screen>

    </sect3>

    <sect3 id="extrapaths.sh">
      <title>/etc/profile.d/extrapaths.sh</title>

      <indexterm zone="postlfs-config-profile extrapaths.sh">
        <primary sortas="e-etc-profile.d-extrapaths.sh">/etc/profile.d/extrapaths.sh</primary>
      </indexterm>

      <para>
        Ce script ajoute plusieurs chemins utiles aux variables d'environnement
<envar>PATH</envar> et peut être utilisé pour personnaliser les autres
variables d'environnement relatives à PATH (par exemple LD_LIBRARY_PATH,
etc) qui peuvent être utiles pour tous les utilisateurs.
      </para>

<screen role="root"><userinput>cat &gt; /etc/profile.d/extrapaths.sh &lt;&lt; "EOF"
<literal>if [ -d /usr/local/lib/pkgconfig ] ; then
        pathappend /usr/local/lib/pkgconfig PKG_CONFIG_PATH
fi
if [ -d /usr/local/bin ]; then
        pathprepend /usr/local/bin
fi
if [ -d /usr/local/sbin -a $EUID -eq 0 ]; then
        pathprepend /usr/local/sbin
fi

if [ -d /usr/local/share ]; then
        pathprepend /usr/local/share XDG_DATA_DIRS
fi

# Set some defaults before other applications add to these paths.
pathappend /usr/share/man  MANPATH
pathappend /usr/share/info INFOPATH</literal>
EOF</userinput></screen>

    </sect3>

    <sect3 id="readline.sh">
      <title>/etc/profile.d/readline.sh</title>

      <indexterm zone="postlfs-config-profile readline.sh">
        <primary sortas="e-etc-profile.d-readline.sh">/etc/profile.d/readline.sh</primary>
      </indexterm>

      <para>
        Ce script règle le fichier de configuration <filename>inputrc</filename> par
défaut. Si l'utilisateur n'a pas de paramètres individuels, il utilise le
fichier global.
      </para>

<screen role="root"><userinput>cat &gt; /etc/profile.d/readline.sh &lt;&lt; "EOF"
<literal># Set up the INPUTRC environment variable.
if [ -z "$INPUTRC" -a ! -f "$HOME/.inputrc" ] ; then
        INPUTRC=/etc/inputrc
fi
export INPUTRC</literal>
EOF</userinput></screen>

    </sect3>

    <sect3 id="umask.sh">
      <title>/etc/profile.d/umask.sh</title>

      <indexterm zone="postlfs-config-profile umask.sh">
        <primary sortas="e-etc-profile.d-umask.sh">/etc/profile.d/umask.sh</primary>
      </indexterm>

      <para>
        Le paramétrage de la valeur <command>umask</command> est important pour la
sécurité. Ici, les droits d'écriture par défaut du groupe sont désactivés
pour les utilisateurs systèmes et quand le nom d'utilisateur et le nom du
groupe ne sont pas les mêmes.
      </para>

<screen role="root"><userinput>cat &gt; /etc/profile.d/umask.sh &lt;&lt; "EOF"
<literal># By default, the umask should be set.
if [ "$(id -gn)" = "$(id -un)" -a $EUID -gt 99 ] ; then
  umask 002
else
  umask 022
fi</literal>
EOF</userinput></screen>

    </sect3>


    <!-- This is handled in the Xorg section of the book
    <sect3 id="X.sh">

      <title>/etc/profile.d/X.sh</title>

      <indexterm zone="postlfs-config-profile X.sh">
        <primary sortas="e-etc-profile.d-X.sh">/etc/profile.d/X.sh</primary>
      </indexterm>

      <para>
        If <application>X</application> is installed, the <envar>PATH</envar>
        and <envar>PKG_CONFIG_PATH</envar> variables are also updated.
      </para>

<screen role="root"><userinput>cat &gt; /etc/profile.d/X.sh &lt;&lt; "EOF"
<literal>if [ -x /usr/X11R6/bin/X ]; then
        pathappend /usr/X11R6/bin
fi
if [ -d /usr/X11R6/lib/pkgconfig ] ; then
        pathappend /usr/X11R6/lib/pkgconfig PKG_CONFIG_PATH
fi</literal>
EOF</userinput></screen>

    </sect3>
-->
<sect3 id="i18n.sh">
    
      <!-- This is handled system wide on systemd but LANG is not exported to
         the environment, hence it's return...need to add additional text for
         systemd only -->
<title>/etc/profile.d/i18n.sh</title>

    <indexterm zone="postlfs-config-profile i18n.sh">
      <primary sortas="e-etc-profile.d-i18n.sh">/etc/profile.d/i18n.sh</primary>
    </indexterm>

      <para>
        Ce script règle une variable d'environnement nécessaire au support des
langues natives. Vous pouvez trouver un point complet sur la détermination
de cette variable sur la page <ulink
url="&lfs-root;/chapter09/profile.html">Fichiers de démarrage du shell bash
de LFS</ulink>.
      </para>

<screen role="root" revision="sysv"><userinput>cat &gt; /etc/profile.d/i18n.sh &lt;&lt; "EOF"
<literal># Set up i18n variables
export LANG=<replaceable>&lt;ll&gt;</replaceable>_<replaceable>&lt;CC&gt;</replaceable>.<replaceable>&lt;charmap&gt;</replaceable><replaceable>&lt;@modifiers&gt;</replaceable></literal>
EOF</userinput></screen>

<screen role="root" revision="systemd"><userinput>cat &gt; /etc/profile.d/i18n.sh &lt;&lt; "EOF"
<literal># Set up i18n variables
. /etc/locale.conf
export LANG</literal>
EOF</userinput></screen>

    </sect3>

    <sect3>
      <title>Autres valeurs d'Initialisation</title>

      <para>
        On peut facilement ajouter d'autres réglages à <filename>profile</filename>
en ajoutant des scripts supplémentaires au répertoire <filename
class='directory'>/etc/profile.d</filename>.
      </para>

    </sect3>

  </sect2>

  <sect2 id="etc-bashrc-profile">
    <title>/etc/bashrc</title>

    <indexterm zone="postlfs-config-profile etc-bashrc-profile">
      <primary sortas="e-etc-bashrc">/etc/bashrc</primary>
    </indexterm>

    <para>
      Voici un <filename>/etc/bashrc</filename> de base. Les commentaires dans ce
fichier devraient vous expliquer tout ce dont vous avez besoin.
    </para>

<screen role="root"><userinput>cat &gt; /etc/bashrc &lt;&lt; "EOF"
<literal># Begin /etc/bashrc
# Written for Beyond Linux From Scratch
# by James Robertson &lt;jameswrobertson@earthlink.net&gt;
# updated by Bruce Dubbs &lt;bdubbs@&lfs-domainname;&gt;

# System wide aliases and functions.

# System wide environment variables and startup programs should go into
# /etc/profile.  Personal environment variables and startup programs
# should go into ~/.bash_profile.  Personal aliases and functions should
# go into ~/.bashrc

# Provides colored /bin/ls and /bin/grep commands.  Used in conjunction
# with code in /etc/profile.

alias ls='ls --color=auto'
alias grep='grep --color=auto'

# Provides prompt for non-login shells, specifically shells started
# in the X environment. [Review the LFS archive thread titled
# PS1 Environment Variable for a great case study behind this script
# addendum.]

NORMAL="\[\e[0m\]"
RED="\[\e[1;31m\]"
GREEN="\[\e[1;32m\]"
if [[ $EUID == 0 ]] ; then
  PS1="$RED\u [ $NORMAL\w$RED ]# $NORMAL"
else
  PS1="$GREEN\u [ $NORMAL\w$GREEN ]\$ $NORMAL"
fi

unset RED GREEN NORMAL

# End /etc/bashrc</literal>
EOF</userinput></screen>

  </sect2>

  <sect2 id="bash_profile-profile">
    <title>~/.bash_profile</title>

    <indexterm zone="postlfs-config-profile bash_profile-profile">
      <primary sortas="e-AA.bash_profile">~/.bash_profile</primary>
    </indexterm>

    <para>
      Voici un <filename>~/.bash_profile</filename> de base. Si vous voulez que
chaque nouvel utilisateur ait automatiquement ce fichier, renvoyez seulement
la sortie de la commande vers <filename>/etc/skel/.bash_profile</filename>
et vérifiez les droits après l'exécution de la commande. Vous pouvez alors
copier <filename>/etc/skel/.bash_profile</filename> dans les répertoires
home des utilisateurs existants, y compris celui de <systemitem
class="username">root</systemitem>, et réglez comme il faut le propriétaire
et le groupe d'appartenance.
    </para>

<screen><userinput>cat &gt; ~/.bash_profile &lt;&lt; "EOF"
<literal># Begin ~/.bash_profile
# Written for Beyond Linux From Scratch
# by James Robertson &lt;jameswrobertson@earthlink.net&gt;
# updated by Bruce Dubbs &lt;bdubbs@&lfs-domainname;&gt;

# Personal environment variables and startup programs.

# Personal aliases and functions should go in ~/.bashrc.  System wide
# environment variables and startup programs are in /etc/profile.
# System wide aliases and functions are in /etc/bashrc.

if [ -f "$HOME/.bashrc" ] ; then
  source $HOME/.bashrc
fi

if [ -d "$HOME/bin" ] ; then
  pathprepend $HOME/bin
fi

# Having . in the PATH is dangerous
#if [ $EUID -gt 99 ]; then
#  pathappend .
#fi

# End ~/.bash_profile</literal>
EOF</userinput></screen>

  </sect2>

  <sect2 id="dot_profile-profile">
    <title>~/.profile</title>

    <indexterm zone="postlfs-config-profile dot_profile-profile">
      <primary sortas="e-AA.dot_profile">~/.profile</primary>
    </indexterm>

    <para>
      Voici un <filename>~/.profile</filename> de base. Les commentaires et les
instructions d'utilisation de <filename
class="directory">/etc/skel</filename> pour
<filename>.bash_profile</filename> ci-dessus s'appliquent aussi ici. Seuls
les noms de fichiers cibles sont différents.
    </para>

<screen><userinput>cat &gt; ~/.profile &lt;&lt; "EOF"
<literal># Begin ~/.profile
# Personal environment variables and startup programs.

if [ -d "$HOME/bin" ] ; then
  pathprepend $HOME/bin
fi

# Set up user specific i18n variables
#export LANG=<replaceable>&lt;ll&gt;</replaceable>_<replaceable>&lt;CC&gt;</replaceable>.<replaceable>&lt;charmap&gt;</replaceable><replaceable>&lt;@modifiers&gt;</replaceable>

# End ~/.profile</literal>
EOF</userinput></screen>

  </sect2>

  <sect2 id="bashrc-profile">
    <title>~/.bashrc</title>

    <indexterm zone="postlfs-config-profile bashrc-profile">
      <primary sortas="e-AA.bashrc">~/.bashrc</primary>
    </indexterm>

    <para>
      Voici un fichier <filename>~/.bashrc</filename> de base.
    </para>

<screen><userinput>cat &gt; ~/.bashrc &lt;&lt; "EOF"
<literal># Begin ~/.bashrc
# Written for Beyond Linux From Scratch
# by James Robertson &lt;jameswrobertson@earthlink.net&gt;

# Personal aliases and functions.

# Personal environment variables and startup programs should go in
# ~/.bash_profile.  System wide environment variables and startup
# programs are in /etc/profile.  System wide aliases and functions are
# in /etc/bashrc.

if [ -f "/etc/bashrc" ] ; then
  source /etc/bashrc
fi

# Set up user specific i18n variables
#export LANG=<replaceable>&lt;ll&gt;</replaceable>_<replaceable>&lt;CC&gt;</replaceable>.<replaceable>&lt;charmap&gt;</replaceable><replaceable>&lt;@modifiers&gt;</replaceable>

# End ~/.bashrc</literal>
EOF</userinput></screen>

  </sect2>


  <sect2 id="bash_logout-profile">
    <title>~/.bash_logout</title>

    <indexterm zone="postlfs-config-profile bash_logout-profile">
      <primary sortas="e-AA.bash_logout">~/.bash_logout</primary>
    </indexterm>

    <para>
      C'est un <filename>~/.bash_logout</filename> vide qui peut être utilisé
comme modèle. Vous remarquerez que le <filename>~/.bash_logout</filename> de
base n'inclut pas de commande <userinput>clear</userinput>. Ceci car le
vidage se gère dans le fichier <filename>/etc/issue</filename>.
    </para>

<screen><userinput>cat &gt; ~/.bash_logout &lt;&lt; "EOF"
<literal># Begin ~/.bash_logout
# Written for Beyond Linux From Scratch
# by James Robertson &lt;jameswrobertson@earthlink.net&gt;

# Personal items to perform on logout.

# End ~/.bash_logout</literal>
EOF</userinput></screen>

  </sect2>


  <sect2 id="etc-dircolors-profile">
    <title>/etc/dircolors</title>

    <indexterm zone="postlfs-config-profile etc-dircolors-profile">
      <primary sortas="e-etc-dircolors">/etc/dircolors</primary>
    </indexterm>

    <indexterm zone="postlfs-config-profile etc-dircolors-profile">
      <primary sortas="e-AA.dircolors">~/.dircolors</primary>
    </indexterm>

    <para>
       Si vous utilisez la possibilité <filename>dircolors</filename>, lancez la
commande suivante. Les étapes de paramétrage de <filename
class="directory">/etc/skel</filename> indiquées ci-dessus peuvent être
utilisées ici pour avoir un fichier <filename>~/.dircolors</filename> lors
du réglage d'un nouvel utilisateur. Comme tout à l'heure, changez simplement
le nom du fichier de sorti dans la commande suivante et assurez-vous que les
droits, le propriétaire et le groupe conviennent aux fichiers créés ou
copiés.
    </para>

<screen role="root"><userinput>dircolors -p > /etc/dircolors</userinput></screen>

    <para>
      Si vous souhaitez personnaliser les couleurs utilisées pour différents types
de fichiers, vous devez éditer le fichier
<filename>/etc/dircolors</filename>. Les instructions pour régler les
couleurs sont comprises dans le fichier.
    </para>


    <para>
      Enfin, Ian Macdonald a écrit un ensemble excellent de modèles et de
bidouillages pour améliorer votre environnement de shell. Vous pouvez le
lire en ligne sur <ulink url="https://www.caliban.org/bash/index.shtml"/>.
    </para>

  </sect2>

</sect1>
