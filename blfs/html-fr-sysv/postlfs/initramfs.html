<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8" />
    <title>
      À propos de initramfs
    </title>
    <link rel="stylesheet" type="text/css" href="../stylesheets/lfs.css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.79.1" />
    <link rel="stylesheet" href="../stylesheets/lfs-print.css" type=
    "text/css" media="print" />
  </head>
  <body class="blfs" id="blfs-r10.1-914+">
    <div class="navheader">
      <h4>
        Au-delà de Linux<sup>®</sup> From Scratch (édition <span class=
        "phrase">System V)</span> - Version r10.1-914+
      </h4>
      <h3>
        Chapitre&nbsp;5.&nbsp;Systèmes de fichiers et gestion de disque
      </h3>
      <ul>
        <li class="prev">
          <a accesskey="p" href="filesystems.html" title=
          "Systèmes de fichiers et gestion de disque">Précédent</a>
          <p>
            Systèmes de fichiers et gestion de disque
          </p>
        </li>
        <li class="next">
          <a accesskey="n" href="btrfs-progs.html" title=
          "btrfs-progs-5.13.1">Suivant</a>
          <p>
            btrfs-progs-5.13.1
          </p>
        </li>
        <li class="up">
          <a accesskey="u" href="filesystems.html" title=
          "Chapitre&nbsp;5.&nbsp;Systèmes de fichiers et gestion de disque">Niveau
          supérieur</a>
        </li>
        <li class="home">
          <a accesskey="h" href="../index.html" title=
          "Au-delà de Linux® From Scratch (édition System V) - Version r10.1-914+">
          Sommaire</a>
        </li>
      </ul>
    </div>
    <div class="sect1" lang="fr" xml:lang="fr">
      <h1 class="sect1">
        <a id="initramfs" name="initramfs"></a>À propos de initramfs
      </h1>
      <p>
        La seule fonction d'un initramfs est de monter le système de fichier
        racine. L'initramfs est un ensemble complet de répertoires que vous
        pouvez trouver dans un système de fichiers racine normal. Il est
        regroupé dans une seule archive cpio et compressé avec l'un des
        nombreux algorithmes de compression.
      </p>
      <p>
        Au moment du démarrage, le chargeur de démarrage charge le noyau et
        l'image initramfs dans la mémoire et démarre le noyau. Le noyau
        vérifie la présence d'un initramfs et, s'il le trouve, le monte sur /
        et lance /init. Le programme init est typiquement un script shell.
        Notez que le processus de démarrage est plus long, même
        significativement plus long, si un initramfs est utilisé.
      </p>
      <p>
        Pour la plupart des distributions, les modules du noyau sont la plus
        importante raison d'avoir un initramfs. Dans une distribution
        générale, il y a beaucoup d'inconnues comme les types de systèmes de
        fichiers et les couches des disques. Dans un sens, c'est l'opposé de
        LFS où les capacités et les couches du système sont connus et un
        noyau personnalisé est normalement construit. Dans cette situation,
        un initramfs est rarement nécessaire.
      </p>
      <p>
        Il y a seulement quatre raisons d'avoir un initramfs dans un
        environnement LFS&nbsp;: le chargement du rootfs depuis le réseau,
        son chargement depuis un volume logique LVM, avoir un rootfs chiffré
        où un mot de passe est requis, ou pour le confort d'un rootfs
        spécifié par un LABEL ou un UUID. Les autres cas signifient souvent
        que le noyau n'est pas configuré correctement.
      </p>
      <div class="sect2" lang="fr" xml:lang="fr">
        <h2 class="sect2">
          <a id="initramfs-build" name="initramfs-build"></a>Construire un
          initramfs
        </h2>
        <p>
          Si vous décidez de construire un initramfs, les scripts suivants
          fourniront les bases pour le faire. Les scripts autoriseront la
          spécification du rootfs via un UUID de partition ou un LABEL de
          partition ou un rootfs dans un volume logique LVM. Ils ne prennent
          pas en charge les systèmes de fichier racine chiffrés ou le montage
          des rootfs par des cartes réseaux. Pour plus d'informations sur les
          possibilités, voir <a class="ulink" href=
          "https://www.linuxfromscratch.org/hints/read.html">L'astuce LFS</a>
          ou <a class="ulink" href=
          "http://fedoraproject.org/wiki/Dracut">dracut</a>.
        </p>
        <p>
          Pour installer ces scripts, lancez les commandes suivantes en tant
          qu'utilisateur <code class="systemitem">root</code>&nbsp;:
        </p>
        <pre class="root"><kbd class=
        "command">cat &gt; /usr/sbin/mkinitramfs &lt;&lt; "EOF"
<code class="literal">#!/bin/bash
# This file based in part on the mkinitramfs script for the LFS LiveCD
# written by Alexander E. Patrakov and Jeremy Huntwork.

copy()
{
  local file

  if [ "$2" = "lib" ]; then
    file=$(PATH=/usr/lib type -p $1)
  else
    file=$(type -p $1)
  fi

  if [ -n "$file" ] ; then
    cp $file $WDIR/usr/$2
  else
    echo "Missing required file: $1 for directory $2"
    rm -rf $WDIR
    exit 1
  fi
}

if [ -z $1 ] ; then
  INITRAMFS_FILE=initrd.img-no-kmods
else
  KERNEL_VERSION=$1
  INITRAMFS_FILE=initrd.img-$KERNEL_VERSION
fi

if [ -n "$KERNEL_VERSION" ] &amp;&amp; [ ! -d "/usr/lib/modules/$1" ] ; then
  echo "No modules directory named $1"
  exit 1
fi

printf "Creating $INITRAMFS_FILE... "

binfiles="sh cat cp dd killall ls mkdir mknod mount "
binfiles="$binfiles umount sed sleep ln rm uname"
binfiles="$binfiles readlink basename"

# Systemd installs udevadm in /bin. Other udev implementations have it in /sbin
if [ -x /usr/bin/udevadm ] ; then binfiles="$binfiles udevadm"; fi

sbinfiles="modprobe blkid switch_root"

# Optional files and locations
for f in mdadm mdmon udevd udevadm; do
  if [ -x /usr/sbin/$f ] ; then sbinfiles="$sbinfiles $f"; fi
done

# Add lvm if present (cannot be done with the others because it
# also needs dmsetup
if [ -x /usr/sbin/lvm ] ; then sbinfiles="$sbinfiles lvm dmsetup"; fi

unsorted=$(mktemp /tmp/unsorted.XXXXXXXXXX)

DATADIR=/usr/share/mkinitramfs
INITIN=init.in

# Create a temporary working directory
WDIR=$(mktemp -d /tmp/initrd-work.XXXXXXXXXX)

# Create base directory structure
mkdir -p $WDIR/{dev,run,sys,proc,usr/{bin,lib/{firmware,modules},sbin}}
mkdir -p $WDIR/etc/{modprobe.d,udev/rules.d}
touch $WDIR/etc/modprobe.d/modprobe.conf
ln -s usr/bin  $WDIR/bin
ln -s usr/lib  $WDIR/lib
ln -s usr/sbin $WDIR/sbin
ln -s lib      $WDIR/lib64

# Create necessary device nodes
mknod -m 640 $WDIR/dev/console c 5 1
mknod -m 664 $WDIR/dev/null    c 1 3

# Install the udev configuration files
if [ -f /etc/udev/udev.conf ]; then
  cp /etc/udev/udev.conf $WDIR/etc/udev/udev.conf
fi

for file in $(find /etc/udev/rules.d/ -type f) ; do
  cp $file $WDIR/etc/udev/rules.d
done

# Install any firmware present
cp -a /usr/lib/firmware $WDIR/usr/lib

# Copy the RAID configuration file if present
if [ -f /etc/mdadm.conf ] ; then
  cp /etc/mdadm.conf $WDIR/etc
fi

# Install the init file
install -m0755 $DATADIR/$INITIN $WDIR/init

if [  -n "$KERNEL_VERSION" ] ; then
  if [ -x /usr/bin/kmod ] ; then
    binfiles="$binfiles kmod"
  else
    binfiles="$binfiles lsmod"
    sbinfiles="$sbinfiles insmod"
  fi
fi

# Install basic binaries
for f in $binfiles ; do
  ldd /usr/bin/$f | sed "s/\t//" | cut -d " " -f1 &gt;&gt; $unsorted
  copy /usr/bin/$f bin
done

for f in $sbinfiles ; do
  ldd /usr/sbin/$f | sed "s/\t//" | cut -d " " -f1 &gt;&gt; $unsorted
  copy $f sbin
done

# Add udevd libraries if not in /usr/sbin
if [ -x /usr/lib/udev/udevd ] ; then
  ldd /usr/lib/udev/udevd | sed "s/\t//" | cut -d " " -f1 &gt;&gt; $unsorted
elif [ -x /usr/lib/systemd/systemd-udevd ] ; then
  ldd /usr/lib/systemd/systemd-udevd | sed "s/\t//" | cut -d " " -f1 &gt;&gt; $unsorted
fi

# Add module symlinks if appropriate
if [ -n "$KERNEL_VERSION" ] &amp;&amp; [ -x /usr/bin/kmod ] ; then
  ln -s kmod $WDIR/usr/bin/lsmod
  ln -s kmod $WDIR/usr/bin/insmod
fi

# Add lvm symlinks if appropriate
# Also copy the lvm.conf file
if  [ -x /usr/sbin/lvm ] ; then
  ln -s lvm $WDIR/usr/sbin/lvchange
  ln -s lvm $WDIR/usr/sbin/lvrename
  ln -s lvm $WDIR/usr/sbin/lvextend
  ln -s lvm $WDIR/usr/sbin/lvcreate
  ln -s lvm $WDIR/usr/sbin/lvdisplay
  ln -s lvm $WDIR/usr/sbin/lvscan

  ln -s lvm $WDIR/usr/sbin/pvchange
  ln -s lvm $WDIR/usr/sbin/pvck
  ln -s lvm $WDIR/usr/sbin/pvcreate
  ln -s lvm $WDIR/usr/sbin/pvdisplay
  ln -s lvm $WDIR/usr/sbin/pvscan

  ln -s lvm $WDIR/usr/sbin/vgchange
  ln -s lvm $WDIR/usr/sbin/vgcreate
  ln -s lvm $WDIR/usr/sbin/vgscan
  ln -s lvm $WDIR/usr/sbin/vgrename
  ln -s lvm $WDIR/usr/sbin/vgck
  # Conf file(s)
  cp -a /etc/lvm $WDIR/etc
fi

# Install libraries
sort $unsorted | uniq | while read library ; do
# linux-vdso and linux-gate are pseudo libraries and do not correspond to a file
# libsystemd-shared is in /lib/systemd, so it is not found by copy, and
# it is copied below anyway
  if [[ "$library" == linux-vdso.so.1 ]] ||
     [[ "$library" == linux-gate.so.1 ]] ||
     [[ "$library" == libsystemd-shared* ]]; then
    continue
  fi

  copy $library lib
done

if [ -d /usr/lib/udev ]; then
  cp -a /usr/lib/udev $WDIR/usr/lib
fi
if [ -d /usr/lib/systemd ]; then
  cp -a /usr/lib/systemd $WDIR/usr/lib
fi
if [ -d /usr/lib/elogind ]; then
  cp -a /usr/lib/elogind $WDIR/usr/lib
fi

# Install the kernel modules if requested
if [ -n "$KERNEL_VERSION" ]; then
  find                                                                        \
     /usr/lib/modules/$KERNEL_VERSION/kernel/{crypto,fs,lib}                      \
     /usr/lib/modules/$KERNEL_VERSION/kernel/drivers/{block,ata,md,firewire}      \
     /usr/lib/modules/$KERNEL_VERSION/kernel/drivers/{scsi,message,pcmcia,virtio} \
     /usr/lib/modules/$KERNEL_VERSION/kernel/drivers/usb/{host,storage}           \
     -type f 2&gt; /dev/null | cpio --make-directories -p --quiet $WDIR

  cp /usr/lib/modules/$KERNEL_VERSION/modules.{builtin,order}                     \
            $WDIR/usr/lib/modules/$KERNEL_VERSION

  depmod -b $WDIR $KERNEL_VERSION
fi

( cd $WDIR ; find . | cpio -o -H newc --quiet | gzip -9 ) &gt; $INITRAMFS_FILE

# Prepare early loading of microcode if available
if ls /usr/lib/firmware/intel-ucode/* &gt;/dev/null 2&gt;&amp;1 ||
   ls /usr/lib/firmware/amd-ucode/*   &gt;/dev/null 2&gt;&amp;1; then

# first empty WDIR to reuse it
  rm -r $WDIR/*

  DSTDIR=$WDIR/kernel/x86/microcode
  mkdir -p $DSTDIR

  if [ -d /usr/lib/firmware/amd-ucode ]; then
    cat /usr/lib/firmware/amd-ucode/microcode_amd*.bin &gt; $DSTDIR/AuthenticAMD.bin
  fi

  if [ -d /usr/lib/firmware/intel-ucode ]; then
    cat /usr/lib/firmware/intel-ucode/* &gt; $DSTDIR/GenuineIntel.bin
  fi

  ( cd $WDIR; find . | cpio -o -H newc --quiet ) &gt; microcode.img
  cat microcode.img $INITRAMFS_FILE &gt; tmpfile
  mv tmpfile $INITRAMFS_FILE
  rm microcode.img
fi

# Remove the temporary directories and files
rm -rf $WDIR $unsorted
printf "done.\n"
</code>
EOF

chmod 0755 /usr/sbin/mkinitramfs</kbd></pre>
        <pre class="root"><kbd class=
        "command">mkdir -p /usr/share/mkinitramfs &amp;&amp;
cat &gt; /usr/share/mkinitramfs/init.in &lt;&lt; "EOF"
<code class="literal">#!/bin/sh

PATH=/usr/bin:/usr/sbin
export PATH

problem()
{
   printf "Encountered a problem!\n\nDropping you to a shell.\n\n"
   sh
}

no_device()
{
   printf "The device %s, which is supposed to contain the\n" $1
   printf "root file system, does not exist.\n"
   printf "Please fix this problem and exit this shell.\n\n"
}

no_mount()
{
   printf "Could not mount device %s\n" $1
   printf "Sleeping forever. Please reboot and fix the kernel command line.\n\n"
   printf "Maybe the device is formatted with an unsupported file system?\n\n"
   printf "Or maybe filesystem type autodetection went wrong, in which case\n"
   printf "you should add the rootfstype=... parameter to the kernel command line.\n\n"
   printf "Available partitions:\n"
}

do_mount_root()
{
   mkdir /.root
   [ -n "$rootflags" ] &amp;&amp; rootflags="$rootflags,"
   rootflags="$rootflags$ro"

   case "$root" in
      /dev/*    ) device=$root ;;
      UUID=*    ) eval $root; device="/dev/disk/by-uuid/$UUID" ;;
      PARTUUID=*) eval $root; device="/dev/disk/by-partuuid/$PARTUUID" ;;
      LABEL=*   ) eval $root; device="/dev/disk/by-label/$LABEL" ;;
      ""        ) echo "No root device specified." ; problem ;;
   esac

   while [ ! -b "$device" ] ; do
       no_device $device
       problem
   done

   if ! mount -n -t "$rootfstype" -o "$rootflags" "$device" /.root ; then
       no_mount $device
       cat /proc/partitions
       while true ; do sleep 10000 ; done
   else
       echo "Successfully mounted device $root"
   fi
}

do_try_resume()
{
   case "$resume" in
      UUID=* ) eval $resume; resume="/dev/disk/by-uuid/$UUID"  ;;
      LABEL=*) eval $resume; resume="/dev/disk/by-label/$LABEL" ;;
   esac

   if $noresume || ! [ -b "$resume" ]; then return; fi

   ls -lH "$resume" | ( read x x x x maj min x
       echo -n ${maj%,}:$min &gt; /sys/power/resume )
}

init=/sbin/init
root=
rootdelay=
rootfstype=auto
ro="ro"
rootflags=
device=
resume=
noresume=false

mount -n -t devtmpfs devtmpfs /dev
mount -n -t proc     proc     /proc
mount -n -t sysfs    sysfs    /sys
mount -n -t tmpfs    tmpfs    /run

read -r cmdline &lt; /proc/cmdline

for param in $cmdline ; do
  case $param in
    init=*      ) init=${param#init=}             ;;
    root=*      ) root=${param#root=}             ;;
    rootdelay=* ) rootdelay=${param#rootdelay=}   ;;
    rootfstype=*) rootfstype=${param#rootfstype=} ;;
    rootflags=* ) rootflags=${param#rootflags=}   ;;
    resume=*    ) resume=${param#resume=}         ;;
    noresume    ) noresume=true                   ;;
    ro          ) ro="ro"                         ;;
    rw          ) ro="rw"                         ;;
  esac
done

# udevd location depends on version
if [ -x /sbin/udevd ]; then
  UDEVD=/sbin/udevd
elif [ -x /lib/udev/udevd ]; then
  UDEVD=/lib/udev/udevd
elif [ -x /lib/systemd/systemd-udevd ]; then
  UDEVD=/lib/systemd/systemd-udevd
else
  echo "Cannot find udevd nor systemd-udevd"
  problem
fi

${UDEVD} --daemon --resolve-names=never
udevadm trigger
udevadm settle

if [ -f /etc/mdadm.conf ] ; then mdadm -As                       ; fi
if [ -x /sbin/vgchange  ] ; then /sbin/vgchange -a y &gt; /dev/null ; fi
if [ -n "$rootdelay"    ] ; then sleep "$rootdelay"              ; fi

do_try_resume # This function will not return if resuming from disk
do_mount_root

killall -w ${UDEVD##*/}

exec switch_root /.root "$init" "$@"
</code>
EOF</kbd></pre>
      </div>
      <div class="sect2" lang="fr" xml:lang="fr">
        <h2 class="sect2">
          <a id="initramfs-install" name="initramfs-install"></a>Utilisation
          d'un initramfs
        </h2>
        <h3>
          Dépendance d'exécution requise
        </h3>
        <p class="required">
          <a class="xref" href="../general/cpio.html" title=
          "cpio-2.13">cpio-2.13</a>
        </p>
        <h3>
          Dépendances de Other Runtime
        </h3>
        <p class="optional">
          <a class="xref" href="lvm2.html" title=
          "LVM2-2.03.13">LVM2-2.03.13</a> et <a class="xref" href=
          "mdadm.html" title="mdadm-4.1">mdadm-4.1</a> doivent être installés
          avant de générer l'initramfs, si les partitions du système les
          utilise.
        </p>
        <p class="usernotes">
          Notes utilisateur&nbsp;: <a class="ulink" href=
          "https://wiki.linuxfromscratch.org/blfs/wiki/initramfs">https://wiki.linuxfromscratch.org/blfs/wiki/initramfs</a>
        </p>
        <p>
          Pour construire un initramfs, lancer ce qui suit en tant
          qu'utilisateur <code class="systemitem">root</code>&nbsp;:
        </p>
        <pre class="userinput"><kbd class=
        "command">mkinitramfs [KERNEL VERSION]</kbd></pre>
        <p>
          L'argument facultatif est le répertoire où les modules appropriés
          du noyau sont enregistrés. Cela peut être un sous-répertoire de
          <code class="filename">/lib/modules</code>. Si aucun module n'est
          spécifié, alors l'initramfs est appelé <span class=
          "emphasis"><em>initrd.img-no-kmods</em></span>. Si une version du
          noyau est précisé, le fichier initrd est appelé <span class=
          "emphasis"><em>initrd.img-$KERNEL_VERSION</em></span> et est
          seulement destiné pour le noyau spécifiquement précisé. Les
          fichiers de sortie seront enregistrés dans le répertoire courant.
        </p>
        <p>
          Si vous avez besoin du chargement de microcode au plus tôt (voir
          <a class="xref" href="firmware.html#cpu-microcode" title=
          "Mise à jour de micro-codes pour les CPU">la section intitulée
          «&nbsp;Mise à jour de micro-codes pour les CPU&nbsp;»</a>), vous
          pouvez installer le blob ou le conteneur approprié dans
          <code class="filename">/lib/firmware</code>. Il sera
          automatiquement ajouté à l'initrd quand vous lancerez <span class=
          "command"><strong>mkinitfs</strong></span>.
        </p>
        <p>
          Après avoir généré le fichier initrd, copiez-le dans le répertoire
          <code class="filename">/boot</code>.
        </p>
        <p>
          Maintenant éditez <code class="filename">/boot/grub/grub.cfg</code>
          et ajoutez une nouvelle entrée dans le menu. En dessous, plusieurs
          exemples sont présentés.
        </p>
        <pre class="userinput"><kbd class=
        "command"># Generic initramfs and root fs identified by UUID
menuentry "LFS Dev (LFS-7.0-Feb14) initrd, Linux 3.0.4"
{
  linux  /vmlinuz-3.0.4-lfs-20120214 root=UUID=54b934a9-302d-415e-ac11-4988408eb0a8 ro
  initrd /initrd.img-no-kmods
}</kbd></pre>
        <pre class="userinput"><kbd class=
        "command"># Generic initramfs and root fs on LVM partition
menuentry "LFS Dev (LFS-7.0-Feb18) initrd lvm, Linux 3.0.4"
{
  linux  /vmlinuz-3.0.4-lfs-20120218 root=/dev/mapper/myroot ro
  initrd /initrd.img-no-kmods
}</kbd></pre>
        <pre class="userinput"><kbd class=
        "command"># Specific initramfs and root fs identified by LABEL
menuentry "LFS Dev (LFS-7.1-Feb20) initrd label, Linux 3.2.6"
{
  linux  /vmlinuz-3.2.6-lfs71-120220 root=LABEL=lfs71 ro
  initrd /initrd.img-3.2.6-lfs71-120220
}</kbd></pre>
        <p>
          Finalement, redémarrez le système et sélectionnez le système
          désiré.
        </p>
      </div>
      <p class="updated">
        Last updated on
      </p>
    </div>
    <div class="navfooter">
      <ul>
        <li class="prev">
          <a accesskey="p" href="filesystems.html" title=
          "Systèmes de fichiers et gestion de disque">Précédent</a>
          <p>
            Systèmes de fichiers et gestion de disque
          </p>
        </li>
        <li class="next">
          <a accesskey="n" href="btrfs-progs.html" title=
          "btrfs-progs-5.13.1">Suivant</a>
          <p>
            btrfs-progs-5.13.1
          </p>
        </li>
        <li class="up">
          <a accesskey="u" href="filesystems.html" title=
          "Chapitre&nbsp;5.&nbsp;Systèmes de fichiers et gestion de disque">Niveau
          supérieur</a>
        </li>
        <li class="home">
          <a accesskey="h" href="../index.html" title=
          "Au-delà de Linux® From Scratch (édition System V) - Version r10.1-914+">
          Sommaire</a>
        </li>
      </ul>
    </div>
  </body>
</html>
