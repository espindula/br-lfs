<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
    "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
   <!ENTITY % general-entities SYSTEM "../../general.ent">
   %general-entities;
   
]>
<sect1 id="pkgmgt">
   <?dbhtml filename="pkgmgt.html"?>
   
   <sect1info>
      <othername>$LastChangedBy: randy $</othername>
      <date>$Date: 2007-04-04 21:42:53 +0200 (mer. 04 avril 2007) $</date>
   </sect1info>
   
   <title>Gestion de paquetages</title> 
   
   <para>
      La gestion de paquetages est un ajout souvent demandé au livre LFS. Un gestionnaire de
      paquetages permet de conserver une trace des fichiers installés, simplifiant ainsi leur
      suppression ou leur mise à jour. Un gestionnaire de paquetages gérera tant les fichiers
      binaires et de bibliothèque que l'installation des fichiers de configuration. Avant tout,
      NON&mdash;cette section ne parle pas d'un gestionnaire de paquetages particulier, elle n'en
      recommande pas non plus. Elle fait un tour des techniques les plus populaires pour indiquer
      comment elles fonctionnent. Le gestionnaire parfait de paquetages pourrait faire partie de ces
      techniques ou pourrait être une combinaison d'une ou plusieurs techniques. Cette section
      mentionne brièvement les problèmes pouvant survenir lors de la mise à jour des paquetages. 
   </para> 
   
   <para>
      Parmi les raisons de l'absence d'un gestionnaire de paquetages mentionné dans LFS ou BLFS: 
   </para> 
   <itemizedlist>
      <listitem>
         <para>
            S'occuper de la gestion de paquetages est en dehors des buts de ces livres&mdash; visant
            à apprendre comment un système Linux est construit. 
         </para> 
      </listitem>
      <listitem>
         <para>
            Il existe de nombreuses solutions pour la gestion de paquetages, chacune ayant des
            forces et ses faiblesses. En inclure une qui satisfait tout le monde est difficile. 
         </para> 
      </listitem>
   </itemizedlist>
   
   <para>
      Des astuces ont été écrites sur le thème de la gestion de paquetages. Visitez le <ulink
      url="&hints-root;"> Projet des astuces </ulink>
      et voyez celui qui satisfait vos besoins. 
   </para> 
   
   <sect2>
      <title>Problèmes de mise à jour</title> 
      
      <para>
         Un gestionnaire de paquetages facilite la mise à jour des nouvelles versions au moment de
         leur sortie. Généralement, les instructions dans les livres LFS et BLFS peuvent être
         utilisées pour les nouvelles versions. Voici quelques points à connaître pour une mise à
         jour de paquetages, spécifiquement sur un système en cours de fonctionnement 
      </para> 
      <itemizedlist>
         <listitem>
            <para>
               Si un des paquets de l'ensemble d'outils ( <application>Glibc</application> ,
               <application>GCC</application> ou <application>Binutils</application> ) doit être mis
               à jour avec une nouvelle version mineure, reconstruire LFS est plus sûr. Bien que
               vous <emphasis>
               pourriez </emphasis>
               être capable de ne pas reconstruire tous les paquetages dans leur ordre de
               dépendances. Nous ne vous le recommandons pas. Par exemple, si glibc-2.2.x a besoin
               d'être mis à jour vers glibc-2.3.x, il est préférable de reconstruire. Pour les mises
               à jour encore plus mineures, une simple réinstallation fonctionne généralement mais
               cela n'est pas garanti. Par exemple, mettre à jour de glibc-2.3.1 à glibc-2.3.2 ne
               causera aucun problème. 
            </para> 
         </listitem>
         <listitem>
            <para>
               Si un paquetage contenant une bibliothèque partagée est mise à jour et si le nom de
               cette dernière est modifié, alors les paquetages liées dynamiquement à la
               bibliothèque devront être recompilés pour être liés à la nouvelle bibliothèque.
               (Remarquez qu'il n'y a aucune corrélation entre la version du paquetage et le nom de
               la bibliothèque.) Par exemple, considérez un paquetage foo-1.2.3 qui installe une
               bibliothèque partagée de nom <filename class='libraryfile'>libfoo.so.1</filename> .
               Disons que vous mettez à jour le paquetage avec une nouvelle version foo-1.2.4 qui
               installe une bibliothèque partagée de nom <filename class='libraryfile'>
               libfoo.so.2</filename> . Dans ce cas, tous les paquetages liés dynamiquement à
               <filename class='libraryfile'>libfoo.so.1</filename> doivent être recompilés pour
               être liés à <filename class='libraryfile'>
               libfoo.so.2</filename> . Remarquez que vous ne devez pas supprimer les anciennes
               bibliothèques jusqu'à ce que les paquetages indépendants soient recompilés. 
            </para> 
         </listitem>
         <listitem>
            <para>
               Si vous mettez à jour un système en fonction, cherchez des paquets qui utilisent
               <command>cp</command> à la place de <command>install</command> pour installer des
               fichiers. La dernière commande est en général plus sûre si l'exécutable ou la
               bibliothèque est déjà chargé en mémoire. 
            </para> 
         </listitem>
      </itemizedlist>
      
   </sect2>
   
   <sect2>
      <title>Techniques de gestion de paquetages</title> 
      
      <para>
         Ce qui suit est une liste de techniques habituelles de gestion de paquetages. Avant de
         prendre une décision sur un gestionnaire de paquetages, faites une recherche sur les
         différentes techniques et notamment leurs faiblesses. 
      </para> 
      
      <sect3>
         <title>Tout est dans ma tête!</title> 
         
         <para>
            Oui, c'est une technique de gestion de paquetages. Certains n'éprouvent pas le besoin
            d'un gestionnaire de paquetages parce qu'ils connaissent très bien les paquetages et
            connaissent les fichiers installés par chaque paquetage. Certains utilisateurs n'en ont
            pas besoin parce qu'ils planifient la reconstruction entière de LFS lorsqu'un paquetage
            est modifié. 
         </para> 
         
      </sect3>
      
      <sect3>
         <title>Installer dans des répertoires séparés</title> 
         
         <para>
            C'est une gestion des paquetages tellement simple qu'elle ne nécessite aucun paquetage
            supplémentaire pour gérer les installations. Chaque paquetage est installé dans un
            répertoire séparé. Par exemple, le paquetage foo-1.1 est installé dans <filename
            class='directory'>/usr/pkg/foo-1.1</filename> et un lien symbolique est créé de
            <filename>/usr/pkg/foo</filename> vers <filename class='directory'>
            /usr/pkg/foo-1.1</filename> . Lors de l'installation de la nouvelle version foo-1.2,
            elle est installée dans <filename class='directory'>/usr/pkg/foo-1.2</filename> et
            l'ancien lien symbolique est remplacé par un lien symbolique vers la nouvelle version. 
         </para> 
         
         <para>
            Les variables d'environnement telles que celles indiquées à la <quote><xref
            linkend="beyond"/></quote> ont besoin d'être étendues pour inclure
            <filename>/usr/pkg/foo</filename> . Pour plus que quelques paquetages, ce schéma devient
            ingérable. 
         </para> 
         
      </sect3>
      
      <sect3>
         <title>Gestion de paquetage par lien symbolique</title> 
         
         <para>
            C'est une variante de la technique précédente. Chaque paquetage est installé de façon
            similaire au schéma précédent. Mais au lieu de réaliser le lien symbolique, chaque
            fichier dispose d'un lien symbolique vers son équivalent dans la hiérarchie <filename
            class='directory'>/usr</filename> . Ceci supprime le besoin d'étendre les variables
            d'environnement. Bien que les liens symboliques peuvent être créés par l'utilisateur,
            pour automatiser la création, certains gestionnaires de paquetages ont été écrit avec
            cette approche. Parmi les plus populaires se trouvent Stow, Epkg, Graft et Depot. 
         </para> 
         
         <para>
            L'installation doit être faussée, de façon à ce que chaque paquetage pense qu'il est
            installé dans <filename class="directory">/usr</filename> alors qu'en réalité il est
            installé dans la hiérarchie <filename class="directory">
            /usr/pkg</filename> . Installer de cette manière n'est généralement pas une tâche
            triviale. Par exemple, considérez que vous installez un paquetage libfoo-1.1. Les
            instructions suivantes pourraient ne pas installer correctement le paquetage: 
         </para> 
         
<screen><userinput>./configure --prefix=/usr/pkg/libfoo/1.1
make
make install</userinput></screen>
         
         <para>
            L'installation fonctionnera mais les paquetages dépendants pourraient ne pas lier libfoo
            comme vous vous y attenderiez. Si vous compilez un paquetage qui se lie à <filename
            class='libraryfile'>/usr/pkg/libfoo/1.1/lib/libfoo.so.1</filename> au lieu de <filename
            class='libraryfile'>
            /usr/lib/libfoo.so.1</filename> comme vous le prévoyez. La bonne approche est d'utiliser
            la stratégie <envar>DESTDIR </envar>pour fausser l'installation du paquetage. Cette
            approche fonctionne ainsi:  
         </para> 
         
<screen><userinput>./configure --prefix=/usr
make
make DESTDIR=/usr/pkg/libfoo/1.1 install</userinput></screen>
         
         <para>
            La plupart des paquetages supportent cette approche mais elle pose problème à certains.
            Pour les paquetages non compatibles, vous pouvez soit les installer manuellement soit
            trouver plus simple d'installer les paquetages problématiques dans <filename
            class='directory'>/opt</filename> . 
         </para> 
         
      </sect3>
      
      <sect3>
         <title>Basé sur le temps</title> 
         
         <para>
            Avec cette technique, un fichier est balisé avec l'heure avant l'installation du
            paquetage. Après l'installation, une simple utilisation de la commande
            <command>find</command> avec les options appropriées peut générer une trace de tous les
            fichiers installés après que le fichier temps ne soit créé. install-log est un
            gestionnaire de paquetages écrit avec cette approche. 
         </para> 
         
         <para>
            Bien que ce schéma a l'avantage d'être simple, il a deux inconvénients. Si à
            l'installation, les fichiers sont installés sans balise de temps autre que l'heure
            actuelle, ces fichiers ne seront pas suivis par le gestionnaire de paquetages. De plus,
            ce schéma peut seulement être utilisé lorsqu'un seul paquetage est installé à la fois.
            Les traces ne sont pas fiables si deux paquetages sont installés dans deux consoles
            différentes. 
         </para> 
         
      </sect3>
      
      <sect3>
         <title>Basé sur LD_PRELOAD</title> 
         
         <para>
            Avec cette approche, une bibliothèque est préchargée avant l'installation. Pendant
            l'installation, cette bibliothèque poursuit les paquets qui sont installés en
            s'attachant à divers exécutables tels que <command>cp</command> ,
            <command>install</command> , <command>mv</command> et la poursuite des appels système
            qui modifient le système de fichiers. Pour que cette approche fonctionne, tous les
            exécutables doivent être liés de façon dynamique sans le bit suid ou sgid (id super
            utilisateur ou super groupe). Le préchargement de la bibliothèque peut provoquer des
            effets indésirables pendant l'installation. Effectuez donc des tests pour vous assurer
            que le gestionnaire de paquets ne casse rien et journalisés tous les fichiers adéquats. 
         </para> 
         
      </sect3>
      
      <sect3>
         <title>Créer des archives de paquetages</title> 
         
         <para>
            Dans ce schéma, l'installation d'un paquetage est faussée dans un répertoire séparé
            comme décrit plus haut. Après l'installation, une archive du paquetage est créée en
            utilisant les fichiers installés. L'archive est ensuite utilisée pour installer le
            paquetage soit sur la machine locale soit même sur d'autres machines. 
         </para> 
         
         <para>
            Cette approche est utilisée par la plupart des gestionnaires de paquetages trouvés dans
            les distributions commerciales. Les exemples de gestionnaires qui suivent cette approche
            sont RPM, pkg-utils, apt de Debian et le système Portage de Gentoo. 
         </para> 
         
      </sect3>
      
      <sect3>
         <title>Gestion basée sur les utilisateurs</title> 
         
         <para>
            Ce schéma, unique à LFS, a été décrit par Matthias Benkmann et est disponible sur le
            <ulink url="&hints-root;"> Projet des astuces </ulink>
            . Dans ce schéma, chaque paquetage est installé en tant qu'utilisateur séparé dans les
            emplacements standards. Les fichiers appartenant à un paquetage sont facilement
            identifiés grâce à l'identifiant de l'utilisateur. Les fonctionnalités et avantages de
            cette approche sont trop complexes pour les décrire dans cette section. Pour plus de
            détails, voir l'astuce sur <ulink
            url="&hints-root;/downloads/files/more_control_and_pkg_man.txt"/> . 
         </para> 
         
      </sect3>
      
   </sect2>
   
</sect1>
