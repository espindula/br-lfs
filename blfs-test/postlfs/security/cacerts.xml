<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
    "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
   <!ENTITY % general-entities SYSTEM "../../general.ent">
   %general-entities;
   
   <!ENTITY certhost              "http://mxr.mozilla.org">
   <!ENTITY certdir               "/mozilla/source/security/nss/lib/ckfw/builtins">
   <!ENTITY ca-bundle-download    "&certhost;&certdir;/certdata.txt?raw=1">
   <!ENTITY ca-bundle-size        "1.2 Mio">
   <!ENTITY cacerts-buildsize     "1.2 Mio">
   <!ENTITY cacerts-time          "moins de0.1 SBU">
   
]>
<sect1 id="cacerts" xreflabel="Certificate Authority Certificates">
   <?dbhtml filename="cacerts.html"?>
   
   <sect1info>
      <othername>$LastChangedBy: bdubbs $</othername>
      <date>$Date: 2012-03-19 21:57:08 +0100 (lun. 19 mars 2012) $</date>
   </sect1info>
   
   <title>Certificate Authority Certificates</title> 
   
   <para>
      La <foreignphrase>Public Key Inrastructure</foreignphrase> (infrastructure de clés publiques)
      est utilisés dans de nombreux cas de sécurité sur un système Linux. Pour qu'un certificat soit
      fiable, il doit être signé par  un agent de confiance, qu'on appelle l'autorité de certificat
      (<foreignphrase>Certificate Authority</foreignphrase>) (CA).  Les certificats chargés dans
      cette section sont issus de la liste du système de contrôle de on the Mozilla et elle est
      formatée dans une forme utilisée par <xref linkend='openssl'/>.  Les certificats peuvent
      également être utilisés par d'autres applications, directement ou indirectement via
      <application>openssl</application> . 
   </para> 
   
   &lfs70_checked;
   <indexterm zone="cacerts">
      <primary sortas="a-cacerts"> Certificate Authority Certificates </primary>
   </indexterm>
   
   <sect2 role="package">
      <title>Introduction à Certificate Authorities</title> 
      
      <bridgehead renderas="sect3"> Informations sur le paquet </bridgehead>
      <itemizedlist spacing="compact">
         <listitem>
            <para>
               Téléchargement du Certificat CA>&nbsp;: <ulink url="&ca-bundle-download;"/> 
            </para> 
         </listitem>
         <listitem>
            <para>
               Taille du bouquet CA>&nbsp;: &ca-bundle-size; 
            </para> 
         </listitem>
         <listitem>
            <para>
               Estimation de l'espace disque requis: &cacerts-buildsize; 
            </para> 
         </listitem>
         <listitem>
            <para>
               Estimation du temps de construction: &cacerts-time; 
            </para> 
         </listitem>
      </itemizedlist>
      
      <bridgehead renderas="sect3"> Dépendances de Certificate Authority Certificates </bridgehead>
      
      <bridgehead renderas="sect4"> Requises </bridgehead>
      
      <para role="required">
         <xref linkend="openssl"/>
      </para> 
      
      <bridgehead renderas="sect4"> Facultative </bridgehead>
      
      <para role="optional">
         <xref linkend="wget"/>
      </para> 
      
      <para condition="html" role="usernotes">
         Notes utilisateur: <ulink url='&blfs-wiki;/cacerts'/> 
      </para> 
      
   </sect2>
   
   <sect2 role="installation">
      <title>Installation de Certificate Authority Certificates</title> 
      
      <para>
         Créez d'abord un script pour reformatter un certificat en forme dont a besoin
         <application>openssl</application> . En tant qu'utilisateur <systemitem class="username">
         root </systemitem>&nbsp;:  
      </para> 
      
<screen><userinput>cat>
 /bin/make-cert.pl &lt;&lt; "EOF"
 certificate.crt
my $certdata = './tempfile.cer';
open( IN, "cat $certdata|" )
    || die "could not open $certdata";
my $incert = 0;
while ( &lt;IN&gt; )
{
    if ( /^CKA_VALUE MULTILINE_OCTAL/ )
    {
        $incert = 1;
        open( OUT, "|openssl x509 -text -inform DER -fingerprint" )
            || die "could not pipe to openssl x509";
    }
    elsif ( /^END/ &amp;&amp; $incert )
    {
        close( OUT );
        $incert = 0;
        print "\n\n";
    }
    elsif ($incert)
    {
        my @bs = split( /\\/ );
        foreach my $b (@bs)
        {
            chomp $b;
            printf( OUT "%c", oct($b) ) unless $b eq '';
        }
    }
}
EOF
chmod +x /bin/make-cert.pl</userinput></screen>
      
      <para>
         Le script suivant crée les certificats et un bouquet de tous les certificats. Il crée un
         répertoire <filename class='directory'>./certs</filename> et
         <filename>./BLFS-ca-bundle-${VERSION}.crt</filename> .  Créez de nouveau ce script en tant
         qu'utilisateur <systemitem class="username"> root </systemitem>&nbsp;:  
      </para> 
      
<screen><userinput>cat>
 /bin/make-ca.sh &lt;&lt; "EOF"
certdata="certdata.txt"
if [ ! -r $certdata ]; then
  echo "$certdata must be in the local directory"
  exit 1
fi
REVISION=$(grep CVS_ID $certdata | cut -f4 -d'$')
if [ -z "${REVISION}" ]; then
  echo "$certfile has no 'Revision' in CVS_ID"
  exit 1
fi
VERSION=$(echo $REVISION | cut -f2 -d" ")
TEMPDIR=$(mktemp -d)
TRUSTATTRIBUTES="CKA_TRUST_SERVER_AUTH"
BUNDLE="BLFS-ca-bundle-${VERSION}.crt"
CONVERTSCRIPT="make-cert.pl"
SSLDIR="/etc/ssl"
mkdir "${TEMPDIR}/certs"
CERTBEGINLIST=$(grep -n "^# Certificate" "${certdata}" | cut -d ":" -f1)
CERTENDLIST=`grep -n "^CKA_TRUST_STEP_UP_APPROVED" "${certdata}" | cut -d ":" -f 1`
for certbegin in ${CERTBEGINLIST}; do
  for certend in ${CERTENDLIST}; do
    if test "${certend}" -gt "${certbegin}"; then
      break
    fi
  done
  # Dump to a temp file with the name of the file as the beginning line number
  sed -n "${certbegin},${certend}p" "${certdata}">
 "${TEMPDIR}/certs/${certbegin}.tmp"
done
unset CERTBEGINLIST CERTDATA CERTENDLIST certebegin certend
mkdir -p certs
rm certs/*      # Make sure the directory is clean
for tempfile in ${TEMPDIR}/certs/*.tmp; do
  # Make sure that the cert is trusted...
  grep "CKA_TRUST_SERVER_AUTH" "${tempfile}" | \
    egrep "TRUST_UNKNOWN|NOT_TRUSTED">
 /dev/null
  if test "${?}" ="0"; then
    # Throw a meaningful error and remove the file
    cp "${tempfile}" tempfile.cer
    "${CONVERTSCRIPT}">
 tempfile.crt
    keyhash=$(openssl x509 -noout -in tempfile.crt -hash)
    echo "Certificate ${keyhash} is not trusted!  Removing..."
    rm -f tempfile.cer tempfile.crt "${tempfile}"
    continue
  fi
  # If execution made it to here in the loop, the temp cert is trusted
  # Find the cert data and generate a cert file for it
  cp "${tempfile}" tempfile.cer
  "${CONVERTSCRIPT}">
 tempfile.crt
  keyhash=$(openssl x509 -noout -in tempfile.crt -hash)
  mv tempfile.crt "certs/${keyhash}.pem"
  rm -f tempfile.cer "${tempfile}"
  echo "Created ${keyhash}.pem"
done
if test -f certs/8f111d69.pem; then
  echo "Certificate 8f111d69 is not trusted!  Removing..."
  rm -f certs/8f111d69.pem
fi
cat certs/*.pem>
  ${BUNDLE}
rm -r "${TEMPDIR}"
EOF
chmod +x /bin/make-ca.sh</userinput></screen>
      
      <para>
         Ajoutez un script bref pour supprimer les certificts expirés d'un répertoire. Créez de
         nouveau ce script en tant qu'utilisateur <systemitem class="username"> root
         </systemitem>&nbsp;:  
      </para> 
      
<screen><userinput>cat>
 /bin/remove-expired-certs.sh &lt;&lt; "EOF"
function mydate()
{
  local y=$( echo $1 | cut -d" " -f4 )
  local M=$( echo $1 | cut -d" " -f1 )
  local d=$( echo $1 | cut -d" " -f2 )
  local m
  if [ ${d} -lt 10 ]; then d="0${d}"; fi
  case $M in
    Jan) m="01";;
    Feb) m="02";;
    Mar) m="03";;
    Apr) m="04";;
    May) m="05";;
    Jun) m="06";;
    Jul) m="07";;
    Aug) m="08";;
    Sep) m="09";;
    Oct) m="10";;
    Nov) m="11";;
    Dec) m="12";;
  esac
  certdate="${y}${m}${d}"
}
OPENSSL=/usr/bin/openssl
DIR=/etc/ssl/certs
if [ $# -gt 0 ]; then
  DIR="$1"
fi
certs=$( find ${DIR} -type f -name "*.pem" -o -name "*.crt" )
today=$( date +%Y%m%d )
for cert in $certs; do
  notafter=$( $OPENSSL x509 -enddate -in "${cert}" -noout )
  date=$( echo ${notafter} |  sed 's/^notAfter=//' )
  mydate "$date"
  if [ ${certdate} -lt ${today} ]; then
     echo "${cert} expired on ${certdate}! Removing..."
     rm -f "${cert}"
  fi
done
EOF
chmod +x /bin/remove-expired-certs.sh</userinput></screen>
      
      <para>
         Les commandes suivantes récupèreront les certificats et les convertit dans le bon format. 
         Si vous le désirez, vous pouvez utiliser un navigateur Internet plutôt que
         <application>wget</application> mais le fichier devra être enregistré sous le nom
         <filename>certdata.txt</filename> .  Ces commandes peuvent être répétées autant de fois que
         nécessaire pour mettre à jour les Certificats CA. 
      </para> 
      
<screen><userinput>certhost='http://mxr.mozilla.org'                        &amp;&amp;
certdir='/mozilla/source/security/nss/lib/ckfw/builtins' &amp;&amp;
url="$certhost$certdir/certdata.txt?raw=1"               &amp;&amp;
wget --output-document certdata.txt $url &amp;&amp;
unset certhost certdir url               &amp;&amp;
make-ca.sh                               &amp;&amp;
remove-expired-certs.sh certs</userinput></screen>
      
      <para>
         Maintenant, en tant qu'utilisateur the <systemitem class="username"> root
         </systemitem>&nbsp;:  
      </para> 
      
<screen><userinput>SSLDIR=/etc/ssl                                     &amp;&amp;
install -d ${SSLDIR}/certs                          &amp;&amp;
cp -v certs/*.pem ${SSLDIR}/certs                   &amp;&amp;
c_rehash                                            &amp;&amp;
install BLFS-ca-bundle*.crt ${SSLDIR}/ca-bundle.crt &amp;&amp;
unset SSLDIR</userinput></screen>
      
      <para>
         Enfin, nettoyez le répertoire courant: 
      </para> 
      
<screen><userinput>rm -r certs BLFS-ca-bundle*</userinput></screen>
      
   </sect2>
   
   <sect2 role="content">
      <title>Contenu</title> 
      
      <segmentedlist>
         <segtitle>Programmes installés</segtitle>
         <segtitle>Bibliothèques installées</segtitle>
         <segtitle>Répertoires installés</segtitle>
         
         <seglistitem>
            <seg>
               make-ca.sh, make-cert.pl et remove-expired-certs.sh
            </seg>
            <seg>
               Aucune
            </seg>
            <seg>
               /etc/ssl/certs
            </seg>
         </seglistitem>
      </segmentedlist>
      <variablelist>
      
      <bridgehead renderas="sect3"> Descriptions courtes </bridgehead>
      <?dbfo list-presentation="list"?>
      <?dbhtml list-presentation="table"?>
      
      <varlistentry id="make-ca">
         <term><command>make-ca.sh</command> </term>
         <listitem>
            <para>
               est un script <application>bash</application> qui reformate le fichier
               <filename>certdata.txt</filename> pour que <application>openssl</application>
               l'utilise. 
            </para> 
            <indexterm zone="cacerts make-ca">
               <primary sortas="b-make-ca"> make-ca </primary>
            </indexterm>
         </listitem>
      </varlistentry>
      
      <varlistentry id="make-cert">
         <term><command>make-cert.pl</command> </term>
         <listitem>
            <para>
               est un script <application>perl</application> qui convertit un certificat binaire
               unique (format .der) au format .pem. 
            </para> 
            <indexterm zone="cacerts make-cert">
               <primary sortas="b-make-cert"> make-cert </primary>
            </indexterm>
         </listitem>
      </varlistentry>
      
      <varlistentry id="remove-expired-certs">
         <term><command>remove-expired-certs.sh</command> </term>
         <listitem>
            <para>
               est un script <application>perl</application> qui supprime les certificats expirés
               d'un répertoire. Le répertoire par défaut est <filename
               class='directory'>/etc/ssl/certs</filename> . 
            </para> 
            <indexterm zone="cacerts remove-expired-certs">
               <primary sortas="b-remove-expired-certs"> remove-expired-certs </primary>
            </indexterm>
         </listitem>
      </varlistentry>
      </variablelist>
      
   </sect2>
   
</sect1>
