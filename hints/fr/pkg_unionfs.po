# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2019-09-02 09:14+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Plain text
#: origin/pkg_unionfs.txt:2
msgid "AUTHOR: Samad Lotia"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:4
msgid "DATE: 2008-10-21"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:7
msgid ""
"LICENSE: GNU GPL 2 (see "
"http://www.linuxfromscratch.org/hints/downloads/files/LICENSES/gpl-2.txt)"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:9
msgid "SYNOPSIS: A UnionFS-based package management system"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:16
#, no-wrap
msgid ""
"DESCRIPTION:\n"
"  UnionFS is a kernel patch that allows one to merge the contents of many\n"
"  disparate directories so they all appear as a single directory. This\n"
"  functionality provides a basis for a minimal, yet effective,\n"
"  package manager. This approach appeals to those who want a more rational\n"
"  and organized directory structure.\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:20
#, no-wrap
msgid ""
"ATTACHMENTS:\n"
"  1) "
"http://www.linuxfromscratch.org/hints/downloads/files/ATTACHMENTS/pkg_unionfs/pkgs\n"
"  2) "
"http://www.linuxfromscratch.org/hints/downloads/files/ATTACHMENTS/pkg_unionfs/manager\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:23
#, no-wrap
msgid ""
"PREREQUISITES:\n"
"  Completion of the \"Constructing a Temporary System\" chapter in the LFS "
"book.\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:25
msgid "HINT:"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:27
msgid "Part I. Introduction"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:33
msgid ""
"UnionFS is a kernel patch that provides the ability to merge many "
"directories such that their contents appear together in one directory. The "
"package manager proposed here uses this ability to merge the contents of "
"various packages so directories like /bin and /lib have the appearance of "
"containing all loaded packages."
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:44
msgid ""
"This type of package management is inspired by GoboLinux's unique take on "
"the archaic Unix directory structures*. Instead of installing all packages "
"into the /usr directory whose contents can become quite unwieldy, packages "
"are installed into their own directories. GoboLinux's package manager "
"creates symbolic links in the necessary directories in order to give the "
"appearance that the package is installed in traditional directories.  A "
"package can be removed by deleting the directory a package was installed in, "
"causing the symbolic links pointing to that package to become "
"invalidated. GoboLinux demonstrates that a fully-functional GNU/Linux system "
"does not require packages to be installed in traditional directories."
msgstr ""

#. type: Bullet: '* '
#: origin/pkg_unionfs.txt:46
msgid "http://www.gobolinux.org/?page=k5"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:48
msgid "Section I.a. Advantages"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:57
msgid ""
"The primary benefit of this type of package manager is simplicity. It only "
"requires a patched kernel, a startup script for setting up the UnionFS mount "
"points, and a script for loading and unloading packages. This approach "
"refrains from the canonical black-box style of package management where the "
"user issues specialized commands to a complex package manager consisting of "
"several tiers of programs and book-keeping files to install or uninstall a "
"pacakge. Here, the user issues commands to a script that, in turn, merely "
"issues mount commands to UnionFS."
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:59
msgid "There are some possible benefits of a simpler directory structure:"
msgstr ""

#. type: Bullet: '  * '
#: origin/pkg_unionfs.txt:62
msgid ""
"The contents of /bin, /sbin, and /lib merely contain a few files necessary "
"for init scripts."
msgstr ""

#. type: Bullet: '  * '
#: origin/pkg_unionfs.txt:65
msgid ""
"There is no chance an uninstalled package can leave behind stray files in "
"/etc or /usr/share."
msgstr ""

#. type: Bullet: '  * '
#: origin/pkg_unionfs.txt:68
msgid ""
"It is convenient to tuck away special libraries and files needed by a "
"specific package but need to be kept hidden from the rest of the system."
msgstr ""

#. type: Bullet: '  * '
#: origin/pkg_unionfs.txt:73
msgid ""
"It is easier to find configuration files for a package. Instead of hunting "
"down a configuration file in /etc or /usr/share that contains files from all "
"packages, one can browse through a package's directory to look for a file."
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:78
msgid ""
"This approach is flexible in that determining what constitutes a package is "
"up to the user. One can combine several different packages together into one "
"super-package so their contents are loaded together. This is useful for "
"packages like X.Org, which consists of hundreds subpackages."
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:83
msgid ""
"A secondary benefit of this approach is version management. In some cases it "
"is useful to have multiple versions of the same package installed at the "
"same time. One can try out a newer version of a package to see if it is "
"satisfactory without affecting the installation of an older version."
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:85
msgid "Section I.b. Disadvantages"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:87
msgid "There are several disadvantages to this type of package management."
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:92
msgid ""
"First, this approach imposes a longer startup time. At system boot, "
"necessary packages must be loaded before the system can be fully "
"functional. This disadvantage is not a serious setback for most users, since "
"loading one hundred and thirty packages takes about four seconds on a "
"relatively new computer."
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:96
msgid ""
"Second, a package cannot be unloaded if its contents are in use. This "
"limitation primarily affects packages consisting of libraries. Running "
"programs must be terminated first in order to unload a package they depend "
"on."
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:98
msgid "Section I.c. How It Works"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:102
msgid ""
"Assume UnionFS is installed and is working. To demonstrate UnionFS, assume "
"there are the directories a, b, and c. a contains the file 1, b contains "
"file 2, and c is empty."
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:115
#, no-wrap
msgid ""
"  $ ls\n"
"  a b c\n"
"  $ ls -a a\n"
"  . .. 1\n"
"  $ cat a/1\n"
"  one\n"
"  $ ls -a b\n"
"  . .. 2\n"
"  $ cat b/2\n"
"  two\n"
"  $ ls -a c\n"
"  . ..\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:120
#, no-wrap
msgid ""
"The following command is then issued:\n"
"  # mount -t unionfs -o \"ro,dirs=a:b\" none c\n"
"This has the effect of performing a union operation on the contents of a and "
"b\n"
"and storing them in c.\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:138
#, no-wrap
msgid ""
"This produces the following result:\n"
"  $ ls\n"
"  a b c\n"
"  $ ls -a a\n"
"  . .. 1\n"
"  $ cat a/1\n"
"  one\n"
"  $ ls -a b\n"
"  . .. 2\n"
"  $ cat b/2\n"
"  two\n"
"  $ ls -a c\n"
"  . .. 1 2\n"
"  $ cat c/1\n"
"  one\n"
"  $ cat c/2\n"
"  two\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:147
msgid ""
"This functionality is the basis for the package manager. Assume there is a "
"binary in directory /pkgs/sed/4.1.5/bin/sed. The package manager notices "
"there is a bin directory at /pkgs/sed/4.1.5/bin. It determines that this "
"directory's contents should be mapped to the directory /bin.  The package "
"manager issues mount commands to UnionFS. After the package is loaded, "
"/pkgs/sed/4.1.5/bin/sed appears as /bin/sed. A user of the system can use "
"the sed program as if it exists in /bin/sed. When a package is unloaded, sed "
"is no longer in /bin, yet remains as /pkgs/sed/4.1.5/bin/sed."
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:149
msgid "Section I.d. Some Preliminary Jargon"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:153
msgid ""
"While jargon and specialized lexicon should be rigorously eschewed*, some "
"preliminary terminology is presented here to reduce the verbosity of this "
"document or to clarify potentially ambiguous phrases."
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:159
#, no-wrap
msgid ""
" * Installing a package:\n"
"     The programs, libraries, and configuration files are built and copied "
"to\n"
"     a designated directory for a package. This does not mean the package\n"
"     is available and can be used by the system. Installation is not "
"handled\n"
"     in any way by the package manager proposed here.\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:166
#, no-wrap
msgid ""
" * Loading a package:\n"
"     The programs, libraries, and configurations of a package are made\n"
"     available to the system. In other words, the package manager looks at "
"a\n"
"     package's contents and issues mounts to UnionFS so the appropriate "
"files\n"
"     will be presented in /bin, /lib, /etc, and so on. A package must be\n"
"     installed before it can be loaded.\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:171
#, no-wrap
msgid ""
"  * Unloading a package:\n"
"     The opposite of loading, where the contents of a package are made\n"
"     unavailable to the system. A package's contents do not appear in "
"/bin,\n"
"     /lib, /etc, and so on, yet remain in its respective package "
"directory.\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:177
#, no-wrap
msgid ""
"  * Uninstalling a package:\n"
"     The opposite of installing, where the package's files are completely\n"
"     removed from disk. A package, if it has been loaded, must be unloaded\n"
"     first before it can be removed. Uninstalling is not handled by the\n"
"     package manager, since rm is sufficient.\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:184
#, no-wrap
msgid ""
"  * Source directory:\n"
"      This is a directory, like bin, share, or lib, in a package's\n"
"      directory. Its contents, along with other packages' source "
"directories,\n"
"      are the source for directories that are a target for UnionFS, like\n"
"      /bin, /usr/share, or /lib. In the example demonstrated in Section "
"I.c,\n"
"      /pkgs/sed/4.1.5/bin is a source directory.\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:189
#, no-wrap
msgid ""
"  * Target directory:\n"
"      This is a directory, like /bin or /lib. Its contents are "
"artificially\n"
"      constructed by UnionFS. In the example demonstrated in Section I.c,\n"
"      /bin is the target directory of the source directory "
"/pkgs/sed/4.1.5/bin.\n"
msgstr ""

#. type: Bullet: '* '
#: origin/pkg_unionfs.txt:192
msgid ""
"See Orwell, G. \"Politics of the English Language.\" 1946.  "
"http://www.mtholyoke.edu/acad/intrel/orwell46.htm"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:194
msgid "Part II. Installation"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:197
msgid ""
"Setting up the package manager is discussed here and should be done after "
"the chapter \"Constructing a Temporary System\" is completed."
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:199
msgid "Section II.a. The Directory Structure"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:203
msgid ""
"The following directory structure is assumed in this document and provided "
"scripts. It is perfectly reasonable to change this structure to one's "
"tastes."
msgstr ""

#. type: Bullet: '  1) '
#: origin/pkg_unionfs.txt:205
msgid "The general directory containing all packages is stored in /pkgs."
msgstr ""

#. type: Bullet: '  2) '
#: origin/pkg_unionfs.txt:208
msgid ""
"A package is installed in a subdirectory of /pkgs. For example, the sed "
"package is installed in /pkgs/sed."
msgstr ""

#. type: Bullet: '  3) '
#: origin/pkg_unionfs.txt:213
msgid ""
"A package's version is a subdirectory in the package's directory. For "
"example, if sed has the version 4.1.5, it is installed in /pkgs/sed/4.1.5.  "
"Since each package version has its own directory, multiple versions of the "
"same package can be installed."
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:224
#, no-wrap
msgid ""
"  4) The target directories:\n"
"       * /bin,\n"
"       * /etc,\n"
"       * /lib,\n"
"       * /var,\n"
"       * /usr/share,\n"
"       * /usr/man,\n"
"       * /usr/include,\n"
"       * and /usr/info\n"
"     should be created.\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:228
#, no-wrap
msgid ""
"     /usr/bin should link to /bin, and /usr/lib should link to /lib.\n"
"     If one is using a 64-bit machine, the additional /lib64 and "
"/usr/lib64\n"
"     links should point to /lib.\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:230
msgid "Section II.b. Installing Packages"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:239
msgid ""
"After the chapter \"Constructing a Temporary System,\" the LFS book "
"describes steps for the actual installation of packages in the chapter "
"\"Installing Basic System Software.\" The LFS book relies on a package's "
"Makefile to determine the location--typically /usr--where the package is to "
"be installed. Because packages are installed in non-standard locations, this "
"default behavior must be superseded. One can install all packages in the LFS "
"and BLFS books in their own directories, including fundamental packages like "
"glibc and sysvinit."
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:243
msgid ""
"Many packages only require the DESTDIR parameter be passed to the Makefile "
"when issuing the install command*. Here is an example of Bison-2.3 to "
"illustrate the process of installing a typical package."
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:246
#, no-wrap
msgid ""
"  1) Create the necessary directories:\n"
"       mkdir -pv /pkgs/bison/2.3\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:252
#, no-wrap
msgid ""
"  2) Follow the steps provided by LFS, except for \"make install\":\n"
"       ./configure --prefix=/usr\n"
"       echo '#define YYENABLE_NLS 1' >> config.h\n"
"       make\n"
"       make check\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:255
#, no-wrap
msgid ""
"  3) Run \"make install\" with the DESTDIR parameter:\n"
"       make DESTDIR=/pkgs/bison/2.3 install\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:261
msgid ""
"Most packages will follow this format. Unfortunately, not all packages use "
"the DESTDIR parameter for installation. Some packages require the configure "
"script's --prefix parameter to determine where the package is to be "
"installed. One must look at the README or INSTALL files provided with a "
"package to determine this."
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:266
msgid ""
"Typically, if a package does not have a configure script, the DESTDIR "
"parameter will probably not work, and one must consult the provided "
"documentation to determine how to install a package in a non-standard "
"location."
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:271
msgid ""
"Some packages require the --sysconfdir parameter for the configure script.  "
"The LFS book specifies this should be /etc. Since the package is to be "
"installed in a non-standard location, this should be set to "
"/pkgs/name/version/etc."
msgstr ""

#. type: Bullet: '* '
#: origin/pkg_unionfs.txt:274
msgid ""
"See the section \"Package Management\" in the LFS book for further "
"discussion.  "
"http://www.linuxfromscratch.org/lfs/view/development/chapter06/pkgmgt.html"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:276
msgid "Section II.c. Setting up the Kernel"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:279
msgid ""
"By now, all the packages specified in the chapter \"Installing Basic System "
"Software\" should be installed in their own directories."
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:284
msgid ""
"In the chapter \"Making the LFS System Bootable,\" the LFS book describes "
"how to compile and install the kernel. In order to add the UnionFS "
"capability to the Linux kernel, one must patch the kernel source code before "
"compiling it. Here are the steps to setting up the patch."
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:288
#, no-wrap
msgid ""
"  1) Download a kernel patch from:\n"
"       http://www.filesystems.org/project-unionfs.html\n"
"     Unpack the patch.\n"
msgstr ""

#. type: Bullet: '  2) '
#: origin/pkg_unionfs.txt:292
msgid ""
"Download the corresponding kernel version. The file name of the kernel patch "
"may be something like \"unionfs-2.5_for_2.6.26.5.diff.gz\". Therefore, "
"download the kernel version 2.6.26.5. Unpack the kernel source code."
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:296
#, no-wrap
msgid ""
"  4) Apply the kernel patch by first entering the kernel source code "
"directory\n"
"     and then typing:\n"
"       patch -Np1 -i /path/to/unionfs/patch.diff\n"
msgstr ""

#. type: Bullet: '  5) '
#: origin/pkg_unionfs.txt:302
msgid ""
"Follow the steps in the LFS book for setting up a menu configuration for the "
"kernel. While in the configuration program, ensure the UnionFS module is "
"built. The option can be found in Drivers > Filesystems > Layered "
"Filesystems. UnionFS can be built as a module or can be statically linked "
"with the kernel."
msgstr ""

#. type: Bullet: '  6) '
#: origin/pkg_unionfs.txt:305
msgid ""
"Build and install the kernel as specified in the chapter \"Making the LFS "
"System Bootable.\""
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:307
msgid "Section II.d. Setting up the Scripts"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:311
msgid ""
"After finishing the \"Setting up System Bootscripts\" and \"Making the LFS "
"System Bootable\" chapters, one must setup the necessary scripts for package "
"management before restarting*. There are two attached scripts, pkgs and "
"manager."
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:314
msgid ""
"The manager script issues mount commands to UnionFS. This script can be "
"copied into /pkgs. This script will be discussed in depth later."
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:322
msgid ""
"pkgs is an init script that (a) sets up all the mount points necessary for "
"package management and (b) loads all the necessary packages for system "
"startup.  This script should be executed as early in the bootscripts as "
"possible.  If UnionFS is built as a module, the script should be executed "
"after the module has been loaded. Otherwise, this script should be executed "
"first. To install this script assuming one is using LFS's boot scripts, one "
"should:"
msgstr ""

#. type: Bullet: '  1) '
#: origin/pkg_unionfs.txt:324
msgid "Copy pkgs into /etc/rc.d/init.d."
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:327
#, no-wrap
msgid ""
"  2) Make a link of pkgs to /etc/rc.sysinit:\n"
"      a) If UnionFS was built as a module:\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:331
#, no-wrap
msgid ""
"         Have the script be executed after the necessary modules have been\n"
"\t loaded:\n"
"           (i) ln -sv /etc/rc.d/init.d/pkgs /etc/rc.d/rc.sysinit/S06pkgs\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:335
#, no-wrap
msgid ""
"\t Add UnionFS to /etc/sysconfig/modules in order to have the UnionFS\n"
"\t module be loaded at startup:\n"
"\t   (ii) echo unionfs >> /etc/sysconfig/modules\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:337
#, no-wrap
msgid "      b) If UnionFS was built into the kernel:\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:341
#, no-wrap
msgid ""
"\t Lower the execution order of mountkernfs:\n"
"           (i) mv -v /etc/rc.d/rc.sysinit/S00mountkernfs \\\n"
"\t             /etc/rc.d/rc.sysinit/S01mountkernfs\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:344
#, no-wrap
msgid ""
"\t Have the pkgs script to be executed first:\n"
"\t   (ii) ln -sv /etc/rc.d/init.d/pkgs /etc/rc.d/rc.sysinit/S00pkgs\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:350
#, no-wrap
msgid ""
"  3) Create the pkgs_startup file:\n"
"       This file is used by pkgs to determine what packages to load at\n"
"       startup. This file is akin to /etc/sysconfig/modules. Each line in "
"this\n"
"       file has the following format:\n"
"         package_name <SPACE> package_version\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:354
#, no-wrap
msgid ""
"       This file is typically located in /etc/sysconfig. If one wishes to "
"use\n"
"       another location, change the CONFIG_FILE variable in the pkgs script "
"to\n"
"       the location of this file.\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:360
#, no-wrap
msgid ""
"       This file should contain all the packages necessary for the init "
"scripts\n"
"       that follow the pkgs script, like sysklogd and udev, in order for\n"
"       proper system startup. If one wishes to load all available packages "
"\n"
"       at system startup, type:\n"
"         /pkgs/manager list > /etc/sysconfig/pkgs_startup\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:364
msgid ""
"If the manager script was not copied into /pkgs, open the pkgs script and "
"look for the PKG_LOADER variable. This variable should be changed to the "
"location of the manager script."
msgstr ""

#. type: Bullet: '* '
#: origin/pkg_unionfs.txt:367
msgid ""
"In fact, not setting up the package manager will produce a non-bootable "
"system because packages are installed in non-standard locations."
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:369
msgid "Section II.e. Creating the Necessary Symbolic Links"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:373
msgid ""
"After the scripts have been installed, a few symbolic links must be created "
"for proper system startup, since essential programs like init are not "
"installed in standard locations."
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:381
msgid ""
"The general process for creating the symbolic links is as follows.  All the "
"programs (1) that are to be executed after the kernel has finished "
"initializing and before the pkgs script can be executed and (2) the "
"libraries these programs depend on must have symbolic links in the /bin, "
"/sbin, or /lib directories. The pkgs script calls the manager script to load "
"the packages, so all programs required by manager and the libraries they "
"depend on must also have symbolic links."
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:383
msgid "Subsection II.e.1. Program Symbolic Links"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:387
msgid ""
"Here is a list of programs whose symbolic links are typically required.  "
"Some systems may require additional programs. Those denoted by an asterisk "
"are mandatory."
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:399
#, no-wrap
msgid ""
" *1) init -- this program is executed by the kernel after initialization\n"
"       The kernel expects init to be in /sbin/init.\n"
" *2) bash -- this is executed by init to run the init scripts\n"
" *3) echo -- this is used by all init scripts to display messages\n"
" *4) ls -- used by the manager script\n"
" *5) find -- used by the manager script\n"
" *6) sed -- used by the manager script\n"
" *7) mount -- this is used by the mountkernfs, pkgs, and manager scripts\n"
"  8) mountpoint -- this is used by the mountkernfs script\n"
"  9) modprobe -- this is used by the modules script\n"
" 10) dmesg -- this is used by the consolelog script\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:403
#, no-wrap
msgid ""
"To create the symbolic link for a program, one must locate the program "
"first.\n"
"This can be achieved by typing:\n"
"  find /pkgs -name program_name\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:408
#, no-wrap
msgid ""
"Next, the symbolic link can be created:\n"
"  ln -sv /path/to/program_name /bin\n"
"    or\n"
"  ln -sv /path/to/program_name /sbin\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:412
#, no-wrap
msgid ""
"For example, if one wants to create the symbolic link for init, one must "
"first\n"
"locate it by typing:\n"
"  find /pkgs -name init\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:415
#, no-wrap
msgid ""
"If find produces the following result:\n"
"  /pkgs/sysvinit/2.86/sbin/init\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:418
#, no-wrap
msgid ""
"The symbolic link can then be created by typing:\n"
"  ln -sv /pkgs/sysvinit/2.86/sbin/init /sbin\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:420
msgid "Subsection II.e.2. Library Symbolic Links"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:425
#, no-wrap
msgid ""
"All of the above programs depend on shared libraries. It is for this "
"reason\n"
"links to the required shared libraries must be in /lib. To determine the\n"
"required libraries, type:\n"
"  ldd /path/to/program\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:428
#, no-wrap
msgid ""
"Next, search for the location of the library by typing:\n"
"  find /pkgs -name library_name\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:431
#, no-wrap
msgid ""
"Finally, create the symbolic link in /lib if one does not exist:\n"
"  ln -sv /path/to/library /lib\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:435
#, no-wrap
msgid ""
"For example, if one wishes to create the symbolic links for bash, one must\n"
"first determine the libraries it requires:\n"
"  ldd /bin/bash\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:444
#, no-wrap
msgid ""
"The ldd program may produce the following output:\n"
"  linux-vdso.so.1 =>  (0x00007ffff6bfe000)\n"
"  libreadline.so.5 => /lib/libreadline.so.5 (0x00007fc8ee804000)\n"
"  libhistory.so.5 => /lib/libhistory.so.5 (0x00007fc8ee6fc000)\n"
"  libncursesw.so.5 => /lib/libncursesw.so.5 (0x00007fc8ee596000)\n"
"  libdl.so.2 => /lib/libdl.so.2 (0x00007fc8ee492000)\n"
"  libc.so.6 => /lib/libc.so.6 (0x00007fc8ee258000)\n"
"  /lib64/ld-linux-x86-64.so.2 (0x00007fc8ee941000)\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:449
#, no-wrap
msgid ""
"For each of the files listed, a symbolic link should be created.\n"
"\"linux-vdso.so.1\" is skipped because it does not point to an\n"
"actual file. The library \"libhistory.so.5\" can be located by typing:\n"
"  find /pkgs -name libhistory.so.5\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:452
#, no-wrap
msgid ""
"If find produces the result:\n"
"  /pkgs/readline/5.2/lib/libhistory.so.5\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:455
#, no-wrap
msgid ""
"The symbolic link can be created by typing:\n"
"  ln -sv /pkgs/readline/5.2/lib/libhistory.so.5 /lib\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:457
msgid "Subsection II.e.3. Troubleshooting"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:462
msgid ""
"During system startup, if the kernel, init, or an init script reports it "
"cannot find a certain program, there are two possible reasons: (a) a valid "
"symbolic link to the program is not in /bin or /sbin, or (b) all the "
"necessary libraries for the program do not have valid symbolic links in "
"/lib."
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:464
msgid "Part III. Using the Package Manager"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:467
msgid ""
"Now that installation is completed, one can boot into the LFS system. This "
"section describes how to use the package manager."
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:469
msgid "Section III.a. Loading and Unloading"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:473
msgid ""
"The manager script does the grunt work for setting up the target "
"directories.  It provides two functionalities: (1) loading a package and (2) "
"unloading a package. Loading and unloading can be done as follows:"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:475
#, no-wrap
msgid "  /pkgs/manager load package-name [package-version]\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:477
msgid ""
"For example, if one wishes to load the package sed, version 4.1.5, one "
"types:"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:479
#, no-wrap
msgid "  /pkgs/manager load sed 4.1.5\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:482
msgid ""
"Specifying the package version is optional. If it is omitted, the first "
"version manager finds is used. Unloading the package follows the same "
"format:"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:484
#, no-wrap
msgid "  /pkgs/manager unload package-name [package-version]\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:486
msgid "To unload sed, version 4.1.5, type:"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:488
#, no-wrap
msgid "  /pkgs/manager unload sed 4.1.5\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:490
msgid "The package version must match the same version used to load the package."
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:492
msgid "Section III.b. Upgrading a package"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:495
msgid ""
"To upgrade a package, unload the package version that is already loaded, and "
"load the new package version."
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:499
#, no-wrap
msgid ""
"Suppose there are two versions of the fluxbox package installed:\n"
"  $ /pkgs/manager list fluxbox\n"
"  0.9.16 1.0.0\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:503
#, no-wrap
msgid ""
"To switch from 0.9.16 to 1.0.0, one types:\n"
"  # /pkgs/manager unload fluxbox 0.9.16\n"
"  # /pkgs/manager load fluxbox 1.0.0\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:505
msgid "Section III.c. Diagnostics"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:507
msgid "The manager script provides a few diagnostic tools:"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:510
#, no-wrap
msgid ""
"  * To list all of the packages available and their versions, type:\n"
"      /pkgs/manager list\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:513
#, no-wrap
msgid ""
"  * To list all the available versions of a package, type:\n"
"      /pkgs/manager list package-name\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:516
#, no-wrap
msgid ""
"  * To check that the correct directories are being unionized, type:\n"
"      /pkgs/manager test package-name [package_version]\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:518
msgid "Section III.d. Limitations"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:524
msgid ""
"One of the goals of the package manager is minimalism. Features found in "
"most package managers are not available in the one presented here because of "
"this choice. However, the limitations listed here can be overcome by "
"extending the functionality of the package manager. The scripts are not "
"designed to be a byzantine of code, and they contain comments to ease "
"hacking."
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:529
msgid ""
"The manager script cannot determine what packages are loaded. There are no "
"checks made when a package is loaded. Issuing a load command to a package "
"already loaded has no effect. Unloading a package that is not loaded will "
"result in an error from UnionFS."
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:532
msgid ""
"If a package depends on another, it is up to the user to load that "
"package. No dependency calculations are performed by the package manager."
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:534
msgid "Section III.d. When to Reload a Package"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:537
msgid ""
"If a package's contents are modified, there are certain situations where "
"reloading a package is necessary for changes to take effect."
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:543
msgid ""
"Adding files or directories to a source directory like etc or bin does not "
"require a reload. Assume there is a package samba, version 2.10.13. There is "
"the directory share in the package. If a file called mynotes.txt is added to "
"the package's share directory, reloading the package will not be needed, "
"since mynotes.txt will immediately appear in /usr/share."
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:550
msgid ""
"Adding a source directory where one did not exist before requires a "
"reload. Assume there is the package gtk with version 2.10.13.  This package "
"only contains the directory usr; in other words, the directory "
"/pkgs/gtk/2.10.13 only contains the directory usr.  If an etc directory, "
"which did not exist before, is created in /pkgs/gtk/2.10.13, a reload is "
"necessary."
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:554
#, no-wrap
msgid ""
"Reloads can be accomplished by typing:\n"
"  /pkgs/manager unload package-name package-version\n"
"  /pkgs/manager load package-name package-version\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:558
#, no-wrap
msgid ""
"To reload the gtk package with version 2.10.13, one types:\n"
"  /pkgs/manager unload gtk 2.10.13\n"
"  /pkgs/manager load gtk 2.10.13\n"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:560
msgid "Section III.e. Editing Files in a Package"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:563
msgid ""
"When editing a file in a package, one should open the file from the /pkgs "
"directory, not from the target directory."
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:569
msgid ""
"Suppose there is a file in /pkgs/x.org/7.2/etc/X11/x.org, which also exists "
"as /etc/X11/x.org. If one wishes to edit this file, it should be opened from "
"/pkgs/x.org/7.2/etc/X11/x.org, not /etc/X11/x.org.  Changes made to "
"/pkgs/x.org/7.2/etc/X11/x.org will immediately become apparent in "
"/etc/X11/x.org."
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:575
msgid ""
"Even though they are technically the same file, if /etc/X11/x.org is edited, "
"UnionFS will physically create the directory /etc/X11, save the changes made "
"to /etc/X11/x.org, and delete /pkgs/x.org/7.2/etc/X11/x.org. This behavior "
"runs against the goal of keeping files in separate directories as much as "
"possible."
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:577
msgid "Section III.f. Uninstalling a package"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:580
msgid ""
"To uninstall a package, (a) unload the package, then (b) delete the package "
"directory."
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:582
msgid "Part IV. Concluding Remarks"
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:587
msgid ""
"The goal of this document is to present an alternative package manager based "
"on UnionFS to the de-facto standard of black-box style package managers.  "
"Users wishing for a higher degree of organization over files and directories "
"may find this type of package manager useful."
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:589
msgid "The ideas presented here can be extended, namely:"
msgstr ""

#. type: Bullet: '  1. '
#: origin/pkg_unionfs.txt:593
msgid ""
"Other operating systems, like the BSDs, can also take advantage of this type "
"of package management. In fact, the BSD kernels have supported union "
"directories for many years."
msgstr ""

#. type: Bullet: '  2. '
#: origin/pkg_unionfs.txt:597
msgid ""
"The capabilities of the package manager can be improved by hacking the "
"manager script or write additional scripts that automate the installation of "
"packages."
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:603
#, no-wrap
msgid ""
"     Moreover, replacing the manager script with something in a different\n"
"     scripting language may be better. Bash has been a difficult language "
"for\n"
"     the author, and rewriting the manager script in Python\n"
"     would reduce the amount of code and make it cleaner. Adding "
"functionality\n"
"     to the package manager is probably much easier in Python than Bash.\n"
msgstr ""

#. type: Bullet: '  3. '
#: origin/pkg_unionfs.txt:609
msgid ""
"Users can have personal packages in their home directories and can load and "
"unload them. This can be achieved by: (a) allowing mounting to non-root "
"users, (b) copying the manager script to the user's home directory, and (c) "
"modifying the script's \"pkg_dir\" and \"target_dir\" variables."
msgstr ""

#. type: Plain text
#: origin/pkg_unionfs.txt:612
#, no-wrap
msgid ""
"CHANGELOG:\n"
"  [2008-10-30]\n"
"    * Hint created.\n"
msgstr ""
