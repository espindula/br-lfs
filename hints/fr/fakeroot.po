# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2019-09-02 09:13+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Plain text
#: origin/fakeroot.txt:2
msgid "AUTHOR: Tushar Teredesai <tushar AT linuxfromscratch DOT org>"
msgstr ""

#. type: Plain text
#: origin/fakeroot.txt:4
msgid "DATE: 2006-01-17"
msgstr ""

#. type: Plain text
#: origin/fakeroot.txt:6
msgid "LICENSE: BSD"
msgstr ""

#. type: Plain text
#: origin/fakeroot.txt:8
msgid "SYNOPSIS: Fakeroot approach for package installation"
msgstr ""

#. type: Plain text
#: origin/fakeroot.txt:13
msgid ""
"DESCRIPTION: LFS and BLFS instructions install files directly into the root "
"directory without any kind of package management. Except for some simplistic "
"cases, not having some sort of package management on the system will lead to "
"problems."
msgstr ""

#. type: Plain text
#: origin/fakeroot.txt:17
msgid ""
"In this hint, I discuss a style of package management that is most commonly "
"used by distros - the fakeroot approach. And looking at the advantages, it "
"is no wonder why it is the most popular method."
msgstr ""

#. type: Plain text
#: origin/fakeroot.txt:25
msgid ""
"ATTACHMENTS: * "
"http://www.linuxfromscratch.org/hints/downloads/attachments/autotools-multiversion/autoconf-wrapper "
"* "
"http://www.linuxfromscratch.org/hints/downloads/attachments/autotools-multiversion/automake-wrapper "
"* "
"http://www.linuxfromscratch.org/patches/download/autoconf/autoconf-2.13-race.patch "
"* "
"http://www.linuxfromscratch.org/patches/download/autoconf/autoconf-2.13-fedora_macro_fixes-1.patch "
"* "
"http://www.linuxfromscratch.org/patches/download/automake/automake-1.4-p6-fedora_fixes.patch "
"* "
"http://www.linuxfromscratch.org/patches/download/automake/automake-1.5-fedora_fixes.patch"
msgstr ""

#. type: Plain text
#: origin/fakeroot.txt:28
msgid "PREREQUISITES: None."
msgstr ""

#. type: Plain text
#: origin/fakeroot.txt:30
msgid "HINT:"
msgstr ""

#. type: Plain text
#: origin/fakeroot.txt:37
msgid ""
"In the fakeroot approach, instead of installing the files into the final "
"location (i.e. /), the files are installed into a temporary location and "
"then moved to a different location. The way to achieve this is package "
"dependent.  Generally, the compilation instructions are identical to what "
"you will find in the LFS or BLFS book. It is only during the installation "
"that you need to modify the instructions."
msgstr ""

#. type: Plain text
#: origin/fakeroot.txt:76
#, no-wrap
msgid ""
"Before going into the details of the approach, let us check out the "
"advantages\n"
"of the fakeroot approach so that you can decide whether it is the right\n"
"technique for your system.\n"
"  * Does not require any additional packages to be installed on the "
"system.\n"
"  * Allows manipulating the installed files before then end up in their "
"final\n"
"    location. This removes patches in LFS such as "
"coreutils-remove-XXX.patch\n"
"    that will never be accepted upstream. It also allows performing "
"various\n"
"    maintainence operations such as compressing man and info pages. It "
"also\n"
"    allows you to not allow the package to replace certain files (such as\n"
"    configuration files).\n"
"  * Allows upgrading packages on a live system (including packages such as\n"
"    glibc). Anyone who has tried to upgrade qt while logged into kde knows\n"
"    what I am talking about:) Bumping off users for the duration of "
"package\n"
"    upgrades reflects poorly on the system administrator IMO.\n"
"  * If the package installation fails for some reason, there won't be a\n"
"    \"half-baked\" pacakge in /. Though a bit extreme, consider the "
"following\n"
"    example. You are building gcc in BLFS and run into a problem during "
"make\n"
"    install. You may be fscked since a partial gcc is installed in / which "
"may\n"
"    or may not run. You have also destroyed the previously installed "
"gcc. If\n"
"    you had installed it in fakeroot, you could have investigated the "
"cause,\n"
"    corrected the problem, removed the fakeroot directory and installed "
"the\n"
"    files again.\n"
"  * Allows checking of conflicts before the package is installed. For "
"example,\n"
"    heimdal installs executables that overwrite executables from other\n"
"    packages. If you blindly install heimdal into / you may not notice it\n"
"    until its too late.\n"
"  * Provides a clear distinction between post installation "
"configuration. LFS\n"
"    and BLFS only talk about installing packages (and sometimes about\n"
"    upgrading packages) but never about removing packages. Some packages "
"are\n"
"    particularly hard to remove. Just removing the files that were "
"installed\n"
"    by the package is not enough, you also need to run additional "
"commands.\n"
"    For example, for the GNOME packages you may need to uninstall schemas "
"and\n"
"    regenerate scrollkeeper files. With the fakeroot approach, you will "
"soon\n"
"    get into the habit of performing two additional steps:\n"
"    - post install config: Steps to be performed after the package is\n"
"      relocated to /.\n"
"    - post removal config: Steps to be performed after the package is "
"removed.\n"
"      Generally, this reverses whatever was done by the post install "
"config.\n"
msgstr ""

#. type: Plain text
#: origin/fakeroot.txt:99
#, no-wrap
msgid ""
"The steps to installing a package with this approach are as follows. If "
"you\n"
"are creating scripts for package installation, each of the following can be "
"a\n"
"function of its own.\n"
"  *) Unpack the source and apply patches if required.\n"
"       tar -xvf $pkg-$ver.tar.bz2\n"
"  *) Compile.\n"
"       cd $pkg-$ver\n"
"       ./configure --prefix=/usr\n"
"       make\n"
"  *) Optionally test the package.\n"
"       make -k check\n"
"  *) Install into fakeroot. Adjust the FAKEROOT envar to suit your system.\n"
"       FAKEROOT=/usr/fakeroot/$pkg-$ver\n"
"       make DESTDIR=$FAKEROOT install\n"
"  *) Perform whatever maintainence you need on the installed files.\n"
"  *) If upgrading the packaqge, perform post removal config steps for the\n"
"     previously installed version.\n"
"  *) Relocate the package to the final destination.\n"
"       cd $FAKEROOT\n"
"       tar cf - . | (cd / ; tar xf - )\n"
"  *) Perform post install configuration.\n"
"  *) If upgrading a package, remove files left over by the previous "
"version.\n"
msgstr ""

#. type: Plain text
#: origin/fakeroot.txt:110
#, no-wrap
msgid ""
"Hopefully, now you are convinced that the fakeroot approach is the right\n"
"approach for you. So lets get down to the details on how to achieve this.\n"
"Since it is impossible to include instructions for all the packages in LFS "
"and\n"
"BLFS, I will go through some common ways to install packages into "
"fakeroot. If\n"
"you get stuck in a particular package:\n"
"* Check out my build scripts at\n"
"  <http://linuxfromscratch.org/~tushar/build-scripts/>.\n"
"* Check out Gentoo Ebuilds at "
"<http://www.gentoo.org/cgi-bin/viewcvs.cgi/>.\n"
"* Check out Fedora spec files at\n"
"  <http://cvs.fedora.redhat.com/viewcvs/?root=core>.\n"
msgstr ""

#. type: Plain text
#: origin/fakeroot.txt:128
#, no-wrap
msgid ""
"Ways to install into fakeroot:\n"
"* Installation controlled using an envar.\n"
"  Since the fakeroot approach is the most commonly used approach for "
"package\n"
"  management, lot of package maintainers use an easy way to control the\n"
"  installation. Also, since most packages use autotools, the envar for\n"
"  fakeroot is DESTDIR. Hence the installation for this kind of packages "
"would\n"
"  be\n"
"    make DESTDIR=$FAKEROOT install\n"
"  Some packages may use a different envar for fakeroot. For example, glibc\n"
"  uses install_root. Check the INSTALL file in the package to find the "
"envar.\n"
"* Installation by modifying prefix during installation.\n"
"  For some older packages, a simple way to make the packages install into\n"
"  fakeroot is to change the prefix variable during installation.\n"
"    make prefix=$FAKEROOT/usr install\n"
"* Manual installation.\n"
"  Some packages are stubborn. Sometimes it is easier to install all files\n"
"  manually. This is convinient for packages that do not install few files.\n"
msgstr ""

#. type: Plain text
#: origin/fakeroot.txt:163
#, no-wrap
msgid ""
"Things to look out for:\n"
"* Sometimes packages do not create the destination file before installing\n"
"  files into a dir. Normally when installing into / this is not a problem\n"
"  since the destination dir such as /usr/bin would already have been "
"created.\n"
"  But when installing into a fakeroot, you may need to create these dirs\n"
"  manually using install -d.\n"
"* A small minority of packages hardcode the fakeroot directory into the "
"files.\n"
"  It is generally a good idea to peruse the logs.\n"
"* Packages that install info pages create a file /usr/share/info/dir. This\n"
"  file should be recreated after the package is install. Refer to the LFS\n"
"  book's section on texinfo on how to regenrate this file.\n"
"* Perl modules have two problems. One is that the file .packlist hardcodes "
"the\n"
"  FAKEROOT dir in it. This needs to be removed using sed. Additionally, "
"each\n"
"  module installs a shared file perllocal.pod. If the module is installed\n"
"  directly into /, the installation would have appended the new contents "
"to\n"
"  the file. Since we install into a fakeroot, we need to manually append\n"
"  this file to the system installed perllocal.pod and prevent installation "
"of\n"
"  the perllocal.pod installed by the module.\n"
"* Packages that install GConf schemas install the schemas automatically "
"during\n"
"  make install. Since we are installing into a fakeroot, this step needs to "
"be\n"
"  performed in the post installation config step. To disable installation "
"of\n"
"  the schmeas, either set the GCONF_DISABLE_MAKEFILE_SCHEMA_INSTALL var to\n"
"  true during make install or pass the --disable-schema-install switch to\n"
"  configure.\n"
"* For packages that install scrollkeeper catalogs, the scrollkeeper-update\n"
"  process needs to be disabled during installation and the scrollkeeper\n"
"  database needs to be updated in the post installation config.\n"
"* For packages that install fonts, fc-cache and gtk-updated-icon-cache needs "
"to\n"
"  be called during post installation config phase.\n"
"* For packages that install gtk immodules and loaders, the configuration "
"needs\n"
"  to be recreated manually by calling gtk-query-immodules and\n"
"  gdk-pixbuf-query-loaders.\n"
"* For packages that install mime db files, the mime database needs to be\n"
"  updated manually by calling update-mime-database.\n"
msgstr ""

#. type: Plain text
#: origin/fakeroot.txt:167
msgid ""
"If you feel adventorous, you can combine this hint with the pkg-user hint "
"for the unlimate package manager scheme:-) I have been using that for quite "
"some time and even though it is a little bit complex, it has served me well."
msgstr ""

#. type: Plain text
#: origin/fakeroot.txt:170
#, no-wrap
msgid ""
"CHANGELOG:\n"
"[2005-12-09]\n"
"  * Initial Version of the hint.\n"
msgstr ""
