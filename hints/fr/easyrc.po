# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2019-09-02 09:13+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Plain text
#: origin/easyrc.txt:43
#, no-wrap
msgid ""
"#  TITLE:          Runlevel control using eight runlevel files in one "
"directory.\n"
"#  LFS VERSION:    Tested on LFS-3.0\n"
"#  AUTHOR:         Ivo van Kamp\n"
"#  \n"
"#  \n"
"#  SYNOPSIS:       If you find symbolic start and kill links in eight "
"runlevel\n"
"#                  directories hard to manage, you could use eight rc "
"files\n"
"#                  (e.g. /etc/rc.d/rc[0-6,S].scripts) containing only the\n"
"#                  basenames of the init scripts in /etc/init.d. \n"
"#  \n"
"#  \n"
"#  HINT:\n"
"#  \n"
"#  Version 1.0 (17 dec 2001)\n"
"#  \n"
"#  TABLE OF CONTENTS:\n"
"#  1. /etc/inittab \n"
"#  2. /etc/rc.d/rc \n"
"#  3. /etc/rc.d/convert\n"
"#  4. /etc/rc.d/check \n"
"#  5. /etc/rc.d/template \n"
"#  6. /etc/init.d/functions \n"
"#  \n"
"#  For the sake of clarity all runlevels are handled in  the same manner.\n"
"#  As a result it's possible to call a start script within runlevels 0\n"
"#  and 6. The script used to behave the exact same way as the old rc file,\n"
"#  which had a bug when checking for start scripts in the sysinit "
"runlevel.\n"
"#  In the process of fixing this I removed the inconsistencies. If you "
"need\n"
"#  'mountfs' to stop after starting 'sendsignals', you need to make a\n"
"#  'umountfs', which should function like 'mountfs stop'. \n"
"#  \n"
"#  To implement all this you need to execute this hint and put the "
"extracted\n"
"#  files in the right places. Then start the 'convert' script in /etc/rc.d\n"
"#  to generate the /etc/rc.d/rc[0-6,S].scripts. Execute 'check' to see if\n"
"#  every init script exists. Now you have runlevel control.\n"
"#\n"
"#  PS:\n"
"#  - Don't forget to make 'umountfs' if you didn't already have one!\n"
"#  - Use a '#' at the beginning of start or stop entries inside the\n"
"#    rc[0-6,S].scripts to comment them out. \n"
"#  - Use 'check' to see what happens.\n"
"#\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:46
msgid "mkdir -p etc/rc.d mkdir -p etc/init.d"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:48 origin/easyrc.txt:74
msgid "#-------------------------------/etc/inittab----------------------------------"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:50
msgid "echo \"Extracting etc/inittab...\""
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:52
msgid "cat > etc/inittab << \"EOF\""
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:70
msgid ""
"id:3:initdefault: si::sysinit:/etc/rc.d/rc S l0:0:wait:/etc/rc.d/rc 0 "
"l1:S1:wait:/etc/rc.d/rc 1 l2:2:wait:/etc/rc.d/rc 2 l3:3:wait:/etc/rc.d/rc 3 "
"l4:4:wait:/etc/rc.d/rc 4 l5:5:wait:/etc/rc.d/rc 5 l6:6:wait:/etc/rc.d/rc 6 "
"ca:12345:ctrlaltdel:/sbin/shutdown -t1 -a -r now "
"su:S016:respawn:/sbin/sulogin 1:2345:respawn:/sbin/agetty tty1 9600 "
"2:2345:respawn:/sbin/agetty tty2 9600 3:2345:respawn:/sbin/agetty tty3 9600 "
"4:2345:respawn:/sbin/agetty tty4 9600 5:2345:respawn:/sbin/agetty tty5 9600 "
"6:2345:respawn:/sbin/agetty tty6 9600"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:72 origin/easyrc.txt:330 origin/easyrc.txt:392 origin/easyrc.txt:440 origin/easyrc.txt:457 origin/easyrc.txt:1020
msgid "EOF"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:77 origin/easyrc.txt:334
msgid "#-------------------------------/etc/rc.d/rc----------------------------------"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:79
msgid "echo \"Extracting etc/rc.d/rc...\""
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:81
msgid "cat > etc/rc.d/rc << \"EOF\""
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:91
#, no-wrap
msgid ""
"#!/bin/sh\n"
"#\n"
"# Begin /etc/rc.d/rc\n"
"#\n"
"# Thanks to Jason Pearce  - jason.pearce@linux.org\n"
"#       and Gerard Beekmans - gerard@linuxfromscratch.org\n"
"# print_error_msg based on ideas by Simon Perreault -\n"
"# nomis80@videotron.ca\n"
"#\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:121
#, no-wrap
msgid ""
"################################################################\n"
"#\n"
"# This script does two things in the following order:\n"
"#\n"
"# 1. Stop the init scripts for the current runlevel that\n"
"#    were started in the previous runlevel.\n"
"#\n"
"# 2. Start the init scripts for the current runlevel if they\n"
"#    got stopped (as described above) or if they have not\n"
"#    been started already by the previous runlevel.\n"
"#\n"
"# Ergo: Stop only if it was started and start only if it\n"
"# wasn't already or got stopped.\n"
"#\n"
"# The init scripts to be stopped or started are assumed to\n"
"# be in /etc/init.d/ and are referred to by the rc scripts\n"
"# in /etc/rc.d/rc[runlevel].scripts.\n"
"# \n"
"# NB: For the sake of clarity all runlevels are handled in\n"
"# the same manner. As a result it's possible to call a start\n"
"# script within runlevels 0 and 6. The script used to behave\n"
"# the exact same way as the old rc file, which had a bug\n"
"# when checking for start scripts in the sysinit runlevel.\n"
"# In the process of fixing this I removed the\n"
"# inconsistencies. If you need 'mountfs' to stop after\n"
"# starting 'sendsignals', you need to make a 'umountfs',\n"
"# which should function like 'mountfs stop'. \n"
"#\n"
"################################################################\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:125
msgid "# # Include the functions declared in the /etc/rc.d/functions file #"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:127 origin/easyrc.txt:405
msgid "source /etc/init.d/functions"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:132
msgid ""
"# # The print_error_msg function prints an error message when an unforeseen "
"# error occurred that wasn't trapped for some reason by a evaluate_retval # "
"call or error checking in different ways."
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:152
#, no-wrap
msgid ""
"print_error_msg()\n"
"{\n"
"        echo\n"
"        $FAILURE\n"
"        echo -n \"You should not read this error message. It means \"\n"
"        echo \"that an unforeseen error \"\n"
"        echo -n \"took place and subscript $i exited with \"\n"
"        echo \"a return value \"\n"
"        echo -n \"of $error_value for an unknown reason. If you're able \"\n"
"        echo \"to trace this error down \"\n"
"        echo -n \"to a bug in one of the files provided by this book, \"\n"
"        echo \"please be so kind to \"\n"
"        echo -n \"inform us at lfs-discuss@linuxfromscratch.org\"\n"
"        $NORMAL\n"
"        echo\n"
"        echo\n"
"        echo \"Press a key to continue...\"\n"
"        read\n"
"}\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:158
msgid ""
"# # If you uncomment the debug variable below none of the scripts will be # "
"executed, just the script name and parameters will be echo'ed to the # "
"screen so you can see how the scripts are called by rc.  #"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:161
msgid "# Un-comment the following for debugging.  # debug=echo"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:168
#, no-wrap
msgid ""
"#\n"
"# Start script or program.\n"
"#\n"
"startup() {\n"
"        $debug \"$@\"\n"
"}\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:172
msgid "# # Ignore CTRL-C only in this shell, so we can interrupt subprocesses.  #"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:174
msgid "trap \":\" INT QUIT TSTP"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:177
#, no-wrap
msgid ""
"echo -n \"Current runlevel: \" $RUNLEVEL\n"
"echo \"   Previous runlevel: \" $PREVLEVEL\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:183
msgid ""
"# # Now find out what the current and what the previous runlevel are. The # "
"$RUNLEVEL variable is set by init for all it's children. This script # runs "
"as a child of init.  #"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:185
msgid "runlevel=$RUNLEVEL"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:190
msgid ""
"# # Get first argument. Set new runlevel to this argument. If no runlevel # "
"was passed to this script we won't change runlevels.  #"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:197
#, no-wrap
msgid ""
"[ \"$1\" != \"\" ] && runlevel=$1\n"
"if [ \"$runlevel\" = \"\" ]\n"
"then\n"
"        echo \"Usage: $0 <runlevel>\" >&2\n"
"        exit 1\n"
"fi\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:199
msgid "previous=$PREVLEVEL"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:204
msgid ""
"# # If $PREVLEVEL is set to \"N\" and we're not in the sysinit # level then "
"we assume the previous runlevel to be sysinit.  #"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:206
msgid "[ \"$previous\" == \"N\" ] && [ \"$runlevel\" != \"S\" ] && previous=\"S\""
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:210
msgid "# # If previous is empty set it to 'N' c.q. 'No previous'.  #"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:212
msgid "[ \"$previous\" == \"\" ] && previous=\"N\""
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:214
msgid "export runlevel previous"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:218
msgid "# # Is there a rc script for the new runlevel? #"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:221
msgid "if [ -f $RCDIR/rc$runlevel.scripts ] then"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:226
#, no-wrap
msgid ""
"#\n"
"# If so, first collect all the stop scripts in the new run level.\n"
"#\n"
"        get_stop_scripts rc$runlevel.scripts STOP\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:237
#, no-wrap
msgid ""
"\tFIRSTTIME=1\n"
"\tfor i in $STOP \n"
"\tdo\n"
"\tif [ ! -f $SCRIPTDIR/$i ];\n"
"\tthen\n"
"\t\t$FAILURE \n"
"\t\techo \"Error: rc$runlevel.scripts:$SCRIPTDIR/$i not found\"\n"
"\t\t$NORMAL\n"
"\t\tcontinue\n"
"\tfi\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:246
#, no-wrap
msgid ""
"#\n"
"# Determine if there is a start script for this stop script in the\n"
"# previous runlevel.\n"
"#\n"
"        if [ \"$previous\" != \"N\" ]\n"
"        then\n"
"            get_start_scripts rc$previous.scripts previous_start $i\n"
"        fi\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:248
#, no-wrap
msgid "               [ ! \"$previous_start\" ] && continue\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:251
#, no-wrap
msgid ""
"               [ \"$FIRSTTIME\" ] && FIRSTTIME=\"\" && $WHITE &&\n"
"               echo \"Stop:\" && $NORMAL\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:255
msgid "# # If we found previous_start, run the stop script #"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:269
#, no-wrap
msgid ""
"\t\tstartup $SCRIPTDIR/$i stop\n"
"\t\terror_value=$?\n"
"#\n"
"# If the return value of the script is not 0, something went wrong with\n"
"# error checking inside the script. The print_error_msg function will be\n"
"# called and the message plus the return value of the stop script will be\n"
"# printed to the screen\n"
"#\n"
"\t\tif [ $error_value != 0 ]\n"
"\t\tthen\n"
"\t\t\tprint_error_msg\n"
"\t\tfi\n"
"\tdone\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:274
#, no-wrap
msgid ""
"#\n"
"# Now run the START scripts for this runlevel.\n"
"#\n"
"        get_start_scripts rc$runlevel.scripts START\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:285
#, no-wrap
msgid ""
"        FIRSTTIME=1\n"
"        for i in $START \n"
"        do\n"
"                if [ ! -f $SCRIPTDIR/$i ];\n"
"                then\n"
"                       $FAILURE \n"
"                       echo \"Error: rc$runlevel.scripts:$SCRIPTDIR/$i not "
"found\"\n"
"                       $NORMAL\n"
"                       continue\n"
"                fi\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:288
#, no-wrap
msgid ""
"                if [ \"$previous\" != \"N\" ]\n"
"                then\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:293
msgid ""
"# # Find current start script in previous runlevel and stop script in this # "
"runlevel.  #"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:296
#, no-wrap
msgid ""
"                    get_stop_scripts rc$runlevel.scripts stop $i\n"
"         get_start_scripts rc$previous.scripts previous_start $i\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:306
#, no-wrap
msgid ""
"#\n"
"# If there is a start script in the previous level level and no stop\n"
"# script in this level, we don't have to re-start the service;\n"
"# abort this iteration and start the next one.\n"
"#\n"
"\t\t\t  [ \"$previous_start\" ] && \n"
"\t\t\t  [ ! \"$stop\" ] && \n"
"\t\t\t  continue\n"
"                fi\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:309
#, no-wrap
msgid ""
"                [ \"$FIRSTTIME\" ] && FIRSTTIME=\"\" && $WHITE &&\n"
"                echo \"Start:\" && $NORMAL\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:312
#, no-wrap
msgid ""
"\t\tstartup $SCRIPTDIR/$i start\n"
"\t\terror_value=$?\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:319
msgid ""
"# # If the return value of the script is not 0, something went wrong with # "
"error checking inside the script. the print_error_msg function will be # "
"called and the message plus the return value of the stop script will be # "
"printed to the screen #"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:326
#, no-wrap
msgid ""
"\t\tif [ $error_value != 0 ]\n"
"\t\tthen\n"
"\t\t\tprint_error_msg\n"
"\t\tfi\n"
"        done\n"
"fi\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:328
msgid "# End /etc/rc.d/rc"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:332
msgid "chmod 754 etc/rc.d/rc"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:337 origin/easyrc.txt:396
msgid "#-------------------------------/etc/rc.d/convert-----------------------------"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:339
msgid "echo \"Extracting etc/rc.d/convert...\""
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:341
msgid "cat > etc/rc.d/convert << \"EOF\""
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:343
msgid "#!/bin/bash"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:348
msgid ""
"# # This script will convert runlevel directories to files # in the current "
"directory.  #"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:350
msgid "RCDIRS=`find /etc -type d -name \"rc[0-9,S].d\"`"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:353
msgid "for i in $RCDIRS do"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:355
#, no-wrap
msgid "    RCFILE=`basename $i | sed 's/\\.d/\\.scripts/g'`\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:360
#, no-wrap
msgid ""
"    if [ -f $RCFILE ];\n"
"    then\n"
"\techo -n \"RC file '$RCFILE' already exists! Overwrite ? (yes/no) [n] \"\n"
"\tread answer\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:373
#, no-wrap
msgid ""
"\tcase \"$answer\" in\n"
"\t\t y|Y|yes|Yes|YES)\n"
"\t\t    echo \"Creating backup of $RCFILE called $RCFILE.old\"\n"
"\t\t    cp -v $RCFILE $RCFILE.old\n"
"\t\t ;;\n"
"\t\t *)\n"
"\t\t    echo \"Generation of $RCFILE aborted.\"\n"
"                    echo\n"
"                    continue\n"
"\t\t ;;\n"
"\tesac\n"
"    fi\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:382
#, no-wrap
msgid ""
"    echo \"Generating $RCFILE...\"\n"
"    echo\n"
"    echo \"#----------START----------\" > $RCFILE \n"
"    for x in $i/S* \n"
"    do\n"
"        [ ! -h $x ] && continue\n"
"                echo `basename $x` | sed 's/^.[0-9]*//' >> $RCFILE \n"
"    done\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:390
#, no-wrap
msgid ""
"    echo \"#----------STOP----------\" >> $RCFILE \n"
"    for x in $i/K* \n"
"    do\n"
"        [ ! -h $x ] && continue\n"
"                echo `basename $x` | sed 's/^.[0-9]*//' >> $RCFILE \n"
"    done\n"
"done\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:394
msgid "chmod 754 etc/rc.d/convert"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:399 origin/easyrc.txt:444
msgid "#-------------------------------/etc/rc.d/check-------------------------------"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:401
msgid "echo \"Extracting etc/rc.d/check...\""
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:403
msgid "cat > etc/rc.d/check << \"EOF\""
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:407
msgid "SCRIPTS=`ls *.scripts`"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:422
#, no-wrap
msgid ""
"function find_scripts()\n"
"{\n"
"  if [ \"$1\" == \"\" ]; then echo; fi\n"
"  for SCRIPT in $1;\n"
"  do\n"
"  echo -n -e \"\\t\" $SCRIPT\n"
"  if [ ! -f $SCRIPTDIR/$SCRIPT ];\n"
"    then\n"
"    print_status failure\n"
"  else\n"
"    print_status success\n"
"  fi\n"
"  done\n"
"}\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:424
msgid "echo"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:438
#, no-wrap
msgid ""
"for SCRIPTFILE in $SCRIPTS;\n"
"do\n"
"  $DARK\n"
"  echo $SCRIPTFILE\n"
"  $NORMAL\n"
"  echo -n \"Start:\"\n"
"  get_start_scripts $SCRIPTFILE START\n"
"  find_scripts \"$START\" \n"
"  echo -n \"Stop:\"\n"
"  get_stop_scripts $SCRIPTFILE STOP\n"
"  find_scripts \"$STOP\" \n"
"  echo\n"
"done\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:442
msgid "chmod 754 etc/rc.d/check"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:447 origin/easyrc.txt:459
msgid "#-------------------------------/etc/rc.d/template----------------------------"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:449
msgid "echo \"Extracting etc/rc.d/template...\""
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:451
msgid "cat > etc/rc.d/template << \"EOF\""
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:453
msgid "#----------START----------"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:455
msgid "#----------STOP-----------"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:462 origin/easyrc.txt:1021
msgid "#-------------------------------/etc/init.d/functions-------------------------"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:464
msgid "echo \"Extracting etc/init.d/functions...\""
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:466
msgid "cat > etc/init.d/functions << \"EOF\""
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:469
msgid "#!/bin/sh # Begin /etc/init.d/functions"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:473
msgid "SCRIPTDIR=\"/etc/init.d\" RCDIR=\"/etc/rc.d\" PATH=\"/bin:/usr/bin\""
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:494
#, no-wrap
msgid ""
"#\n"
"# get_scripts (rc script file, return variable, do start or stop init "
"scripts\n"
"#              switch, [optional init script to search])\n"
"#\n"
"function get_scripts()\n"
"{\n"
"export $2=\"`echo -e $3\"\\n\"$4 | cat - $RCDIR/$1 |\n"
"awk '{\n"
"    if (NR==1) {switch=$0;x=0;}\n"
"    if (NR==2) {searchscript=$0;}\n"
"    if (NR>2) {\n"
"        do\n"
"        {\n"
"           if ($0 ~ /.*START.*/ ) {\n"
"               (switch) ? begin=1 : begin=0;\n"
"           }\n"
"           if ($0 ~ /.*STOP.*/) {\n"
"               (switch) ? begin=0 : begin=1;\n"
"           }\n"
"           if ($0 ~ /^ *#/) continue;\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:504
#, no-wrap
msgid ""
"           if (begin) {\n"
"              if (searchscript!=\"\") { if ($0==searchscript) print 1 }\n"
"              else print;\n"
"           }\n"
"        }\n"
"        while (getline>0)\n"
"    }\n"
"}'`\"\n"
"}\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:513
#, no-wrap
msgid ""
"#\n"
"# get_start_scripts (rc script file, return variable, [init script to "
"search])\n"
"#\n"
"function get_start_scripts()\n"
"{\n"
"   switch=\"1\";\n"
"   get_scripts $1 $2 $switch $3\n"
"}\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:522
#, no-wrap
msgid ""
"#\n"
"# get_stop_scripts (rc script file, return variable, [init script to "
"search])\n"
"#\n"
"function get_stop_scripts()\n"
"{\n"
"   switch=\"0\";\n"
"   get_scripts $1 $2 $switch $3\n"
"}\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:531
msgid ""
"# Set a few variables that influence the text that's printed on the # "
"screen. The SET_COL variable starts the text in the column number # decided "
"by the COL and WCOL section (as defined by the COL # variable). NORMAL "
"prints text in normal mode.  # SUCCESS prints text in a green colour and "
"FAILURE prints text in a red # colour #"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:534
msgid ""
"# If COLUMNS hasn't been set yet (bash sets it but not when called as # sh), "
"do it ourself"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:542
#, no-wrap
msgid ""
"        if [ -z \"$COLUMNS\" ]\n"
"        then\n"
"                # Get the console device if we don't have it already\n"
"                # This is ok by the FHS as there is a fallback if\n"
"                # /usr/bin/tty isn't available, for example at bootup.\n"
"                test -x /usr/bin/tty && CONSOLE=`/usr/bin/tty`\n"
"                test -z \"$CONSOLE\" && CONSOLE=/dev/console\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:545
#, no-wrap
msgid ""
"                # Get the console size (rows columns)\n"
"                SIZE=$(stty size < $CONSOLE)\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:549
#, no-wrap
msgid ""
"                # Strip off the rows leaving the columns\n"
"                COLUMNS=${SIZE#*\\ }\n"
"        fi\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:562
msgid ""
"COL=$[$COLUMNS - 10] WCOL=$[$COLUMNS - 30] SET_COL=\"echo -en "
"\\\\033[${COL}G\" SET_WCOL=\"echo -en \\\\033[${WCOL}G\" NORMAL=\"echo -en "
"\\\\033[0;39m\" SUCCESS=\"echo -en \\\\033[1;32m\" WARNING=\"echo -en "
"\\\\033[1;33m\" DARK=\"echo -en \\\\033[1;30m\" WHITE=\"echo -en "
"\\\\033[1;37m\" BLUE=\"echo -en \\\\033[1;34m\" LIGHTBLUE=\"echo -en "
"\\\\033[1;36m\" FAILURE=\"echo -en \\\\033[1;31m\""
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:570
msgid ""
"# # The evaluate_retval function evaluates the return value of the process # "
"that was run just before this function was called. If the return value # was "
"0, indicating success, the print_status function is called with # the "
"'success' parameter. Otherwise the print_status function is called # with "
"the failure parameter.  #"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:580
#, no-wrap
msgid ""
"evaluate_retval()\n"
"{\n"
"        if [ $? = 0 ]\n"
"        then\n"
"                print_status success\n"
"        else\n"
"                print_status failure\n"
"        fi\n"
"}\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:587
msgid ""
"# # The print_status prints [ OK ] or [FAILED] to the screen. OK appears # "
"in the colour defined by the SUCCESS variable and FAILED appears in # the "
"colour defined by the FAILURE variable. Both are printed starting # in the "
"column defined by the COL variable.  #"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:590
msgid "print_status()  {"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:595 origin/easyrc.txt:643 origin/easyrc.txt:713 origin/easyrc.txt:877 origin/easyrc.txt:974
msgid ""
"# # If no parameters are given to the print_status function, print usage # "
"information.  #"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:601
#, no-wrap
msgid ""
"        if [ $# = 0 ]\n"
"        then\n"
"                echo \"Usage: print_status {success|failure}\"\n"
"                return 1\n"
"        fi\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:628
#, no-wrap
msgid ""
"        case \"$1\" in\n"
"                success)\n"
"                        $SET_COL\n"
"                        echo -n \"[  \"\n"
"                        $SUCCESS\n"
"                        echo -n \"OK\"\n"
"                        $NORMAL\n"
"                        echo \"  ]\"\n"
"                        ;;\n"
"                warning)\n"
"                        $SET_COL\n"
"                        echo -n \"[ \"\n"
"                        $WARNING\n"
"                        echo -n \"ATTN\"\n"
"                        $NORMAL\n"
"                        echo \" ]\"\n"
"                        ;;\n"
"                failure)\n"
"                        $SET_COL\n"
"                        echo -n \"[\"\n"
"                        $FAILURE\n"
"                        echo -n \"FAILED\"\n"
"                        $NORMAL\n"
"                        echo \"]\"\n"
"                        ;;\n"
"        esac\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:630 origin/easyrc.txt:701 origin/easyrc.txt:1016
msgid "}"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:635
msgid ""
"# # The loadproc function starts a process (often a daemon) with # proper "
"error checking #"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:638
msgid "loadproc()  {"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:655
#, no-wrap
msgid ""
"        if [ $# = 0 ]\n"
"        then\n"
"                echo \"Usage: loadproc {program}\"\n"
"                exit 1\n"
"        fi\n"
"#\n"
"# Find the basename of the first parameter (the daemon's name without\n"
"# the path\n"
"# that was provided so /usr/sbin/syslogd becomes plain 'syslogd' after\n"
"# basename ran)\n"
"#\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:662
#, no-wrap
msgid ""
"        base=$(/usr/bin/basename $1)\n"
"#\n"
"# the pidlist variable will contains the output of the pidof command.\n"
"# pidof will try to find the PID's that belong to a certain string;\n"
"# $base in this case\n"
"#\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:664 origin/easyrc.txt:750 origin/easyrc.txt:913
#, no-wrap
msgid "        pidlist=$(/bin/pidof -o $$ -o $PPID -o %PPID -x $base)\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:666 origin/easyrc.txt:752 origin/easyrc.txt:915
#, no-wrap
msgid "        pid=\"\"\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:678
#, no-wrap
msgid ""
"        for apid in $pidlist\n"
"        do\n"
"                if [ -d /proc/$apid ]\n"
"                then\n"
"                        pid=\"$pid $apid\"\n"
"                fi\n"
"        done\n"
"#\n"
"# If the $pid variable contains anything (from the previous for loop) it\n"
"# means the daemon is already running\n"
"#\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:686
#, no-wrap
msgid ""
"        if [ ! -n \"$pid\" ]\n"
"        then\n"
"#\n"
"# Empty $pid variable means it's not running, so we run \"$@\" (all\n"
"# parameters giving to this function from the script) and then check the\n"
"# return value\n"
"#\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:694
#, no-wrap
msgid ""
"                \"$@\"\n"
"                evaluate_retval\n"
"        else\n"
"#\n"
"# The variable $pid was not empty, meaning it was already running. We'll\n"
"# print [ ATTN ] now\n"
"#\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:699
#, no-wrap
msgid ""
"                $SET_WCOL\n"
"                echo -n \"Already running\"\n"
"                print_status warning\n"
"        fi\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:705
msgid "# # The killproc function kills a process with proper error checking #"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:708
msgid "killproc()  {"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:719
#, no-wrap
msgid ""
"        if [ $# = 0 ]\n"
"        then\n"
"                echo \"Usage: killproc {program} [signal]\"\n"
"                exit 1\n"
"        fi\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:726
msgid ""
"# # Find the basename of the first parameter (the daemon's name without # "
"the path # that was provided so /usr/sbin/syslogd becomes plain 'syslogd' "
"after # basename ran)  #"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:728 origin/easyrc.txt:891
#, no-wrap
msgid "        base=$(/usr/bin/basename $1)\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:735
msgid ""
"# # Check if we gave a signal to kill the process with (like -HUP, -TERM, # "
"-KILL, etc) to this function (the second parameter). If no second # "
"parameter was provided set the nolevel variable. Else set the # killlevel "
"variable to the value of $2 (the second parameter)  #"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:742
#, no-wrap
msgid ""
"        if [ \"$2\" != \"\" ]\n"
"        then\n"
"                killlevel=-$2\n"
"        else\n"
"                nolevel=1\n"
"        fi\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:748 origin/easyrc.txt:911
msgid ""
"# # the pidlist variable will contains the output of the pidof command.  # "
"pidof will try to find the PID's that belong to a certain string; # $base in "
"this case #"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:760 origin/easyrc.txt:923
#, no-wrap
msgid ""
"        for apid in $pidlist\n"
"        do\n"
"                if [ -d /proc/$apid ]\n"
"                then\n"
"                        pid=\"$pid $apid\"\n"
"                fi\n"
"        done\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:765
msgid ""
"# # If $pid contains something from the previous for loop it means one or # "
"more PID's were found that belongs to the processes to be killed #"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:768 origin/easyrc.txt:931
#, no-wrap
msgid ""
"        if [ -n \"$pid\" ]\n"
"        then\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:773
msgid ""
"# # If no kill level was specified we'll try -TERM first and then sleep # "
"for 2 seconds to allow the kill to be completed #"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:777
#, no-wrap
msgid ""
"                if [ \"$nolevel\" = 1 ]\n"
"                then\n"
"                        /bin/kill -TERM $pid\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:784
msgid ""
"# # If after -TERM the PID still exists we'll wait 2 seconds before # trying "
"to kill it with -KILL. If the PID still exist after that, wait # two more "
"seconds. If the PIDs still exist by then it's safe to assume # that we "
"cannot kill these PIDs.  #"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:804
#, no-wrap
msgid ""
"                        if /bin/ps h $pid >/dev/null 2>&1\n"
"                        then\n"
"                                /usr/bin/sleep 2\n"
"                                if /bin/ps h $pid > /dev/null 2>&1\n"
"                                then\n"
"                                        /bin/kill -KILL $pid\n"
"                                        if /bin/ps h $pid > /dev/null 2>&1\n"
"                                        then\n"
"                                                /usr/bin/sleep 2\n"
"                                        fi\n"
"                                fi\n"
"                        fi\n"
"                        /bin/ps h $pid >/dev/null 2>&1\n"
"                        if [ $? = 0 ]\n"
"                        then\n"
"#\n"
"# If after the -KILL it still exists it can't be killed for some reason\n"
"# and we'll print [FAILED]\n"
"#\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:807 origin/easyrc.txt:840
#, no-wrap
msgid ""
"                                print_status failure\n"
"                        else\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:812
msgid ""
"# # It was killed, remove possible stale PID file in /var/run and # print [ "
"OK ] #"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:817
#, no-wrap
msgid ""
"                                /bin/rm -f /var/run/$base.pid\n"
"                                print_status success\n"
"                        fi\n"
"                else\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:822
msgid ""
"# # A kill level was provided. Kill with the provided kill level and wait # "
"for 2 seconds to allow the kill to be completed #"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:831
#, no-wrap
msgid ""
"                        /bin/kill $killlevel $pid\n"
"                        if /bin/ps h $pid > /dev/null 2>&1\n"
"                        then\n"
"                                /usr/bin/sleep 2\n"
"                        fi\n"
"                        /bin/ps h $pid >/dev/null 2>&1\n"
"                        if [ $? = 0 ]\n"
"                        then\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:837
msgid ""
"# # If ps' return value is 0 it means it ran ok which indicates that the # "
"PID still exists. This means the process wasn't killed properly with # the "
"signal provided. Print [FAILED] #"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:846
msgid ""
"# # If the return value was 1 or higher it means the PID didn't exist # "
"anymore which means it was killed successfully. Remove possible stale # PID "
"file and print [ OK ] #"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:852
#, no-wrap
msgid ""
"                                /bin/rm -f /var/run/$base.pid\n"
"                                print_status success\n"
"                        fi\n"
"                fi\n"
"        else\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:856
msgid "# # The PID didn't exist so we can't attempt to kill it. Print [ ATTN ] #"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:862 origin/easyrc.txt:961
#, no-wrap
msgid ""
"                $SET_WCOL\n"
"                echo -n \"Not running\"\n"
"                print_status warning\n"
"        fi\n"
"}\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:869
msgid ""
"# # The reloadproc functions sends a signal to a daemon telling it to # "
"reload it's configuration file. This is almost identical to the # killproc "
"function with the exception that it won't try to kill it with # a -KILL "
"signal (aka -9)  #"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:872
msgid "reloadproc()  {"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:883
#, no-wrap
msgid ""
"        if [ $# = 0 ]\n"
"        then\n"
"                echo \"Usage: reloadproc {program} [signal]\"\n"
"                exit 1\n"
"        fi\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:889
msgid ""
"# # Find the basename of the first parameter (the daemon's name without # "
"the path that was provided so /usr/sbin/syslogd becomes plain 'syslogd' # "
"after basename ran)  #"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:898
msgid ""
"# # Check if we gave a signal to send to the process (like -HUP)  # to this "
"function (the second parameter). If no second # parameter was provided set "
"the nolevel variable. Else set the # killlevel variable to the value of $2 "
"(the second parameter)  #"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:905
#, no-wrap
msgid ""
"        if [ -n \"$2\" ]\n"
"        then\n"
"                killlevel=-$2\n"
"        else\n"
"                nolevel=1\n"
"        fi\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:928
msgid ""
"# # If $pid contains something from the previous for loop it means one or # "
"more PID's were found that belongs to the processes to be reloaded #"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:935
msgid "# # If nolevel was set we will use the default reload signal SIGHUP.  #"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:941
#, no-wrap
msgid ""
"                if [ \"$nolevel\" = 1 ]\n"
"                then\n"
"                        /bin/kill -SIGHUP $pid\n"
"                        evaluate_retval\n"
"                else\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:945
msgid "# # Else we will use the provided signal #"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:950
#, no-wrap
msgid ""
"                        /bin/kill $killlevel $pid\n"
"                        evaluate_retval\n"
"                fi\n"
"        else\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:955
msgid ""
"# # If $pid is empty no PID's have been found that belong to the process.  # "
"Print [ ATTN ] #"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:966
msgid ""
"# # The statusproc function will try to find out if a process is running # "
"or not #"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:969
msgid "statusproc()  {"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:980
#, no-wrap
msgid ""
"        if [ $# = 0 ]\n"
"        then\n"
"                echo \"Usage: status {program}\"\n"
"                return 1\n"
"        fi\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:984
msgid "# # $pid will contain a list of PID's that belong to a process #"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:988
#, no-wrap
msgid ""
"        pid=$(/bin/pidof -o $$ -o $PPID -o %PPID -x $1)\n"
"        if [ -n \"$pid\" ]\n"
"        then\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:993
msgid ""
"# # If $pid contains something, the process is running, print the contents # "
"of the $pid variable #"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:997
#, no-wrap
msgid ""
"                echo \"$1 running with Process ID $pid\"\n"
"                return 0\n"
"        fi\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:1002
msgid ""
"# # If $pid doesn't contain it check if a PID file exists and inform the # "
"user about this stale file.  #"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:1014
#, no-wrap
msgid ""
"        if [ -f /var/run/$1.pid ]\n"
"        then\n"
"                pid=$(/usr/bin/head -1 /var/run/$1.pid)\n"
"                if [ -n \"$pid\" ]\n"
"                then\n"
"                        echo \"$1 not running but /var/run/$1.pid exists\"\n"
"                        return 1\n"
"                fi\n"
"        else\n"
"                echo \"$1 is not running\"\n"
"        fi\n"
msgstr ""

#. type: Plain text
#: origin/easyrc.txt:1018
msgid "# End /etc/init.d/functions"
msgstr ""
