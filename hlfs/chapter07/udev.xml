<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
  "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../general.ent">
  %general-entities;
]>

<sect1 id="bootable-udev">
  <?dbhtml filename="udev.html"?>

  <title>Gestion des périphériques et modules sur un système HLFS</title>

  <indexterm zone="bootable-udev">
    <primary sortas="a-Udev">Udev</primary>
    <secondary>usage</secondary>
  </indexterm>

  <para>Dans <xref linkend="chapter-building-system"/>, nous avons
  installé le paquet Udev. Avant d'aller dans les détails concernant son
  fonctionnement, un bref historique des méthodes précédentes de gestion
  des périphériques est nécessaire.</para>

  <para>Les systèmes Linux en général utilisent traditionnellement une
  méthode de création de périphériques statiques avec laquelle un grand
  nombre de n&oelig;uds périphériques est créé sous 
  <filename class="directory">/dev</filename> (quelque fois des milliers
  de n&oelig;uds), quel le matériel correspondant existe ou pas. Ceci se
  fait typiquement avec un script <command>MAKEDEV</command>, qui
  contient des appels au programme <command>mknod</command> avec les
  numéros de périphériques majeurs et mineurs pour chaque périphérique
  possible qui pourrait exister dans le monde.</para>

  <para>En utilisant la méthode udev, seuls les périphériques détectés
  par le noyau obtiennent des n&oelig;uds périphériques créés pour eux.
  Comme ces n&oelig;uds périphériques seront créés à chaque lancement du
  système, ils seront stockés dans un 
  <systemitem class="filesystem">tmpfs</systemitem> (un système de
  fichiers qui réside entièrement en mémoire). Les n&oelig;uds
  périphériques ne requièrent pas beaucoup d'espace disque, donc la
  mémoire utilisée est négligeable.</para>

  <sect2>
    <title>Historique</title>
    
    <para>En février 2000, un nouveau système de fichiers appelé
    <systemitem class="filesystem">devfs</systemitem> a été intégré au
    noyau 2.3.46 et rendu disponible pour la série 2.4 des noyaux
    stables. Bien qu'il soit présent dans le source du noyau, cette
    méthode de création dynamique de périphérique n'a jamais reçu un
    support inconditionnel des développeurs du noyau.</para>

    <para>Le principal problème de l'approche adopté par 
    <systemitem class="filesystem">devfs</systemitem> était la façon dont il gérait la
    détection, la création et le nommage des périphériques. Ce dernier problème, le
    nommage des périphériques, était peut-être le plus critique. Il est
    généralement accepté que s'il est possible de configurer les noms des
    périphériques, alors la politique de nommage des périphériques revient à
    l'administrateur du système, et du coup n'est pas imposée par un ou
    des développeur(s) en particulier. Le système de fichiers
    <systemitem class="filesystem">devfs</systemitem> souffre aussi de 
    conditions particulières inhérentes à son concept et ne peut pas
    être  corrigé sans une revue importante du noyau. Il a aussi été
    marqué comme obsolète pendant une longue période &mdash; à cause
    d'un manque de  maintenance &mdash; et a finalement été supprimé du
    noyau en juin 2006.</para>

    <para>Avec le développement du noyau instable 2.5, sorti ensuite en
    tant que la série 2.6 des noyaux stables, un nouveau système de
    fichiers virtuel appelé 
    <systemitem class="filesystem">sysfs</systemitem> est arrivé. Le
    d'exporter une vue de la configuration matérielle du système pour
    les processus en espace utilisateur. Avec cette représentation
    visible de l'espace utilisateur, la possibilité de voir un
    remplacement de l'espace utilisateur pour  
    <systemitem class="filesystem">devfs</systemitem> est devenu
    beaucoup plus réaliste.</para>

  </sect2>

  <sect2>
    <title>Implémentation d'Udev</title>

    <sect3>
      <title>Sysfs</title>

      <para>Le système de fichier
      <systemitem class="filesystem">sysfs</systemitem>. On pourrait se
      demander comment <systemitem class="filesystem">sysfs</systemitem>
      connaît les périphériques présents sur un système et quels numéros
      de périphériques devraient être utilisés. Les pilotes qui ont été
      compilés directement dans le noyau enregistrent leur objet avec
      <systemitem class="filesystem">sysfs</systemitem> quand ils sont
      détectés par le noyau. Pour les pilotes compilés en tant que
      modules, cet enregistrement surviendra quand le module sera
      chargé. Une fois que le système de fichier
      <systemitem class="filesystem">sysfs</systemitem> est monté (sur
      <filename class="directory">/sys</filename>), les données
      enregistrées par les pilotes internes avec
      <systemitem class="filesystem">sysfs</systemitem> sont disponibles
      pour les processus en espace utilisateur ainsi qu'à
      <command>udev</command> pour la création des n&oelig;uds
      périphériques.</para>

    </sect3>

    <sect3>
      <title>Scripts de démarrage d'Udev</title>

      <para>Le script de démarrage <command>S10udev</command> fait
      attention à créer les n&oelig;uds périphériques au lancement de
      Linux. Le script supprime la gestion des uevents de 
      <command>/sbin/hotplug</command> par défaut. On fait cela car le
      noyau n'a plus besoin de faire appel à un binaire externe. À la
      place, <command>udevd</command> écoutera sur un socket netlink les
      uevents que le noyau fait apparaître. Puis, le script de démarrage
      copie les n&oelig;uds des périphériques statiques qui existent
      dans <filename class="directory">/lib/udev/devices</filename> vers
      <filename class="directory">/dev</filename>. Cela est nécessaire
      car certains périphériques, répertoires et liens symboliques sont
      requis avant que les processus de gestion du périphérique
      dynamique ne soient disponibles pendant les premières étapes du
      démarrage d'un système, ou car  <command>udevd</command> lui-même
      les exige. La création des n&oelig;uds vers un périphérique
      statique dans
      <filename class="directory">/lib/udev/devices</filename> fournit
      aussi un environnement de travail facile pour les périphériques
      qui ne sont pas supportés par l'infrastructure de gestion des
      périphériques en dynamique. Ensuite le script de démarrage lance
      le démon Udev, <command>udevd</command>, qui agira sur tous les
      uevents qu'il reçoit. Enfin, le script de démarrage oblige le
      noyau à répéter des uevents pour chaque périphérique qui a été
      déjà enregistré puis attend que <command>udevd</command> les
      gère.</para>

    </sect3>

    <sect3>
      <title>Création de n&oelig;uds de périphérique</title>

      <para>To obtain the right major and minor number for a device, Udev relies
      on the information provided by <systemitem
      class="filesystem">sysfs</systemitem> in <filename
      class="directory">/sys</filename>.  For example,
      <filename>/sys/class/tty/vcs/dev</filename> contains the string
      <quote>7:0</quote>. This string is used by <command>udevd</command>
      to create a device node with major number <emphasis>7</emphasis> and minor
      <emphasis>0</emphasis>. The names and permissions of the nodes created
      under the <filename class="directory">/dev</filename> directory are
      determined by rules specified in the files within the <filename
      class="directory">/etc/udev/rules.d/</filename> directory. These are
      numbered in a similar fashion to the LFS-Bootscripts package. If
      <command>udevd</command> can't find a rule for the device it is creating,
      it will default permissions to <emphasis>660</emphasis> and ownership to
      <emphasis>root:root</emphasis>. Documentation on the syntax of the Udev
      rules configuration files are available in
      <filename>/usr/share/doc/udev-&udev-version;/index.html</filename></para>
      <para>Pour obtenir le bon nombre majeur ou mineur d'un périphérique,
      Udev s'appuie sur les informations fournies par 
      <systemitem class="filesystem">sysfs</systemitem> dans
      <filename class="directory">/sys</filename>. Par exemple,
      <filename>/sys/class/tty/vcs/dev</filename> contient la chaîne
      <quote>7:0</quote>. Cette chaîne est utilisée par <command>udevd</command>
      pour créer un n&oelig;ud de périphérique avec un nombre majeur
      <emphasis>7</emphasis> et et un nombre mineur <emphasis>0</emphasis>. Les noms
      et les droits des n&oelig;uds sous le répertoire 
      <filename class="directory">/dev</filename> sont déterminés par des
      règles spécifiés dans des fichiers à l'intérieur du répertoire
      <filename class="directory">/etc/udev/rules.d/</filename>. Celles-ci
      sont numérotées d'une façon similaire au paquet LFS-Bootscripts. Si
      <command>udevd</command> ne peut trouver une règle pour le périphérique
      qu'il est en train de créer, il attribuera par défaut des droits 
      <emphasis>660</emphasis> et la propriété à <emphasis>root:root</emphasis>.
      La documentation sur la syntaxe des fichiers de configuration des
      règles Udev est disponible dans <filename>/usr/share/doc/udev-&udev-version;/index.html</filename></para>

    </sect3>

    <sect3>
      <title>Chargement d'un module</title>

      <quote>pci:v00001319d00000801sv*sd*bc04sc01i*</quote>. Pour la
      plupart des périphériques, le pilote du bus définit l'alias du
      pilote qui gérerait le périphérique via  <systemitem
      class="filesystem">sysfs</systemitem>. Par exemple, le fichier
      <filename>/sys/bus/pci/devices/0000:00:0d.0/modalias</filename>
      pourrait contenir la chaîne 
      <quote>pci:v00001319d00000801sv00001319sd00001319bc04sc01i00</quote>.
      Il résultera des règles par défaut fournies avec Udev que
      <command>udevd</command> fera appel à 
      <command>/sbin/modprobe</command> avec le contenu de la variable
      d'environnement de l'uevent <envar>MODALIAS</envar>  qui devrait
      être la même que le contenu du fichier
      <filename>modalias</filename> dans sysfs), donc le chargement de
      après les expansions génériques.</para>

      <para>Dans cet exemple, cela signifie que, outre <emphasis>snd-fm801</emphasis>,
     le pilote <emphasis>forte</emphasis> obsolète (dont on ne veut pas 
     sera chargé s'il est disponible. Voir ci-dessous les moyens d'empêcher
      le chargement des modules indésirables.</para>

      <para>Le noyau lui-même est aussi capable de charger des modules
      de protocole réseau, de support pour des systèmes de fichiers et
      des NLS sur demande.</para>

    </sect3>

    <sect3>
      <title>Gestion des périphériques dynamiques/montables à chaud</title>

      <para>Quand vous connectez un périphérique, comme un lecteur MP3
      USB (<foreignphrase>Universal Serial Bus</foreignphrase>), le
      noyau reconnaît que le périphérique est maintenant connecté et
      génère un uevent. Cet uevent est alors géré par
      <command>udevd</command> comme décrit ci-dessus.</para>

    </sect3>

  </sect2>

  <sect2>
    <title>Problèmes avec le chargement des modules et la création des périphériques</title>

    <para>Il existe quelques problèmes connus pour la création
    automatique des n&oelig;uds périphériques&nbsp;:</para>

    <sect3>
      <title>Un module du noyau n'est pas chargé automatiquement</title>

      <para>Udev will only load a      <para>Udev ne chargera un module que s'il a un alias spécifique au
      bus et si le pilote du bus envoie correctement les alias
      nécessaires vers <systemitem class="filesystem">sysfs</systemitem>.
      Sinon, il faut organiser le chargement de modules par d'autres
      sens. Avec Linux-&linux-version;, Udev est connu pour charger les
      pilotes correctement écrits pour les périphériques INPUT, IDE,
      PCI, USB, SCSI, SERIO et FireWire.</para>

      <para>Pour déterminer si le pilote du périphérique dont vous avez
      besoin a le support nécessaire pour Udev, lancez
      <command>modinfo</command> avec le nom du module comme argument.
      Maintenant, essayez de localiser le répertoire du périphérique
      sous <filename class="directory">/sys/bus</filename> et vérifiez
      s'il y a un fichier <filename>modalias</filename> là-bas.</para>

      <para>Si le fichier <filename>modalias</filename> existe dans
      <systemitem class="filesystem">sysfs</systemitem>, si le pilote
      supporte le périphérique et s'il peut lui parler directement, mais
      s'il n'a pas d'alias, c'est un bogue dans le pilote. Chargez le
      pilote sans l'aide d'Udev et attendez que le problème soit corrigé
      plus tard.</para>
      <filename class="directory">/sys/bus</filename>, cela signifie que
      les développeurs du noyau n'ont pas encore ajouté de support
      modalias à ce type de bus. Avec Linux-&linux-version;, c'est le
      cas pour les bus ISA. Attendez que ce problème soit réparé dans
      les versions ultérieures du noyau.</para>

<para>Udev n'a pas du tout pour but de charger des pilotes
      <quote>emballés</quote> comme <emphasis>snd-pcm-oss</emphasis> et
      des pilotes non matériels comme <emphasis>loop</emphasis>.</para>

    </sect3>

    <sect3>
      <title>A kernel mod<title>Un module du noyau n'est pas chargé automatiquement et 
      Udev n'est pas prévu pour le charger</title>

      <para>Si le module <quote>emballé</quote> n'améliore que la
      fonctionnalité fournie par un autre module (comme
      <emphasis>snd-pcm-oss</emphasis> améliore la fonctionnalité de
      <emphasis>snd-pcm</emphasis> en rendant les cartes son disponibles
      pour les applications OSS), configurez la commande
      <command>modprobe</command> pour charger le wrapper après qu'Udev a
      chargé le module emballé. Pour cela, ajoutez une ligne
      <quote>install</quote> dans
      <filename>/etc/modprobe.conf</filename>. Par exemple&nbsp;:</para>

<screen role="nodump"><literal>install snd-pcm /sbin/modprobe -i snd-pcm ; \
    /sbin/modprobe snd-pcm-oss ; true</literal></screen>

      <para>Si le module en question n'est pas un emballage et s'avère
      utile en tant que tel, configurez le script de démarrage
      <command>S05modules</command> pour charger ce module sur le
      système de démarrage. Pour cela, ajoutez le nom du module au
      fichier <filename>/etc/sysconfig/modules</filename> sur une ligne
      séparée. Cela fonctionne aussi pour les modules emballage, mais ce
      n'est pas optimal dans ce cas.</para>

    </sect3>

    <sect3>
      <title>Udev charge un module indésirable</title>

      <para>Ne compilez pas le module, ou mettez-le en liste noire dans
      le fichier <filename>/etc/modprobe.conf</filename> comme cela est
      fait avec le module <emphasis>forte</emphasis> dans l'exemple
      ci-dessous&nbsp;:</para>

<screen role="nodump"><literal>blacklist forte</literal></screen>

      <para>Les modules en liste noire peuvent toujours être chargés
      manuellement avec la commande explicite 
      <command>modprobe</command>.</para>

    </sect3>

    <sect3>
      <title>Udev crée mal un périphérique, ou crée un mauvais lien
      symbolique</title>

      <para>Cela se produit normalement si une règle correspond à un
      périphérique de façon imprévue. Par exemple, une règle écrite
      avec des lacunes peut correspondre à un disque SCSI (comme désiré)
      et au périphérique générique SCSI correspondant (de façon
      incorrecte) par le fabricant. Trouvez la règle défectueuse et
      rendez-la plus précise..</para>

    </sect3>

    <sect3>
      <title>Une règle Udev fonctionne de manière non fiable</title>

      <para>Cela peut être une autre manifestation du problème
      précédent. Sinon, et si votre règle utilise les attributs de 
      <systemitem class="filesystem">sysfs</systemitem>, il se peut que
      ce soit un problème de timing du noyau, sur le point d'être
      corrigé dans les noyaux ultérieurs. Pour le moment, vous pouvez
      contourner en créant une règle qui attend l'attribut
      <systemitem class="filesystem">sysfs</systemitem> utilisé et en la
      mettant dans le fichier
      <filename>/etc/udev/rules.d/10-wait_for_sysfs.rules</filename>
      (créez ce fichier s'il n'existe pas). Merci d'informer la liste de
      développement de LFS si vous faites ainsi et que cela vous
      aide.</para>

    </sect3>

    <sect3>
      <title>Udev ne crée pas de périphérique</title>

      <para>Le texte ci-après assume que le pilote est compilé de
      manière statique dans le noyau ou qu'il est déjà chargé comme
      module, et que vous avez déjà vérifié qu'Udev ne crée pas de
      périphérique mal nommé.</para>

      <para>Udev n'a pas besoin d'information pour créer un n&oelig;ud
      périphérique si le pilote du noyau n'envoie pas ses données vers 
      <systemitem class="filesystem">sysfs</systemitem>. C'est ce qu'il
      y a de plus courant avec les pilotes de tierces parties à
      l'extérieur de l'arborescence du noyau. Créez un rieur de
      l'arborescence du noyau. Créez un n&oelig;ud de périphérique
      statique dans <filename>/lib/udev/devices</filename> avec les
      numéros majeurs/mineurs appropriés (voir le fichier
      <filename>devices.txt</filename> dans la documentation du noyau ou
      la documentation fournie par le fabricant du pilote tierce
      partie). Le n&oelig;ud du périphérique statique sera copié vers 
      <filename class="directory">/dev</filename> par le script de
      démarrage <command>S10udev</command>.</para>

    </sect3>

<!--
    <sect3>
      <title>Le nommage des périphériques change de manière aléatoire après
      le redémarrage</title>

      <title>Le nommage des périphériques change de manière aléatoire après
      le redémarrage</title>

      <title>Le nommage des périphériques change de manière aléatoire après
      le redémarrage</title>
      <para>Cela est dû au fait que Udev, par nature, gère les uevents
      et charge les modules en parallèle, donc dans un ordre
      imprévisible. Cela ne sera jamais <quote>corrigé</quote>. Vous ne
      devriez pas espérer que les noms des périphériques du noyau sont 
      stables. Créez plutôt vos propres règles qui rendent les liens
      symboliques stables basés sur des attributs stables du
      périphérique, comme une série de nombre ou la sortie de divers
      utilitaires *_id installés par Udev. Voir
      <xref linkend="ch-scripts-symlinks"/> et
      <xref linkend="bootable-network"/> pour des exemples.</para>
    </sect3>
-->

  </sect2>

  <sect2>
    <title>Lecture utile</title>

    <para>Des documentations supplémentaires sont disponibles sur les
    sites suivants&nbsp;:</para>

    <itemizedlist>

      <listitem>
        <para>A Userspace Implementation of <systemitem class="filesystem">devfs</systemitem>
        <ulink url="http://www.kroah.com/linux/talks/ols_2003_udev_paper/Reprint-Kroah-Hartman-OLS2003.pdf"/>
                (NdT&nbsp;: Une implémentation en espace utilisateur de devfs)</para>
      </listitem>

      <listitem>
        <para>La FAQ udev
        <ulink url="http://www.kernel.org/pub/linux/utils/kernel/hotplug/udev-FAQ"/></para>
      </listitem>

      <listitem>
        <para>The <systemitem class="filesystem">sysfs</systemitem> Filesystem
        <ulink url="http://www.kernel.org/pub/linux/kernel/people/mochel/doc/papers/ols-2005/mochel.pdf"/></para>
        (NdT&nbsp;: Le système de fichier
        <systemitem class="filesystem">sysfs</systemitem>)</para>
      </listitem>

    </itemizedlist>

  </sect2>

</sect1>
