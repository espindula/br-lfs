<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
  "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../../general.ent">
  %general-entities;
]>

<sect1 id="ch-scripts-eudev">
  <?dbhtml filename="eudev.html"?>

  <title>Gestion des périphériques et modules sur un système CLFS</title>

  <indexterm zone="ch-scripts-eudev">
    <primary sortas="a-Eudev">eudev</primary>
    <secondary>utilisation</secondary>
  </indexterm>

  <para>Dans <xref linkend="chapter-building-system"/>, nous avons
  installé le paquet Eudev. Avant d'aller dans les détails concernant son
  fonctionnement, un bref historique des méthodes précédentes de gestion
  des périphériques est nécessaire.</para>

  <para>Les systèmes Linux en général utilisent traditionnellement une
  méthode de création de périphériques statiques avec laquelle un grand
  nombre de n&oelig;uds périphériques est créé sous

  <filename class="directory">/dev</filename> (quelque fois des milliers
  de n&oelig;uds), que le matériel correspondant existe ou pas. Ceci se
  fait typiquement avec un script <command>MAKEDEV</command>, qui
  contient des appels au programme <command>mknod</command> avec les
  numéros de périphériques majeurs et mineurs pour chaque périphérique
  possible qui pourrait exister dans le monde.</para>

  <para>En utilisant la méthode Eudev, seuls les périphériques détectés
  par le noyau obtiennent des n&oelig;uds périphériques créés pour eux.
  Comme ces n&oelig;uds périphériques seront créés à chaque lancement du
  système, ils seront stockés dans un 

  <systemitem class="filesystem">tmpfs</systemitem> (un système de
  fichiers qui réside entièrement en mémoire). Les n&oelig;uds
  périphériques ne requièrent pas beaucoup d'espace disque, donc la
  mémoire utilisée est négligeable.</para>

  <sect2>
    <title>Historique</title>

    <para>En février 2000, un nouveau système de fichiers appelé
    <systemitem class="filesystem">devfs</systemitem> a été intégré au
    noyau 2.3.46 et rendu disponible pour la série 2.4 des noyaux
    stables. Bien qu'il soit présent dans le source du noyau, cette
    méthode de création dynamique de périphérique n'a jamais reçu un
    support inconditionnel des développeurs du noyau.</para>

    <para>Le principal problème de l'approche adopté par 
    <systemitem class="filesystem">devfs</systemitem> était la façon dont il gérait la
    détection, la création et le nommage des périphériques. Ce dernier problème, le
    nommage des périphériques, était peut-être le plus critique. Il est
    généralement accepté que s'il est possible de configurer les noms des
    périphériques, alors la politique de nommage des périphériques revient à
    l'administrateur du système, et du coup n'est pas imposée par un ou
    des développeur(s) en particulier. Le système de fichiers
    <systemitem class="filesystem">devfs</systemitem> souffre aussi de 
    conditions particulières inhérentes à son concept et ne peut pas
    être corrigé sans une revue importante du noyau. Il a aussi été
    marqué comme obsolète à cause
    d'un manque de maintenance.</para>

    <para>Avec le développement du noyau instable 2.5, sorti ensuite en
    tant que la série 2.6 des noyaux stables, un nouveau système de
    fichiers virtuel appelé 
    <systemitem class="filesystem">sysfs</systemitem> est arrivé. Le rôle
    de <systemitem class="filesystem">sysfs</systemitem> est d'exporter une vue 
    de la configuration matérielle du 
    système pour les processus en espace utilisateur.
    Avec cette représentation visible de l'espace utilisateur,
    la possibilité de voir un remplacement de l'espace utilisateur pour  
    <systemitem class="filesystem">devfs</systemitem> est devenu
    beaucoup plus réaliste.</para>

  </sect2>

  <sect2>
    <title>Implémentation d'Eudev</title>

    <sect3>
      <title>Sysfs</title>

      <para>Le système de fichier

      <systemitem class="filesystem">sysfs</systemitem>. On pourrait se
      demander comment <systemitem class="filesystem">sysfs</systemitem>
      connaît les périphériques présents sur un système et quels numéros
      de périphériques devraient être utilisés. Les pilotes qui ont été
      compilés directement dans le noyau enregistrent leur objet avec
      <systemitem class="filesystem">sysfs</systemitem> quand ils sont
      détectés par le noyau. Pour les pilotes compilés en tant que
      modules, cet enregistrement surviendra quand le module sera
      chargé. Une fois que le système de fichier
      <systemitem class="filesystem">sysfs</systemitem> est monté (sur
      <filename class="directory">/sys</filename>), les données
      enregistrées par les pilotes internes avec
      <systemitem class="filesystem">sysfs</systemitem> sont disponibles
      pour les processus en espace utilisateur ainsi qu'à
      <command>eudev</command> pour la création des n&oelig;uds
      périphériques.</para>

    </sect3>

    <sect3>
      <title>Scripts de démarrage d'Eudev</title>

      <para>Le script de démarrage <command>S10eudev</command> s'occupe
      de créer les n&oelig;uds périphériques au lancement de
      Linux. Le script supprime la gestion des uevents de 
      <command>/sbin/hotplug</command> par défaut. On fait cela car le
      noyau n'a plus besoin de faire appel à un binaire externe. À la
      place, <command>eudevd</command> écoutera sur une socket netlink les
      uevents que le noyau fait apparaître. Puis, le script de démarrage
      copie les n&oelig;uds des périphériques statiques qui existent
      dans <filename class="directory">/lib/eudev/devices</filename> vers
      <filename class="directory">/dev</filename>. Cela est nécessaire
      car certains périphériques, répertoires et liens symboliques sont
      requis avant que les processus de gestion du périphérique
      dynamique ne soient disponibles pendant les premières étapes du
      démarrage d'un système. La création des n&oelig;uds statiques dans
      <filename class="directory">/lib/eudev/devices</filename> fournit
      aussi un environnement de travail facile pour les périphériques
      qui ne sont pas supportés par l'infrastructure de gestion des
      périphériques en dynamique. Ensuite le script de démarrage lance
      le démon Eudev, <command>eudevd</command>, qui agira sur tous les
      uevents qu'il reçoit. Enfin, le script de démarrage oblige le
      noyau à répéter des uevents pour chaque périphérique qui a été
      déjà enregistré puis attend que <command>eudevd</command> les
      gère.</para>

    </sect3>

    <sect3>
      <title>Création de n&oelig;uds de périphérique</title>

      <para>Pour obtenir le bon nombre majeur ou mineur d'un périphérique,
      Eudev s'appuie sur les informations fournies par 
      <systemitem class="filesystem">sysfs</systemitem> dans
      <filename class="directory">/sys</filename>. Par exemple,
      <filename>/sys/class/tty/vcs/dev</filename> contient la chaîne
      <quote>7:0</quote>. Cette chaîne est utilisée par <command>eudevd</command>
      <emphasis>7</emphasis> et un nombre mineur <emphasis>0</emphasis>. Les noms
      et les droits des n&oelig;uds sous le répertoire 
      <filename class="directory">/dev</filename> sont déterminés par des
      règles spécifiées dans des fichiers à l'intérieur du répertoire
		<filename class="directory">/etc/eudev/rules.d/</filename>. Celles-ci
      sont numérotées d'une façon similaire au paquet CLFS-Bootscripts. Si
      <command>eudevd</command> ne peut trouver une règle pour le périphérique
     qu'il est en train de créer, il attribuera par défaut des droits 
     <emphasis>660</emphasis> et la propriété à <emphasis>root:root</emphasis>.
     La documentation sur la syntaxe des fichiers de configuration des
     règles Eudev est disponible dans
     <filename>/usr/share/doc/eudev/writing_eudev_rules/index.html</filename></para>

    </sect3>

    <sect3>
      <title>Chargement d'un module</title>

      <para>Il se peut que les pilotes des périphériques compilés en
      module aient des aliases compilés en eux. Les aliases sont
      visibles dans la sortie du programme <command>modinfo</command> et
      sont souvent liés aux identifiants spécifiques au bus des
      périphériques supportés par un module. Par exemple, le pilote
      <emphasis>snd-fm801</emphasis> supporte les périphériques PCI
      ayant l'ID fabricant 0x1319 et l'ID de périphérique 0x0801, et il
      a un alias qui est 
      <quote>pci:v00001319d00000801sv*sd*bc04sc01i*</quote>. Pour la
      plupart des périphériques, le pilote du bus définit l'alias du
      pilote qui gérerait le périphérique via <systemitem
      class="filesystem">sysfs</systemitem>. Par exemple, le fichier
      <filename>/sys/bus/pci/devices/0000:00:0d.0/modalias</filename>
      pourrait contenir la chaîne 
      <quote>pci:v00001319d00000801sv00001319sd00001319bc04sc01i00</quote>.
      Il résultera des règles par défaut fournies avec Eudev que
      <command>eudevd</command> fera appel à 
      <command>/sbin/modprobe</command> avec le contenu de la variable
      d'environnement de l'uevent <envar>MODALIAS</envar> (qui devrait
      être la même que le contenu du fichier
      <filename>modalias</filename> dans sysfs), donc chargera tous les
      modules dont les alias correspondent à cette chaîne après les expansions génériques.</para>

      <para>Dans cet exemple, cela signifie que, outre <emphasis>snd-fm801</emphasis>,
     le pilote <emphasis>forte</emphasis> obsolète (et non désiré) 
     sera chargé s'il est disponible. Voir ci-dessous les moyens d'empêcher
      le chargement des modules indésirables.</para>

      <para>Le noyau lui-même est aussi capable de charger des modules
      de protocole réseau, de support pour des systèmes de fichiers et
      des NLS sur demande.</para>

    </sect3>

    <sect3>
      <title>Gestion des périphériques dynamiques/montables à chaud</title>

      <para>Quand vous connectez un périphérique, comme un lecteur MP3
      USB (<foreignphrase>Universal Serial Bus</foreignphrase>), le
      noyau reconnaît que le périphérique est maintenant connecté et
      génère un uevent. Cet uevent est alors géré par
      <command>eudevd</command> comme décrit ci-dessus.</para>

    </sect3>

  </sect2>

  <sect2>
    <title>Problèmes avec le chargement des modules et la création des périphériques</title>

    <para>Il existe quelques problèmes connus pour la création
    automatique des n&oelig;uds périphériques&nbsp;:</para>

    <sect3>
      <title>Un module du noyau n'est pas chargé automatiquement</title>

      <para>Eudev ne chargera un module que s'il a un alias spécifique au
      bus et si le pilote du bus envoie correctement les alias
      nécessaires vers <systemitem class="filesystem">sysfs</systemitem>.
      Sinon, il faut organiser le chargement de modules par d'autres
      moyens. Avec Linux-&linux-version;, Eudev est connu pour charger les
      pilotes correctement écrits pour les périphériques INPUT, IDE,
      PCI, USB, SCSI, SERIO et FireWire.</para>

      <para>Pour déterminer si le pilote du périphérique dont vous avez
      besoin a le support nécessaire pour 
Eudev, lancez
      <command>modinfo</command> avec le nom du module comme argument.
      Puis, essayez de localiser le répertoire du périphérique
      sous <filename class="directory">/sys/bus</filename> et vérifiez
      s'il y a un fichier <filename>modalias</filename> là-bas.</para>

      <para>Si le fichier <filename>modalias</filename> existe dans
      <systemitem class="filesystem">sysfs</systemitem>, alors le pilote
      supporte le périphérique et peut lui parler directement, mais
      s'il n'a pas d'alias, c'est un bogue dans le pilote. Chargez le
      pilote sans l'aide d'Eudev et attendez que le problème soit corrigé
      plus tard.</para>

      <para>S'il n'y a pas de fichier <filename>modalias</filename> dans
      le bon répertoire sous

      <filename class="directory">/sys/bus</filename>, cela signifie que
      les développeurs du noyau n'ont pas encore ajouté de support
      modalias à ce type de bus. Avec Linux-&linux-version;, c'est le
      cas pour les bus ISA. Attendez que ce problème soit réparé dans
      les versions ultérieures du noyau.</para>

      <para>Eudev n'a pas du tout pour but de charger des pilotes
      <quote>wrappers</quote> (qui emballent un autre pilote) comme <emphasis>snd-pcm-oss</emphasis> et
      des pilotes non matériels comme <emphasis>loop</emphasis>.</para>

    </sect3>

    <sect3>
      <title>Un module du noyau n'est pas chargé automatiquement et 
      Eudev n'est pas censé le charger</title>

      <para>Si le module <quote>wrapper</quote> n'améliore que la
      fonctionnalité fournie par un autre module (comme
      <emphasis>snd-pcm-oss</emphasis> améliore la fonctionnalité de
      <emphasis>snd-pcm</emphasis> en rendant les cartes son disponibles
      pour les applications OSS), configurez la commande
      <command>modprobe</command> pour charger le wrapper après qu'Eudev ait
      chargé le module emballé. Pour cela, ajoutez une ligne
      <quote>install</quote> dans
      <filename>/etc/modprobe.conf</filename>. Par exemple&nbsp;:</para>

<screen role="nodump"><literal>install snd-pcm /sbin/modprobe -i snd-pcm ; \
    /sbin/modprobe snd-pcm-oss ; true</literal></screen>

      <para>Si le module en question n'est pas un emballage et s'avère
      utile en tant que tel, configurez le script de démarrage
      <command>S05modules</command> pour charger ce module sur le
      système de démarrage. Pour cela, ajoutez le nom du module au
      fichier <filename>/etc/sysconfig/modules</filename> sur une ligne
      séparée. Cela fonctionne aussi pour les modules emballage, mais ce
      n'est pas optimal dans ce cas.</para>

    </sect3>

    <sect3>
      <title>Eudev charge un module indésirable</title>

      <para>Ne compilez pas le module, ou mettez-le en liste noire dans
      le fichier <filename>/etc/modprobe.conf</filename> comme cela est
      fait avec le module <emphasis>forte</emphasis> dans l'exemple
      ci-dessous&nbsp;:</para>

<screen role="nodump"><literal>blacklist forte</literal></screen>

      <para>Les modules en liste noire peuvent toujours être chargés
      manuellement avec la commande explicite 
      <command>modprobe</command>.</para>

    </sect3>

    <sect3>
      <title>Eudev crée mal un périphérique, ou crée un mauvais lien
      symbolique</title>

      <para>Cela se produit habituellement si une règle correspond à un
      périphérique de façon imprévue. Par exemple, une règle écrite
      avec des lacunes peut correspondre à un disque SCSI (comme désiré)
      et au périphérique générique SCSI correspondant (de façon
      incorrecte) du fabricant. Trouvez la règle défectueuse et
      rendez-la plus précise à l'aide de <command>eudevadm info</command>.</para>

    </sect3>

    <sect3>
      <title>Une règle Eudev fonctionne de manière non fiable</title>

      <para>Cela peut être une autre manifestation du problème
      précédent. Sinon, et si votre règle utilise les attributs de 
      <systemitem class="filesystem">sysfs</systemitem>, il se peut que
      ce soit un problème de timing du noyau, sur le point d'être
      corrigé dans les noyaux ultérieurs. Pour le moment, vous pouvez
      contourner en créant une règle qui attend l'attribut
      <systemitem class="filesystem">sysfs</systemitem> utilisé et en la
      mettant dans le fichier
      <filename>/etc/eudev/rules.d/10-wait_for_sysfs.rules</filename>. Merci d'informer la liste de
      développement de CLFS si vous faites ainsi et que cela vous
      aide.</para>

    </sect3>

    <sect3>
      <title>Eudev ne crée pas de périphérique</title>

      <para>Le texte ci-après assume que le pilote est compilé de
      manière statique dans le noyau ou qu'il est déjà chargé comme
      module, et que vous avez déjà vérifié qu'Eudev ne crée pas de
      périphérique mal nommé.</para>

      <para>Eudev n'a pas besoin d'information pour créer un n&oelig;ud
      périphérique si le pilote du noyau n'envoie pas ses données vers 
      <systemitem class="filesystem">sysfs</systemitem>. C'est ce qu'il
      y a de plus courant avec les pilotes de tierces parties à
      l'extérieur de l'arborescence du noyau. Créez un n&oelig;ud de
      périphérique statique dans <filename>/lib/eudev/devices</filename>
      avec les numéros majeurs/mineurs appropriés (voir le fichier
      <filename>devices.txt</filename> dans la documentation du noyau ou
      la documentation fournie par le fabricant du pilote tierce
      partie). Le n&oelig;ud du périphérique statique sera copié vers 
      <filename class="directory">/dev</filename> par le script de
      démarrage <command>S10eudev</command>.</para>

    </sect3>

    <sect3>
      <title>Le nommage des périphériques change de manière aléatoire après
      le redémarrage</title>

      <para>Cela est dû au fait qu'Eudev, par nature, gère les uevents
      et charge les modules en parallèle, donc dans un ordre
      imprévisible. Cela ne sera jamais <quote>corrigé</quote>. Vous ne
      devriez pas espérer que les noms des périphériques du noyau sont 
      stables. Créez plutôt vos propres règles qui rendent les liens
      symboliques stables basés sur des attributs stables du
      périphérique, comme une série de nombre ou la sortie de divers
      utilitaires *_id installés par Eudev. Voir

      <xref linkend="ch-scripts-symlinks"/> et

    <xref linkend="chapter-network"/> pour des exemples.</para>

    </sect3>

  </sect2>

  <sect2>
    <title>Lecture utile</title>

    <para>Des documentations supplémentaires sont disponibles sur les
    sites suivants&nbsp;:</para>

    <itemizedlist>

      <listitem>
        <para>The <systemitem class="filesystem">sysfs</systemitem> Filesystem
        <ulink url="http://www.kernel.org/pub/linux/kernel/people/mochel/doc/papers/ols-2005/mochel.pdf"/>

        (NdT&nbsp;: Le système de fichier

        <systemitem class="filesystem">sysfs</systemitem>)</para>
      </listitem>

    </itemizedlist>

  </sect2>

</sect1>

