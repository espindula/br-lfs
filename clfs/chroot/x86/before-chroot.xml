<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
  "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../../general.ent">
  %general-entities;
]>

<sect1 id="ch-chroot-before-chroot">
  <?dbhtml filename="before-chroot.html"?>
  <title>Avant d'entrer dans l'environnement Chroot</title>

  <sect2 role="determining-ifneeded">
    <title>Détermination si des étapes doivent être faites</title>

    <para>Avant que nous puissions entrer dans le chroot nous devons être certain que le système
    est dans un état propre. A ce point la variable d'environnement <envar>${CLFS_TARGET}</envar>
    n'existera plus, alors elle n'aura plus d'incidence sur le reste du libre - la plupart des paquets
    s'appuieront sur
    <command>config.guess</command> fourni par
    <xref linkend="ch-system-automake"/>. Les paquets qui n'utilisent pas autotools
    soit ne font pas attention à la triplette cible, ou ont leurs propres façons de déterminer
    sa valeur.   
   </para>

    <para>Dans les deux cas, l'information sur le cpu de l'hôte utilisé pour déterminer
    la triplette cible est verrouillé à la même valeur, 
    <command>uname -m</command>. En exécutant cette commande en dehors du chroot aussi bien que dans le 
    chroot retournera exactement la même sortie.
   </para>

   <para>Si vous n'êtes pas certain que votre hôte et la cible ont la même triplette cible, vous pouvez
    utiliser ce test pour déterminer quel est la triplette cible de l'hôte et si vous devez faire
    quelques étapes pour vous assurer que vous ne construisez pas pour la mauvaise architecture.
    Déballer l'archive
   <xref linkend="ch-system-automake"/> et
    <command>cd</command> dans le repertoire créé. Ensuite exécutez la suite pour voir
    quel est la triplette source détecté par 
    <command>config.guess</command>:</para>

<screen><userinput>build-aux/config.guess</userinput></screen>

    <para>si la sortie de cette commande n'est pas égale à ce qui est dans 
    <envar>${CLFS_TARGET}</envar> alors vous devez relire. Si c'est égal pour pouvez
     continuer dans
    <xref linkend="ch-chroot-chroot"/> en toute sécurité.</para>

  </sect2>

  <sect2 role="using-setarch">
    <title>Utilisation de Setarch</title>

    <para>Si votre hôte à un outil appelé <command>setarch</command>, cela peux résoudre votre problème, au moins
    si vous construisez pour i686. Dans un architecture tel que x86_64, l'utilisation de
    <command>setarch linux32 uname -m</command> donnera toujours i686 en sortie. Il n'est pas possible
    d'avoir une sortie à i486 ou i586.
</para>

    <para>Pour tester si setarch peut faire tous ce que vous voulez faire, exécutez la commande suivante depuis 
    l'intérieur du répertoire
    <xref linkend="ch-system-automake"/>:</para>

<screen><userinput>setarch linux32 build-aux/config.guess</userinput></screen>

    <para>Si la sortie de la commande précédente égale ce qui est dans 
    <envar>${CLFS_TARGET}</envar> alors vous avez une solution viable. Vous pouvez
    envelopper la commande chroot de la page suivante avec
    <command>setarch linux32</command>. Cela ressemblera à :</para>

<screen><userinput>setarch linux32 chroot "${CLFS}" /tools/bin/env -i \
    HOME=/root TERM="${TERM}" PS1='\u:\w\$ ' \
    PATH=/bin:/usr/bin:/sbin:/usr/sbin:/tools/bin \
    /tools/bin/bash --login +h</userinput></screen>

    <para>Si setarch fonctionne pour vous alors vous pouvez continuer en toute sécurité dans
    <xref linkend="ch-chroot-chroot"/>. Si non, il y a une option en plus couverte par ce livre.
    </para>

  </sect2>

  <sect2 role="using-uname_hack">
    <title>Utilisation d'un Uname Hack</title>

    <para os="uua">Uname Hack est un module du noyau qui modifie la sortie de
    <command>uname -m</command> en changeant directement la valeur détectée par la machine. Le module noyau 
    enregistre la valeur originales et la restaure quand le module est déchargé.</para>

    <variablelist os="uub" role="materials">
      <varlistentry>
        <term>Uname Hack (&uname_hack-version;) - &uname_hack-size;:</term>

        <listitem>
          <para>Page d'accueil&nbsp;: <ulink url="&uname_hack-home;"/></para>
          <para>Téléchargement&nbsp;: <ulink url="&uname_hack-url;"/></para>
          <para>Somme de contrôle MD5&nbsp;: <literal>&uname_hack-md5;</literal></para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para os="uuc">Extraire l'archive et <command>cd</command> dans le répertoire créé.
    Pour construire Uname Hack vous devez avoir les sources du noyau pour votre noyau
    actuellement en cours d'exécution . Construisez uname Hack avec la commande suivante ou similaire:
    </para>

<screen os="uud"><userinput>make uname_hack_fake_machine=i486</userinput></screen>

    <variablelist os="uue">
      <title>La signification des options de make et install:</title>

      <varlistentry os="uue1">
        <term><parameter>uname_hack_fake_machine=i486</parameter></term>
        <listitem>
          <para>Ce paramètre initialise la valeur par laquelle le type de machine sera
          changé. Elle peut être initialisée à i586 ou i686.
          </para>
        </listitem>
      </varlistentry>

    </variablelist>

    <para os="uuf">Dans le répertoire supérieure du paquet Uname Hack vous pouvez voir un fichier
     appelé <filename>uname_hack.ko</filename>. Dans que le module est chargé dans le noyau la sortie
    de 
    <command>uname -m</command> sera immédiatement changée.
     chargez le module noyau avec la commande suivante:
    </para>

<screen os="uug"><userinput>insmod uname_hack.ko</userinput></screen>

    <para os="uuh">Pour tester si Uname Hack fonctionne correctement, exécutez la commande
     suivant depuis l'intérieur du répertoire <xref linkend="ch-system-automake"/>:</para>

<screen os="uui"><userinput>build-aux/config.guess</userinput></screen>

    <para os="uuj">La sortie de la commande précédente devra être
    la même que la variable d'environnement
    <envar>${CLFS_TARGET}</envar>. si ce n'est pas le cas, vous pouvez essayer et obtenir de l'aude
     de la liste de diffusion de CLFS ou le canal IRC. Regardez
    <xref linkend="ch-intro-askforhelp"/> pour plus d'information.</para>

  </sect2>

</sect1>
