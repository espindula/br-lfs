<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
  "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../../general.ent">
  %general-entities;
]>

<sect1 id="ch-system-pkgmgt">
  <?dbhtml filename="pkgmgt.html"?>

  <title>Gestion de paquets</title>

  <para>La gestion de paquets est un ajout souvent demandé au livre
CLFS. Un gestionnaire de paquets permet de conserver une trace des
fichiers installés, simplifiant ainsi leur suppression ou leur mise à
jour. Un gestionnaire de paquets gérera tant les fichiers binaires et de
bibliothèque que l'installation des fichiers de configuration. Avant tout, 
NON &mdash;cette section ne parle pas d'un gestionnaire
de paquets particulier, elle n'en recommande pas non plus. Elle fait
un tour des techniques les plus populaires pour indiquer comment elles
fonctionnent. Le gestionnaire de paquets parfait pourrait faire
partie de ces techniques ou pourrait être une combinaison d'une ou
plusieurs techniques. Cette section mentionne brièvement les problèmes
pouvant survenir lors de la mise à jour des paquets.</para>

  <para>Parmi les raisons de l'absence d'un gestionnaire de paquets
  mentionné dans CLFS ou CBLFS&nbsp;:</para>

  <itemizedlist>
    <listitem>
      <para>S'occuper de la gestion de paquets est en dehors des buts de ces
      livres&mdash; visant à apprendre comment un système Linux est construit.</para>
    </listitem>

    <listitem>
      <para>Il existe de nombreuses solutions pour la gestion de paquets,
chacune ayant des forces et ses faiblesses. En inclure une qui
satisfait tout le monde est difficile.</para>
    </listitem>
  </itemizedlist>

  <para>Des astuces ont été écrites sur le thème de la gestion de
  paquets. Visitez le <ulink url="&hints-root;">Projet des
  astuces</ulink> et voyez celui qui satisfait vos besoins.</para>

  <sect2>
    <title>Problèmes de mise à jour</title>

    <para>Un gestionnaire de paquets facilite la mise à jour des
nouvelles versions au moment de leur publication. Généralement, les
instructions des livres CLFS et CBLFS peuvent être utilisées pour les
nouvelles versions. Voici quelques points à connaître pour une mise à
jour de paquets, spécifiquement sur un système en cours de
fonctionnement</para>

    <itemizedlist>
      <listitem>
        <para>Il est recommandé, si un des outils de l'ensemble des outils
        (glibc, gcc, binutils) doit être mis à jour vers une nouvelle version
        mineure, de reconstruire CLFS. Bien que vous <emphasis>pourriez</emphasis>
        être capable de ne pas reconstruire tous les paquets dans leur ordre 
        de dépendances. Nous ne vous le recommandons pas. Par exemple, si
        glibc-2.2.x a besoin d'être mis à jour vers glibc-2.3.x, il est
        préférable de reconstruire. Pour les mises à jour encore plus
        mineures, une simple réinstallation fonctionne généralement mais cela
        n'est pas garanti. Par exemple, mettre à jour de glibc-2.3.1 à
        glibc-2.3.2 ne causera aucun problème.</para>
      </listitem>

      <listitem>
        <para>Si un paquet contenant une bibliothèque partagée est mis à jour et
        si le nom de cette dernière est modifié, alors les paquets liés
        dynamiquement à la bibliothèque devront être recompilés pour être liés
        à la nouvelle bibliothèque. (Remarquez qu'il n'y a aucune corrélation entre
        la version du paquet et le nom de la bibliothèque.) Par exemple,
        considérez un paquet foo-1.2.3 qui installe une bibliothèque
        partagée de nom
        <filename class='libraryfile'>libfoo.so.1</filename>.
        Disons que vous mettez à jour le
        paquet avec une nouvelle version foo-1.2.4 qui installe une
        bibliothèque partagée de nom
        <filename class='libraryfile'>libfoo.so.2</filename>. Dans ce cas, tous les
        paquets liés dynamiquement à
        <filename class='libraryfile'>libfoo.so.1</filename> doivent être recompilés
        pour être liés à
        <filename class='libraryfile'>libfoo.so.2</filename>. Remarquez que vous ne devez pas supprimer
             les anciennes bibliothèques jusqu'à ce que les paquets indépendants
             soient recompilés.</para>
      </listitem>
      <listitem>
        <para>Si vous mettez à jour un système en cours d'exécution, soyez très attentif avec les paquets qui utilisent 
        <command>cp</command> au lieu de <command>install</command> pour installer les fichiers. La deuxième commande est 
        généralement plus sûre si l'exécutable ou la bibliothèque est déjà chargé en mémoire.</para>
      </listitem>
    </itemizedlist>

  </sect2>

  <sect2>
    <title>Techniques de gestion de paquets</title>

    <para>Ce qui suit est une liste des techniques habituelles de gestion de
     paquets. Avant de prendre une décision sur un gestionnaire de
      paquets, faites une recherche sur les différentes techniques et
      notamment leurs faiblesses.</para>

    <sect3>
      <title>Tout est dans ma tête&nbsp;!</title>

      <para>Oui, c'est une technique de gestion de paquets. Certains n'éprouvent
      pas le besoin d'un gestionnaire de paquets parce qu'ils connaissent
      très bien les paquets et connaissent les fichiers installés par chaque
      paquet. Certains utilisateurs n'en ont pas besoin parce qu'ils
      planifient la reconstruction entière de LFS lorsqu'un paquet est
      modifié.</para>

    </sect3>

    <sect3>
      <title>Installer dans des répertoires séparés</title>

      <para>C'est une gestion des paquets tellement simple qu'elle ne nécessite
      aucun paquet supplémentaire pour gérer les installations. Chaque
      paquet est installé dans un répertoire séparé. Par exemple, le
      paquet foo-1.1 est installé dans
      <filename class='directory'>/usr/pkg/foo-1.1</filename>
      et un lien symboique est créé vers
      <filename class='directory'>/usr/pkg/foo-1.1</filename>. Lors de l'installation de
      la nouvelle version foo-1.2, elle est installée dans
      <filename class='directory'>/usr/pkg/foo-1.2</filename>
      et l'ancien lien symbolique est remplacé par un lien symbolique vers la
      nouvelle version.</para>

      <para>Les variables d'environnement telles que <envar>PATH</envar>,
      <envar>LD_LIBRARY_PATH</envar>, <envar>MANPATH</envar>,
      <envar>INFOPATH</envar> et <envar>CPPFLAGS</envar> 
      ont besoin d'être étendues pour inclure
      <filename>/usr/pkg/foo</filename>. Pour plus que quelques paquets, ce 
      schéma devient ingérable.</para>

    </sect3>

    <sect3>
      <title>Gestion de paquet par lien symbolique</title>

      <para>C'est une variante de la technique précédente. Chaque paquet est
        installé de façon similaire au schéma précédent. Mais au lieu de créer
        le lien symbolique, chaque fichier dispose d'un lien symbolique vers
        son équivalent dans la hiérarchie
      <filename class='directory'>/usr</filename>. Ceci supprime le besoin d'étendre les variables
      d'environnement. Bien que les liens symboliques puissent être créés par
      l'utilisateur, pour automatiser la création, certains gestionnaires de
      paquets ont été écrits avec cette approche. Parmi les plus populaires se
      trouvent Stow, Epkg, Graft et Depot.</para>

      <para>L'installation doit être faussée, de façon à ce que chaque paquet pense
        qu'il est installé dans
       <filename class="directory">/usr</filename> alors qu'en réalité il est installé dans la
       hiérarchie <filename class="directory">/usr/pkg</filename>.
       Installer de cette manière n'est généralement pas une
       tâche triviale. Par exemple, considérez que vous installez un paquet
       libfoo-1.1. Les instructions suivantes pourraient ne pas installer
       correctement le paquet&nbsp;:</para>

<screen role="nodump"><userinput>./configure --prefix=/usr/pkg/libfoo/1.1
make
make install</userinput></screen>

      <para>L'installation fonctionnera mais les paquets dépendants pourraient ne
      pas se lier à libfoo comme vous vous y attenderiez. Si vous compilez un
      paquet qui se lie à
      <filename class='libraryfile'>/usr/pkg/libfoo/1.1/lib/libfoo.so.1</filename>
      au lieu de <filename class='libraryfile'>/usr/lib/libfoo.so.1</filename>
      comme vous le prévoyez. La bonne approche est d'utiliser la stratégie
      <envar>DESTDIR</envar> pour fausser l'installation du paquet. Cette approche
      fonctionne ainsi&nbsp;:</para>

<screen role="nodump"><userinput>./configure --prefix=/usr
make
make DESTDIR=/usr/pkg/libfoo/1.1 install</userinput></screen>

      <para>La plupart des paquets supportent cette approche mais elle pose
      problème à certains. Pour les paquets non compatibles, vous pouvez soit
      les installer manuellement soit trouver plus simple d'installer les
      paquets problématiques dans 
      <filename class='directory'>/opt</filename>.</para>

    </sect3>

    <sect3>
      <title>Basé sur un horodatage</title>

      <para>Avec cette technique, un fichier est horodaté avant
      l'installation du paquet. Après l'installation, une simple utilisation
      de la commande
      <command>find</command> avec les options appropriées peut générer une trace de
      tous les fichiers installés après que le fichier horodaté n'a été créé.
      install-log est un gestionnaire de paquets écrit avec cette approche.</para>

      <para>Bien que ce schéma ait l'avantage d'être simple, il a deux inconvénients. Si
      à l'installation, les fichiers sont installés sans être horodatés avec
      l'heure actuelle, ces fichiers ne seront pas suivis par le
      gestionnaire de paquets. De plus, ce schéma peut seulement être utilisé
      lorsqu'un seul paquet est installé à la fois. Les traces ne sont pas
      fiables si deux paquets sont installés dans deux consoles différentes.</para>

    </sect3>

    <sect3>
      <title>Basée sur LD_PRELOAD</title>

      <para>Dans cette approche, une bibliothèque est préchargée avant l'installation. Pendant l'installation, cette 
      bibliothèque poursuit les paquets qui vont être installés en s'attachant à divers exécutables tels que
      <command>cp</command>, <command>install</command>, <command>mv</command>
      et en surveillant les appels du système qui 
      modifient le système de fichiers. Pour que cette approche fonctionne, tous les exécutables doivent être liés de façon 
      dynamique sans le bit suid ou sgid. Il se peut que le préchargement de la bibliothèque provoque des effets secondaires 
      non souhaités pendant l'installation. Donc, il est conseillé d'effectuer des tests pour s'assurer que le gestionnaire 
      de paquets ne casse rien et enregistre tous les fichiers appropriés.</para>

    </sect3>

    <sect3>
      <title>Créer des archives de paquets</title>

      <para>Dans ce schéma, l'installation d'un paquet est faussée dans un
      répertoire séparé comme décrit plus haut. Après l'installation, une
      archive du paquet est créée en utilisant les fichiers installés.
      L'archive est ensuite utilisée pour installer le paquet soit sur la
      machine locale soit même sur d'autres machines.</para>

      <para>Cette approche est utilisée par la plupart des gestionnaires de paquets
        trouvés dans les distributions commerciales. Les exemples de gestionnaires
        qui suivent cette approche sont RPM (qui est d'ailleurs requis par la
      <ulink url="http://refspecs.linuxfoundation.org/lsb.shtml">Spécification
      de base de Linux Standard</ulink>), pkg-utils, apt de Debian, et le
      système Portage de Gentoo. Une astuce décrivant comment adopter ce 
      style de gestion de paquets pour les systèmes CLFS se trouve à
      <ulink url="&hints-root;Fakeroot"/>.</para>

    </sect3>

  </sect2>

</sect1>

