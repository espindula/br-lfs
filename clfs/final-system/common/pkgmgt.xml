<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
  "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../../general.ent">
  %general-entities;
]>

<sect1 id="ch-system-pkgmgt">
  <?dbhtml filename="pkgmgt.html"?>

  <title>Gestion de paquetages</title>

  <para>La gestion de paquetages est un ajout souvent demandé au livre
CLFS. Un gestionnaire de paquetages permet de conserver une trace des
fichiers installés, simplifiant ainsi leur suppression ou leur mise à
jour. Un gesjionnaire de paquetages gérera tant les fichiers binaires et de
bibliothèque que l'installation des fichiers de configuration. Avant tout, 
NON&mdash;cette section ne parle pas d'un gestionnaire
de paquetages particulier, elle n'en recommande pas non plus. Elle fait
un tour des techniques les plus populaires pour indiquer comment elles
fonctionnent. Le gestionnaire parfait de paquetages pourrait faire
partie de ces techniques ou pourrait être une combinaison d'une ou
plusieurs techniques. Cette section mentionne brièvement les problèmes
pouvant survenir lors de la mise à jour des paquetages.</para>

  <para>Parmi les raisons de l'absence d'un gestionnaire de paquetages
  mentionné dans CLFS ou CBLFS&nbsp;:</para>

  <itemizedlist>
    <listitem>
      <para>S'occuper de la gestion de paquetages est en dehors des buts de ces
      livres&mdash; visant à apprendre comment un système Linux est construit.</para>
    </listitem>

    <listitem>
      <para>Il existe de nombreuses solutions pour la gestion de paquetages,
chacune ayant des forces et ses faiblesses. En inclure une qui
satisfait tout le monde est difficile.</para>
    </listitem>
  </itemizedlist>

  <para>Des astuces ont été écrites sur le thème de la gestion de
  paquetages. Visitez le <ulink url="&hints-root;">Projet des
  astuces</ulink> et voyez celui qui satisfait vos besoins.</para>

  <sect2>
    <title>Problèmes de mise à jour</title>

    <para>Un gestionnaire de paquetages facilite la mise à jour des
nouvelles versions au moment de leur sortie. Généralement, les
instructions dans les livres CLFS et CBLFS peuvent être utilisées pour les
nouvelles versions. Voici quelques points à connaître pour une mise à
jour de paquetages, spécifiquement sur un système en cours de
fonctionnement</para>

    <itemizedlist>
      <listitem>
        <para>Il est recommandé, si un des outils de l'ensemble des outils
        (glibc, gcc, binutils) doit être mis à jour avec une nouvelle version
        mineure, de reconstruire CLFS. Bien que vous <emphasis>pourriez</emphasis>
        être capable de ne pas reconstruire tous les paquetages dans leur ordre 
        de dépendances. Nous ne vous le recommandons pas. Par exemple, si
        glibc-2.2.x a besoin d'être mis à jour vers glibc-2.3.x, il est
        préférable de reconstruire. Pour les mises à jour encore plus
        mineures, une simple réinstallation fonctionne généralement mais cela
        n'est pas garanti. Par exemple, mettre à jour de glibc-2.3.1 à
        glibc-2.3.2 ne causera aucun problème.</para>
      </listitem>

      <listitem>
        <para>Si un paquetage contenant une bibliothèque partagée est mis à jour et
        si le nom de cette dernière est modifié, alors les paquetages liées
        dynamiquement à la bibliothèque devront être recompilés pour être liés
        à la nouvelle bibliothèque. (Notez qu'il n'y a aucun corrélation entre
        la version du paquetage et le nom de la bibliothèque.) Par exemple,
        considérez un paquetage foo-1.2.3 qui installe une bibliothèque
        partagée de nom
        <filename class='libraryfile'>libfoo.so.1</filename>.
        Disons que vous mettez à jour le
        paquetage avec une nouvelle version foo-1.2.4 qui installe une
        bibliothèque partagée de nom
        <filename class='libraryfile'>libfoo.so.2</filename>. Dans ce cas, tous les
        paquetages liés dynamiquement à
        <filename class='libraryfile'>libfoo.so.1</filename> doivent être recompilés
        pour être liés à
        <filename class='libraryfile'>libfoo.so.2</filename>. Notez que vous ne devez pas supprimer
             les anciennes bibliothèques jusqu'à ce que les paquetages indépendants
             soient recompilés.</para>
      </listitem>
      <listitem>
        <para>Si vous mettez à jour un système en cours d'exécution, soyez très attentif avec les paquets qui utilisent 
        <command>cp</command> au lieu de <command>install</command> pour installer les fichiers. La deuxième commande est 
        généralement plus sûre si l'exécutable ou la bibliothèque est déjà ´chargé en mémoire.</para>
      </listitem>
    </itemizedlist>

  </sect2>

  <sect2>
    <title>Techniques de gestion de paquetages</title>

    <para>Ce qui suit est une liste de techniques habituelles de gestion de
     paquetages. Avant de prendre une décision sur un gestionnaire de
      paquetages, faites une recherche sur les différentes techniques et
      notamment leurs faiblesses.</para>

    <sect3>
      <title>Tout est dans ma tête&nbsp;!</title>

      <para>Oui, c'est une technique de gestion de paquetages. Certains n'éprouvent
      pas le besoin d'un gestionnaire de paquetages parce qu'ils connaissent
      très bien les paquetages et connaissent les fichiers installés par chaque
      paquetage. Certains utilisateurs n'en ont pas besoin parce qu'ils
      planifient la reconstruction entière de LFS lorsqu'un paquetage est
      modifié.</para>

    </sect3>

    <sect3>
      <title>Installer dans des répertoires séparés</title>

      <para>C'est une gestion des paquetages tellement simple qu'elle ne nécessite
      aucun paquetage supplémentaire pour gérer les installations. Chaque
      paquetage est installé dans un répertoire séparé. Par exemple, le
      paquetage foo-1.1 est installé dans
      <filename class='directory'>/usr/pkg/foo-1.1</filename>
      et un lien symboique est créé vers
      <filename class='directory'>/usr/pkg/foo-1.1</filename>. Lors de l'installation de
      la nouvelle version foo-1.2, elle est installée dans
      <filename class='directory'>/usr/pkg/foo-1.2</filename>
      et l'ancien lien symbolique est remplacé par un lien symbolique vers la
      nouvelle version.</para>

      <para>Les variables d'environnement telles que <envar>PATH</envar>,
      <envar>LD_LIBRARY_PATH</envar>, <envar>MANPATH</envar>,
      <envar>INFOPATH</envar> et <envar>CPPFLAGS</envar> 
      ont besoin d'être étendues pour inclure
      <filename>/usr/pkg/foo</filename>. Pour plus que quelques paquetages, ce 
      schéma devient ingérable.</para>

    </sect3>

    <sect3>
      <title>Gestion de paquetage par lien symbolique</title>

      <para>C'est une variante de la technique précédente. Chaque paquetage est
        installé de façon similaire au schéma précédent. Mais au lieu de réaliser
        le lien symbolique, chaque fichier dispose d'un lien symbolique vers
        son équivalent dans la hiérarchie
      <filename class='directory'>/usr</filename>. Ceci supprime le besoin d'étendre les variables
      d'environnement. Bien que les liens symboliques peuvent être créés par
      l'utilisateur, pour automatiser la création, certains gestionnaires de
      paquetages ont été écrit avec cette approche. Parmi les plus populaires se
      trouvent Stow, Epkg, Graft et Depot.</para>

      <para>L'installation doit être faussée, de façon à ce que chaque paquetage pense
        qu'il est installé dans
       <filename class="directory">/usr</filename> alors qu'en réalité il est installé dans la
       hiérarchie <filename class="directory">/usr/pkg</filename>.
       Installer de cette manière n'est généralement pas une
       tâche triviale. Par exemple, considérez que vous installez un paquetage
       libfoo-1.1. Les instructions suivantes pourraient ne pas installer
       correctement le paquetage&nbsp;:</para>

<screen role="nodump"><userinput>./configure --prefix=/usr/pkg/libfoo/1.1
make
make install</userinput></screen>

      <para>L'installation fonctionnera mais les paquetages dépendants pourraient ne
      pas lier libfoo comme vous vous y attenderiez. Si vous compilez un
      paquetage qui se lie à
      <filename class='libraryfile'>/usr/pkg/libfoo/1.1/lib/libfoo.so.1</filename>
      au lieu de <filename class='libraryfile'>/usr/lib/libfoo.so.1</filename>
      comme vous le prévoyez. La bonne approche est d'utiliser la stratégie
      <envar>DESTDIR</envar> pour fausser l'installation du paquetage. Cette approche
      fonctionne ainsi&nbsp;:</para>

<screen role="nodump"><userinput>./configure --prefix=/usr
make
make DESTDIR=/usr/pkg/libfoo/1.1 install</userinput></screen>

      <para>La plupart des paquetages supportent cette approche mais elle pose
      problème à certains. Pour les paquetages non compatibles, vous pouvez soit
      les installer manuellement soit trouver plus simple d'installer les
      paquetages problématiques dans 
      <filename class='directory'>/opt</filename>.</para>

    </sect3>

    <sect3>
      <title>Basé sur le temps</title>

      <para>Avec cette technique, un fichier est balisé avec l'heure avant
      l'installation du paquetage. Après l'installation, une simple utilisation
      de la commande
      <command>find</command> avec les options appropriées peut générer une trace de
      tous les fichiers installés après que le fichier temps ne soit créé.
      install-log est un gestionnaire de paquetages écrit avec cette approche.</para>

      <para>Bien que ce schéma ait l'avantage d'être simple, il a deux inconvénients. Si
      à l'installation, les fichiers sont installés sans balise de temps autre
      que l'heure actuelle, ces fichiers ne seront pas suivis par le
      gestionnaire de paquetages. De plus, ce schéma peut seulement être utilisé
      lorsqu'un seul paquetage est installé à la fois. Les traces ne sont pas
      fiables si deux paquetages sont installés dans deux consoles différentes.</para>

    </sect3>

    <sect3>
      <title>Basée sur LD_PRELOAD</title>

      <para>Dans cette approche, une bibliothèque est préchargée avant l'installation. Pendant l'installation, cette 
      bibliothèque poursuit les paquets qui vont être installés en s'attachant à divers exécutables tels que
      <command>cp</command>, <command>install</command>, <command>mv</command> et en poursuivant les appels du système qui 
      modifient le système de fichiers. Pour que cette approche fonctionne, tous les exécutables doivent être liés de façon 
      dynamique sans le bit suid ou sgid. Il se peut que le préchargement de la bibliothèque provoque des effets secondaires 
      non souhaités pendant l'installation. Donc, il est conseillé d'effectuer des tests pour s'assurer que le gestionnaire 
      de paquets ne casse rien et enregistre tous les fichiers appropriés.</para>

    </sect3>

    <sect3>
      <title>Créer des archives de paquetages</title>

      <para>Dans ce schéma, l'installation d'un paquetage est faussée dans un
      répertoire séparé comme décrit plus haut. Après l'installation, une
      archive du paquetage est créée en utilisant les fichiers installés.
      L'archive est ensuite utilisée pour installer le paquetage soit sur la
      machine locale soit même sur d'autres machines.</para>

      <para>Cette approche est utilisée par la plupart des gestionnaires de paquetages
        trouvés dans les distributions commerciales. Les exemples de gestionnaires
        qui suivent cette approche sont RPM (qui est parfois requis par la
      <ulink url="http://www.linux-foundation.org/en/Specifications">Spécification
      de base de Linux Standard</ulink>), pkg-utils, apt de Debian, et le
      système de portage de Gentoo. Une astuce décrivant comment adopter ce 
      style de gestion de paquetages pour les systèmes CLFS se trouve à
      <ulink url="&hints-root;fakeroot.txt"/>.</para>

    </sect3>

  </sect2>

</sect1>

